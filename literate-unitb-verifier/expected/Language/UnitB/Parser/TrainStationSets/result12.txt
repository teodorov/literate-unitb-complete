; m3/m3:ctr:plf/FIS/osgn@prime
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
(declare-sort sl$Blk 0)
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
; comment: we don't need to declare the sort Real
(declare-sort sl$Train 0)
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const ent sl$Blk)
(declare-const ext sl$Blk)
(declare-const in (set sl$Train))
(declare-const in@prime (set sl$Train))
(declare-const isgn Bool)
(declare-const isgn@prime Bool)
(declare-const loc (pfun sl$Train sl$Blk))
(declare-const loc@prime (pfun sl$Train sl$Blk))
(declare-const osgn (set sl$Blk))
(declare-const osgn@prime (set sl$Blk))
(declare-const p sl$Blk)
(declare-const plf (set sl$Blk))
(declare-fun card@@sl$Blk ( (set sl$Blk) ) Int)
(declare-fun card@@sl$Train ( (set sl$Train) ) Int)
(declare-fun dom@@sl$Train@@sl$Blk
             ( (pfun sl$Train sl$Blk) )
             (set sl$Train))
(declare-fun dom-rest@@sl$Train@@sl$Blk
             ( (set sl$Train)
               (pfun sl$Train sl$Blk) )
             (pfun sl$Train sl$Blk))
(declare-fun dom-subt@@sl$Train@@sl$Blk
             ( (set sl$Train)
               (pfun sl$Train sl$Blk) )
             (pfun sl$Train sl$Blk))
(declare-fun empty-fun@@sl$Train@@sl$Blk
             ()
             (pfun sl$Train sl$Blk))
(declare-fun finite@@sl$Blk ( (set sl$Blk) ) Bool)
(declare-fun finite@@sl$Train ( (set sl$Train) ) Bool)
(declare-fun injective@@sl$Train@@sl$Blk
             ( (pfun sl$Train sl$Blk) )
             Bool)
(declare-fun mk-set@@sl$Blk (sl$Blk) (set sl$Blk))
(declare-fun ovl@@sl$Train@@sl$Blk
             ( (pfun sl$Train sl$Blk)
               (pfun sl$Train sl$Blk) )
             (pfun sl$Train sl$Blk))
(declare-fun ran@@sl$Train@@sl$Blk
             ( (pfun sl$Train sl$Blk) )
             (set sl$Blk))
(define-fun all@@sl$Blk
            ()
            (set sl$Blk)
            ( (as const (set sl$Blk))
              true ))
(define-fun all@@sl$Train
            ()
            (set sl$Train)
            ( (as const (set sl$Train))
              true ))
(define-fun compl@@sl$Blk
            ( (s1 (set sl$Blk)) )
            (set sl$Blk)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$Train
            ( (s1 (set sl$Train)) )
            (set sl$Train)
            ( (_ map not)
              s1 ))
(define-fun elem@@sl$Blk
            ( (x sl$Blk)
              (s1 (set sl$Blk)) )
            Bool
            (select s1 x))
(define-fun empty-set@@sl$Blk
            ()
            (set sl$Blk)
            ( (as const (set sl$Blk))
              false ))
(define-fun empty-set@@sl$Train
            ()
            (set sl$Train)
            ( (as const (set sl$Train))
              false ))
(define-fun set-diff@@sl$Blk
            ( (s1 (set sl$Blk))
              (s2 (set sl$Blk)) )
            (set sl$Blk)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$Train
            ( (s1 (set sl$Train))
              (s2 (set sl$Train)) )
            (set sl$Train)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@sl$Blk
            ( (s1 (set sl$Blk))
              (s2 (set sl$Blk)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$Train
            ( (s1 (set sl$Train))
              (s2 (set sl$Train)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Blk
            ()
            (set sl$Blk)
            ( (as const (set sl$Blk))
              true ))
(define-fun sl$Train
            ()
            (set sl$Train)
            ( (as const (set sl$Train))
              true ))
(assert (forall ( (r (set sl$Blk)) )
                (! (=> (finite@@sl$Blk r) (<= 0 (card@@sl$Blk r)))
                   :pattern
                   ( (<= 0 (card@@sl$Blk r)) ))))
(assert (forall ( (r (set sl$Train)) )
                (! (=> (finite@@sl$Train r) (<= 0 (card@@sl$Train r)))
                   :pattern
                   ( (<= 0 (card@@sl$Train r)) ))))
(assert (forall ( (r (set sl$Blk)) )
                (! (= (= (card@@sl$Blk r) 0) (= r empty-set@@sl$Blk))
                   :pattern
                   ( (card@@sl$Blk r) ))))
(assert (forall ( (r (set sl$Train)) )
                (! (= (= (card@@sl$Train r) 0)
                      (= r empty-set@@sl$Train))
                   :pattern
                   ( (card@@sl$Train r) ))))
(assert (forall ( (x sl$Blk) )
                (! (= (card@@sl$Blk (mk-set@@sl$Blk x)) 1)
                   :pattern
                   ( (card@@sl$Blk (mk-set@@sl$Blk x)) ))))
(assert (forall ( (r (set sl$Blk)) )
                (! (= (= (card@@sl$Blk r) 1)
                      (exists ( (x sl$Blk) ) (and true (= r (mk-set@@sl$Blk x)))))
                   :pattern
                   ( (card@@sl$Blk r) ))))
(assert (forall ( (r (set sl$Blk))
                  (r0 (set sl$Blk)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Blk)
                       (= (card@@sl$Blk (union r r0))
                          (+ (card@@sl$Blk r) (card@@sl$Blk r0))))
                   :pattern
                   ( (card@@sl$Blk (union r r0)) ))))
(assert (forall ( (r (set sl$Train))
                  (r0 (set sl$Train)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Train)
                       (= (card@@sl$Train (union r r0))
                          (+ (card@@sl$Train r) (card@@sl$Train r0))))
                   :pattern
                   ( (card@@sl$Train (union r r0)) ))))
(assert (= (dom@@sl$Train@@sl$Blk empty-fun@@sl$Train@@sl$Blk)
           empty-set@@sl$Train))
(assert (forall ( (f1 (pfun sl$Train sl$Blk)) )
                (! (= (ovl@@sl$Train@@sl$Blk f1 empty-fun@@sl$Train@@sl$Blk)
                      f1)
                   :pattern
                   ( (ovl@@sl$Train@@sl$Blk f1 empty-fun@@sl$Train@@sl$Blk) ))))
(assert (forall ( (f1 (pfun sl$Train sl$Blk)) )
                (! (= (ovl@@sl$Train@@sl$Blk empty-fun@@sl$Train@@sl$Blk f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Train@@sl$Blk empty-fun@@sl$Train@@sl$Blk f1) ))))
(assert (forall ( (f1 (pfun sl$Train sl$Blk))
                  (f2 (pfun sl$Train sl$Blk)) )
                (! (= (dom@@sl$Train@@sl$Blk (ovl@@sl$Train@@sl$Blk f1 f2))
                      (union (dom@@sl$Train@@sl$Blk f1)
                             (dom@@sl$Train@@sl$Blk f2)))
                   :pattern
                   ( (dom@@sl$Train@@sl$Blk (ovl@@sl$Train@@sl$Blk f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Train sl$Blk))
                  (s1 (set sl$Train)) )
                (! (= (dom@@sl$Train@@sl$Blk (dom-rest@@sl$Train@@sl$Blk s1 f1))
                      (intersect s1 (dom@@sl$Train@@sl$Blk f1)))
                   :pattern
                   ( (dom@@sl$Train@@sl$Blk (dom-rest@@sl$Train@@sl$Blk s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Train sl$Blk))
                  (s1 (set sl$Train)) )
                (! (= (dom@@sl$Train@@sl$Blk (dom-subt@@sl$Train@@sl$Blk s1 f1))
                      (set-diff@@sl$Train (dom@@sl$Train@@sl$Blk f1) s1))
                   :pattern
                   ( (dom@@sl$Train@@sl$Blk (dom-subt@@sl$Train@@sl$Blk s1 f1)) ))))
(assert (= (ran@@sl$Train@@sl$Blk empty-fun@@sl$Train@@sl$Blk)
           empty-set@@sl$Blk))
(assert (injective@@sl$Train@@sl$Blk empty-fun@@sl$Train@@sl$Blk))
(assert (forall ( (x sl$Blk)
                  (y sl$Blk) )
                (! (= (elem@@sl$Blk x (mk-set@@sl$Blk y)) (= x y))
                   :pattern
                   ( (elem@@sl$Blk x (mk-set@@sl$Blk y)) ))))
(assert (forall ( (s1 (set sl$Blk))
                  (s2 (set sl$Blk)) )
                (! (=> (finite@@sl$Blk s1)
                       (finite@@sl$Blk (set-diff@@sl$Blk s1 s2)))
                   :pattern
                   ( (finite@@sl$Blk (set-diff@@sl$Blk s1 s2)) ))))
(assert (forall ( (s1 (set sl$Train))
                  (s2 (set sl$Train)) )
                (! (=> (finite@@sl$Train s1)
                       (finite@@sl$Train (set-diff@@sl$Train s1 s2)))
                   :pattern
                   ( (finite@@sl$Train (set-diff@@sl$Train s1 s2)) ))))
(assert (forall ( (s1 (set sl$Blk))
                  (s2 (set sl$Blk)) )
                (! (=> (and (finite@@sl$Blk s1) (finite@@sl$Blk s2))
                       (finite@@sl$Blk (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Blk (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Train))
                  (s2 (set sl$Train)) )
                (! (=> (and (finite@@sl$Train s1) (finite@@sl$Train s2))
                       (finite@@sl$Train (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Train (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Blk))
                  (s2 (set sl$Blk)) )
                (! (=> (and (finite@@sl$Blk s2) (not (finite@@sl$Blk s1)))
                       (not (finite@@sl$Blk (set-diff@@sl$Blk s1 s2))))
                   :pattern
                   ( (finite@@sl$Blk (set-diff@@sl$Blk s1 s2)) ))))
(assert (forall ( (s1 (set sl$Train))
                  (s2 (set sl$Train)) )
                (! (=> (and (finite@@sl$Train s2) (not (finite@@sl$Train s1)))
                       (not (finite@@sl$Train (set-diff@@sl$Train s1 s2))))
                   :pattern
                   ( (finite@@sl$Train (set-diff@@sl$Train s1 s2)) ))))
(assert (forall ( (x sl$Blk) )
                (! (finite@@sl$Blk (mk-set@@sl$Blk x))
                   :pattern
                   ( (finite@@sl$Blk (mk-set@@sl$Blk x)) ))))
(assert (finite@@sl$Blk empty-set@@sl$Blk))
(assert (finite@@sl$Train empty-set@@sl$Train))
(assert (not (exists ( (osgn@prime (set sl$Blk)) )
                     (and true
                          (= osgn@prime (union osgn (mk-set@@sl$Blk p)))))))
; SKIP:in
(assert (= in@prime in))
; SKIP:loc
(assert (= loc@prime loc))
; asm0
(assert (and (not (elem@@sl$Blk ext plf)) (not (= ext ent))))
; asm1
(assert (forall ( (b sl$Blk) )
                (! (= (elem@@sl$Blk b sl$Blk)
                      (or (elem@@sl$Blk b plf) (= b ent) (= b ext)))
                   :pattern
                   ( (elem@@sl$Blk b sl$Blk) ))))
; asm2
(assert (exists ( (b sl$Blk) ) (and true (elem@@sl$Blk b plf))))
; asm3
(assert (not (elem@@sl$Blk ent plf)))
; asm7
(assert (and (= (union (mk-set@@sl$Blk ext) plf)
                (compl@@sl$Blk (mk-set@@sl$Blk ent)))
             (= (union (mk-set@@sl$Blk ent) plf)
                (compl@@sl$Blk (mk-set@@sl$Blk ext)))
             (= (union (mk-set@@sl$Blk ext) (mk-set@@sl$Blk ent))
                (compl@@sl$Blk plf))))
; inv0
(assert (= (dom@@sl$Train@@sl$Blk loc) in))
; m2:inv0
(assert (injective@@sl$Train@@sl$Blk loc))
; m3:cp:c0
(assert (and (elem@@sl$Blk p plf)
             (elem@@sl$Blk p (ran@@sl$Train@@sl$Blk loc))
             (not (elem@@sl$Blk p osgn))))
; m3:inv0
(assert (subset osgn plf))
; m3:inv1
(assert (forall ( (p_0 sl$Blk)
                  (p_1 sl$Blk) )
                (! (=> (and (elem@@sl$Blk p_0 osgn) (elem@@sl$Blk p_1 osgn))
                       (= p_0 p_1))
                   :pattern
                   ())))
; m3:inv2
(assert (=> (elem@@sl$Blk ext (ran@@sl$Train@@sl$Blk loc))
            (= osgn empty-set@@sl$Blk)))
; m3:inv3
(assert (subset osgn (ran@@sl$Train@@sl$Blk loc)))
(assert (not true))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m3/m3:ctr:plf/FIS/osgn@prime