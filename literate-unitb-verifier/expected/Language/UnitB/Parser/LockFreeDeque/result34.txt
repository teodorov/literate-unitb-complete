; m1/read:LH/SKIP/EQL/ver
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes (a1 a2 a3)
                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)
                                                                     (@@field@@_left a2)
                                                                     (@@field@@_right a3))) ))
(define-sort guarded (a) (Maybe a))
(declare-sort sl$Addr_0 0)
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$OBJ_0 0)
; comment: we don't need to declare the sort Real
(declare-sort sl$State 0)
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const LH sl$Addr_0)
(declare-const LH@prime sl$Addr_0)
(declare-const RH sl$Addr_0)
(declare-const RH@prime sl$Addr_0)
(declare-const dummy sl$Addr_0)
(declare-const free (set sl$Addr_0))
(declare-const free@prime (set sl$Addr_0))
(declare-const lh sl$Addr_0)
(declare-const lh@prime sl$Addr_0)
(declare-const popL Bool)
(declare-const popL@prime Bool)
(declare-const remL Bool)
(declare-const remL@prime Bool)
(declare-const resL sl$OBJ_0)
(declare-const resL@prime sl$OBJ_0)
(declare-const result sl$OBJ_0)
(declare-const result@prime sl$OBJ_0)
(declare-const rh sl$Addr_0)
(declare-const rh@prime sl$Addr_0)
(declare-const state sl$State)
(declare-const state@prime sl$State)
(declare-const ver Int)
(declare-const ver@prime Int)
(declare-const sl$bot sl$OBJ_0)
(declare-const sl$cEmpty sl$State)
(declare-const sl$cInit sl$State)
(declare-const sl$cNonEmpty sl$State)
(declare-const sl$link
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$link@prime
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$trash
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$trash@prime
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)
(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)
(declare-fun card@@sl$State ( (set sl$State) ) Int)
(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (set sl$Addr_0))
(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (set sl$Addr_0)
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (set sl$Addr_0)
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ()
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)
(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)
(declare-fun finite@@sl$State ( (set sl$State) ) Bool)
(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             Bool)
(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))
(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))
(declare-fun mk-set@@sl$State (sl$State) (set sl$State))
(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(define-fun all@@sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              true ))
(define-fun all@@sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              true ))
(define-fun all@@sl$State
            ()
            (set sl$State)
            ( (as const (set sl$State))
              true ))
(define-fun compl@@sl$Addr_0
            ( (s1 (set sl$Addr_0)) )
            (set sl$Addr_0)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0)) )
            (set sl$OBJ_0)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$State
            ( (s1 (set sl$State)) )
            (set sl$State)
            ( (_ map not)
              s1 ))
(define-fun elem@@sl$Addr_0
            ( (x sl$Addr_0)
              (s1 (set sl$Addr_0)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$OBJ_0
            ( (x sl$OBJ_0)
              (s1 (set sl$OBJ_0)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$State
            ( (x sl$State)
              (s1 (set sl$State)) )
            Bool
            (select s1 x))
(define-fun empty-set@@sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              false ))
(define-fun empty-set@@sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              false ))
(define-fun empty-set@@sl$State
            ()
            (set sl$State)
            ( (as const (set sl$State))
              false ))
(define-fun set-diff@@sl$Addr_0
            ( (s1 (set sl$Addr_0))
              (s2 (set sl$Addr_0)) )
            (set sl$Addr_0)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0))
              (s2 (set sl$OBJ_0)) )
            (set sl$OBJ_0)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$State
            ( (s1 (set sl$State))
              (s2 (set sl$State)) )
            (set sl$State)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@sl$Addr_0
            ( (s1 (set sl$Addr_0))
              (s2 (set sl$Addr_0)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0))
              (s2 (set sl$OBJ_0)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$State
            ( (s1 (set sl$State))
              (s2 (set sl$State)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              true ))
(define-fun sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              true ))
(define-fun sl$State
            ()
            (set sl$State)
            ( (as const (set sl$State))
              true ))
(define-fun sl$OBJ@prime
            ()
            (set sl$OBJ_0)
            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))
(define-fun sl$OBJ
            ()
            (set sl$OBJ_0)
            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))
(define-fun sl$Addr@prime
            ()
            (set sl$Addr_0)
            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))
(define-fun sl$Addr
            ()
            (set sl$Addr_0)
            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))
                   :pattern
                   ( (<= 0 (card@@sl$Addr_0 r)) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))
                   :pattern
                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))
(assert (forall ( (r (set sl$State)) )
                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))
                   :pattern
                   ( (<= 0 (card@@sl$State r)) ))))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (= (= (card@@sl$Addr_0 r) 0)
                      (= r empty-set@@sl$Addr_0))
                   :pattern
                   ( (card@@sl$Addr_0 r) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (= (= (card@@sl$OBJ_0 r) 0)
                      (= r empty-set@@sl$OBJ_0))
                   :pattern
                   ( (card@@sl$OBJ_0 r) ))))
(assert (forall ( (r (set sl$State)) )
                (! (= (= (card@@sl$State r) 0)
                      (= r empty-set@@sl$State))
                   :pattern
                   ( (card@@sl$State r) ))))
(assert (forall ( (x sl$Addr_0) )
                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)
                   :pattern
                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))
(assert (forall ( (x sl$OBJ_0) )
                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)
                   :pattern
                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))
(assert (forall ( (x sl$State) )
                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)
                   :pattern
                   ( (card@@sl$State (mk-set@@sl$State x)) ))))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (= (= (card@@sl$Addr_0 r) 1)
                      (exists ( (x sl$Addr_0) )
                              (and true (= r (mk-set@@sl$Addr_0 x)))))
                   :pattern
                   ( (card@@sl$Addr_0 r) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (= (= (card@@sl$OBJ_0 r) 1)
                      (exists ( (x sl$OBJ_0) )
                              (and true (= r (mk-set@@sl$OBJ_0 x)))))
                   :pattern
                   ( (card@@sl$OBJ_0 r) ))))
(assert (forall ( (r (set sl$State)) )
                (! (= (= (card@@sl$State r) 1)
                      (exists ( (x sl$State) )
                              (and true (= r (mk-set@@sl$State x)))))
                   :pattern
                   ( (card@@sl$State r) ))))
(assert (forall ( (r (set sl$Addr_0))
                  (r0 (set sl$Addr_0)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)
                       (= (card@@sl$Addr_0 (union r r0))
                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))
                   :pattern
                   ( (card@@sl$Addr_0 (union r r0)) ))))
(assert (forall ( (r (set sl$OBJ_0))
                  (r0 (set sl$OBJ_0)) )
                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)
                       (= (card@@sl$OBJ_0 (union r r0))
                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))
                   :pattern
                   ( (card@@sl$OBJ_0 (union r r0)) ))))
(assert (forall ( (r (set sl$State))
                  (r0 (set sl$State)) )
                (! (=> (= (intersect r r0) empty-set@@sl$State)
                       (= (card@@sl$State (union r r0))
                          (+ (card@@sl$State r) (card@@sl$State r0))))
                   :pattern
                   ( (card@@sl$State (union r r0)) ))))
(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)
           empty-set@@sl$Addr_0))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)
                      f1)
                   :pattern
                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
                                                                                                         f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
                                                                                                        f1) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (f2 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))
                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)
                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (s1 (set sl$Addr_0)) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))
                      (intersect s1
                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (s1 (set sl$Addr_0)) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))
                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)
                                           s1))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))
(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))
(assert (forall ( (x sl$Addr_0)
                  (y sl$Addr_0) )
                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))
                   :pattern
                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))
(assert (forall ( (x sl$OBJ_0)
                  (y sl$OBJ_0) )
                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))
                   :pattern
                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))
(assert (forall ( (x sl$State)
                  (y sl$State) )
                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))
                   :pattern
                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (finite@@sl$Addr_0 s1)
                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))
                   :pattern
                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (finite@@sl$OBJ_0 s1)
                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$State))
                  (s2 (set sl$State)) )
                (! (=> (finite@@sl$State s1)
                       (finite@@sl$State (set-diff@@sl$State s1 s2)))
                   :pattern
                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))
                       (finite@@sl$Addr_0 (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))
                       (finite@@sl$OBJ_0 (union s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$State))
                  (s2 (set sl$State)) )
                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))
                       (finite@@sl$State (union s1 s2)))
                   :pattern
                   ( (finite@@sl$State (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (and (finite@@sl$Addr_0 s2)
                            (not (finite@@sl$Addr_0 s1)))
                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))
                   :pattern
                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))
                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))
                   :pattern
                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$State))
                  (s2 (set sl$State)) )
                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))
                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))
                   :pattern
                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))
(assert (forall ( (x sl$Addr_0) )
                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))
                   :pattern
                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))
(assert (forall ( (x sl$OBJ_0) )
                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))
                   :pattern
                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))
(assert (forall ( (x sl$State) )
                (! (finite@@sl$State (mk-set@@sl$State x))
                   :pattern
                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))
(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))
(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))
(assert (finite@@sl$State empty-set@@sl$State))
; SKIP:LH
(assert (= LH@prime LH))
; SKIP:RH
(assert (= RH@prime RH))
; SKIP:\link
(assert (= sl$link@prime sl$link))
; SKIP:\trash
(assert (= sl$trash@prime sl$trash))
; SKIP:free
(assert (= free@prime free))
; SKIP:popL
(assert (= popL@prime popL))
; SKIP:remL
(assert (= remL@prime remL))
; SKIP:resL
(assert (= resL@prime resL))
; SKIP:result
(assert (= result@prime result))
; SKIP:rh
(assert (= rh@prime rh))
; m0:inv0
(assert (subset free sl$Addr))
; m0:thm0:ASM
(assert (elem@@sl$Addr_0 LH
                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)
                                (mk-set@@sl$Addr_0 dummy))))
; m0:thm1:ASM
(assert (elem@@sl$Addr_0 RH
                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)
                                (mk-set@@sl$Addr_0 dummy))))
; m1:act0
(assert (= lh@prime LH))
; m1:act1
(assert (= state@prime
           (ite (= LH dummy) sl$cEmpty sl$cNonEmpty)))
; m1:act2
(assert (= ver@prime (ite (= LH dummy) (+ ver 1) ver)))
; m1:sch0
(assert (= state sl$cInit))
; m1:sch1
(assert (not (= LH dummy)))
(assert (not (= ver@prime ver)))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m1/read:LH/SKIP/EQL/ver
