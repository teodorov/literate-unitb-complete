; m1/hdl:popL:more/GRD/str/m0:sch0
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes (a1)
                   ( (Record-item (Record-item (@@field@@_item a1))) ))
(declare-datatypes (a1 a2 a3)
                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)
                                                                     (@@field@@_left a2)
                                                                     (@@field@@_right a3))) ))
(define-sort guarded (a) (Maybe a))
(declare-sort sl$Addr_0 0)
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$OBJ_0 0)
; comment: we don't need to declare the sort Real
(declare-sort sl$State 0)
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const LH sl$Addr_0)
(declare-const LH@prime sl$Addr_0)
(declare-const RH sl$Addr_0)
(declare-const RH@prime sl$Addr_0)
(declare-const dummy sl$Addr_0)
(declare-const free (set sl$Addr_0))
(declare-const free@prime (set sl$Addr_0))
(declare-const lh sl$Addr_0)
(declare-const lh@prime sl$Addr_0)
(declare-const popL Bool)
(declare-const popL@prime Bool)
(declare-const remL Bool)
(declare-const remL@prime Bool)
(declare-const resL sl$OBJ_0)
(declare-const resL@prime sl$OBJ_0)
(declare-const result sl$OBJ_0)
(declare-const result@prime sl$OBJ_0)
(declare-const rh sl$Addr_0)
(declare-const rh@prime sl$Addr_0)
(declare-const state sl$State)
(declare-const state@prime sl$State)
(declare-const v Int)
(declare-const ver Int)
(declare-const ver@prime Int)
(declare-const sl$bot sl$OBJ_0)
(declare-const sl$cBot sl$State)
(declare-const sl$cEmpty sl$State)
(declare-const sl$cInit sl$State)
(declare-const sl$cNonEmpty sl$State)
(declare-const sl$cPopped sl$State)
(declare-const sl$link
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$link@prime
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$trash
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$trash@prime
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))
               sl$Addr_0 )
             (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))
(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)
(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)
(declare-fun card@@sl$State ( (set sl$State) ) Int)
(declare-fun card@Open@@Record-item@@sl$OBJ_0@Close
             ( (set (Record-item sl$OBJ_0)) )
             Int)
(declare-fun const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close
             ( (Record-item sl$OBJ_0) )
             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))
(declare-fun dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (set sl$Addr_0))
(declare-fun dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (set sl$Addr_0)
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (set sl$Addr_0)
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ()
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)
(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)
(declare-fun finite@@sl$State ( (set sl$State) ) Bool)
(declare-fun finite@Open@@Record-item@@sl$OBJ_0@Close
             ( (set (Record-item sl$OBJ_0)) )
             Bool)
(declare-fun ident@Open@@Record-item@@sl$OBJ_0@Close
             ()
             (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))
(declare-fun injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             Bool)
(declare-fun mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             (sl$Addr_0 (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun mk-set@@sl$Addr_0 (sl$Addr_0) (set sl$Addr_0))
(declare-fun mk-set@@sl$OBJ_0 (sl$OBJ_0) (set sl$OBJ_0))
(declare-fun mk-set@@sl$State (sl$State) (set sl$State))
(declare-fun mk-set@Open@@Record-item@@sl$OBJ_0@Close
             ( (Record-item sl$OBJ_0) )
             (set (Record-item sl$OBJ_0)))
(declare-fun ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
             ( (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
             (pfun sl$Addr_0
                   (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close
             ( (set (Record-item sl$OBJ_0))
               (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)) )
             (set (Record-item sl$OBJ_0)))
(declare-fun @@lambda@@_0
             ( (set sl$OBJ_0) )
             (set (Record-item sl$OBJ_0)))
(define-fun all@@sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              true ))
(define-fun all@@sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              true ))
(define-fun all@@sl$State
            ()
            (set sl$State)
            ( (as const (set sl$State))
              true ))
(define-fun all@Open@@Record-item@@sl$OBJ_0@Close
            ()
            (set (Record-item sl$OBJ_0))
            ( (as const (set (Record-item sl$OBJ_0)))
              true ))
(define-fun compl@@sl$Addr_0
            ( (s1 (set sl$Addr_0)) )
            (set sl$Addr_0)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0)) )
            (set sl$OBJ_0)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$State
            ( (s1 (set sl$State)) )
            (set sl$State)
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@Record-item@@sl$OBJ_0@Close
            ( (s1 (set (Record-item sl$OBJ_0))) )
            (set (Record-item sl$OBJ_0))
            ( (_ map not)
              s1 ))
(define-fun elem@@sl$Addr_0
            ( (x sl$Addr_0)
              (s1 (set sl$Addr_0)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$OBJ_0
            ( (x sl$OBJ_0)
              (s1 (set sl$OBJ_0)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$State
            ( (x sl$State)
              (s1 (set sl$State)) )
            Bool
            (select s1 x))
(define-fun elem@Open@@Record-item@@sl$OBJ_0@Close
            ( (x (Record-item sl$OBJ_0))
              (s1 (set (Record-item sl$OBJ_0))) )
            Bool
            (select s1 x))
(define-fun empty-set@@sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              false ))
(define-fun empty-set@@sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              false ))
(define-fun empty-set@@sl$State
            ()
            (set sl$State)
            ( (as const (set sl$State))
              false ))
(define-fun empty-set@Open@@Record-item@@sl$OBJ_0@Close
            ()
            (set (Record-item sl$OBJ_0))
            ( (as const (set (Record-item sl$OBJ_0)))
              false ))
(define-fun set-diff@@sl$Addr_0
            ( (s1 (set sl$Addr_0))
              (s2 (set sl$Addr_0)) )
            (set sl$Addr_0)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0))
              (s2 (set sl$OBJ_0)) )
            (set sl$OBJ_0)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$State
            ( (s1 (set sl$State))
              (s2 (set sl$State)) )
            (set sl$State)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@Record-item@@sl$OBJ_0@Close
            ( (s1 (set (Record-item sl$OBJ_0)))
              (s2 (set (Record-item sl$OBJ_0))) )
            (set (Record-item sl$OBJ_0))
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@sl$Addr_0
            ( (s1 (set sl$Addr_0))
              (s2 (set sl$Addr_0)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0))
              (s2 (set sl$OBJ_0)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$State
            ( (s1 (set sl$State))
              (s2 (set sl$State)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@Record-item@@sl$OBJ_0@Close
            ( (s1 (set (Record-item sl$OBJ_0)))
              (s2 (set (Record-item sl$OBJ_0))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              true ))
(define-fun sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              true ))
(define-fun sl$State
            ()
            (set sl$State)
            ( (as const (set sl$State))
              true ))
(define-fun sl$OBJ@prime
            ()
            (set sl$OBJ_0)
            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))
(define-fun sl$OBJ
            ()
            (set sl$OBJ_0)
            (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))
(define-fun sl$Node@prime
            ()
            (set (Record-item sl$OBJ_0))
            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))
                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))
(define-fun sl$Node
            ()
            (set (Record-item sl$OBJ_0))
            (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close (@@lambda@@_0 (set-diff@@sl$OBJ_0 sl$OBJ_0 (mk-set@@sl$OBJ_0 sl$bot)))
                                                                                     ident@Open@@Record-item@@sl$OBJ_0@Close))
(define-fun sl$Addr@prime
            ()
            (set sl$Addr_0)
            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))
(define-fun sl$Addr
            ()
            (set sl$Addr_0)
            (set-diff@@sl$Addr_0 sl$Addr_0 (mk-set@@sl$Addr_0 dummy)))
(assert (forall ( (r (set (Record-item sl$OBJ_0))) )
                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close r)
                       (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@Record-item@@sl$OBJ_0@Close r)) ))))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))
                   :pattern
                   ( (<= 0 (card@@sl$Addr_0 r)) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))
                   :pattern
                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))
(assert (forall ( (r (set sl$State)) )
                (! (=> (finite@@sl$State r) (<= 0 (card@@sl$State r)))
                   :pattern
                   ( (<= 0 (card@@sl$State r)) ))))
(assert (forall ( (r (set (Record-item sl$OBJ_0))) )
                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 0)
                      (= r empty-set@Open@@Record-item@@sl$OBJ_0@Close))
                   :pattern
                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (= (= (card@@sl$Addr_0 r) 0)
                      (= r empty-set@@sl$Addr_0))
                   :pattern
                   ( (card@@sl$Addr_0 r) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (= (= (card@@sl$OBJ_0 r) 0)
                      (= r empty-set@@sl$OBJ_0))
                   :pattern
                   ( (card@@sl$OBJ_0 r) ))))
(assert (forall ( (r (set sl$State)) )
                (! (= (= (card@@sl$State r) 0)
                      (= r empty-set@@sl$State))
                   :pattern
                   ( (card@@sl$State r) ))))
(assert (forall ( (x (Record-item sl$OBJ_0)) )
                (! (= (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))
                      1)
                   :pattern
                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))
(assert (forall ( (x sl$Addr_0) )
                (! (= (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) 1)
                   :pattern
                   ( (card@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))
(assert (forall ( (x sl$OBJ_0) )
                (! (= (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) 1)
                   :pattern
                   ( (card@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))
(assert (forall ( (x sl$State) )
                (! (= (card@@sl$State (mk-set@@sl$State x)) 1)
                   :pattern
                   ( (card@@sl$State (mk-set@@sl$State x)) ))))
(assert (forall ( (r (set (Record-item sl$OBJ_0))) )
                (! (= (= (card@Open@@Record-item@@sl$OBJ_0@Close r) 1)
                      (exists ( (x (Record-item sl$OBJ_0)) )
                              (and true
                                   (= r (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)))))
                   :pattern
                   ( (card@Open@@Record-item@@sl$OBJ_0@Close r) ))))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (= (= (card@@sl$Addr_0 r) 1)
                      (exists ( (x sl$Addr_0) )
                              (and true (= r (mk-set@@sl$Addr_0 x)))))
                   :pattern
                   ( (card@@sl$Addr_0 r) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (= (= (card@@sl$OBJ_0 r) 1)
                      (exists ( (x sl$OBJ_0) )
                              (and true (= r (mk-set@@sl$OBJ_0 x)))))
                   :pattern
                   ( (card@@sl$OBJ_0 r) ))))
(assert (forall ( (r (set sl$State)) )
                (! (= (= (card@@sl$State r) 1)
                      (exists ( (x sl$State) )
                              (and true (= r (mk-set@@sl$State x)))))
                   :pattern
                   ( (card@@sl$State r) ))))
(assert (forall ( (r (set (Record-item sl$OBJ_0)))
                  (r0 (set (Record-item sl$OBJ_0))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@Record-item@@sl$OBJ_0@Close)
                       (= (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0))
                          (+ (card@Open@@Record-item@@sl$OBJ_0@Close r)
                             (card@Open@@Record-item@@sl$OBJ_0@Close r0))))
                   :pattern
                   ( (card@Open@@Record-item@@sl$OBJ_0@Close (union r r0)) ))))
(assert (forall ( (r (set sl$Addr_0))
                  (r0 (set sl$Addr_0)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)
                       (= (card@@sl$Addr_0 (union r r0))
                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))
                   :pattern
                   ( (card@@sl$Addr_0 (union r r0)) ))))
(assert (forall ( (r (set sl$OBJ_0))
                  (r0 (set sl$OBJ_0)) )
                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)
                       (= (card@@sl$OBJ_0 (union r r0))
                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))
                   :pattern
                   ( (card@@sl$OBJ_0 (union r r0)) ))))
(assert (forall ( (r (set sl$State))
                  (r0 (set sl$State)) )
                (! (=> (= (intersect r r0) empty-set@@sl$State)
                       (= (card@@sl$State (union r r0))
                          (+ (card@@sl$State r) (card@@sl$State r0))))
                   :pattern
                   ( (card@@sl$State (union r r0)) ))))
(assert (forall ( (x (Record-item sl$OBJ_0))
                  (y (Record-item sl$OBJ_0)) )
                (! (= (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)
                              y)
                      x)
                   :pattern
                   ( (select (const@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close x)
                             y) ))))
(assert (forall ( (x (Record-item sl$OBJ_0)) )
                (! (= (select ident@Open@@Record-item@@sl$OBJ_0@Close x)
                      x)
                   :pattern
                   ( (select ident@Open@@Record-item@@sl$OBJ_0@Close x) ))))
(assert (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)
           empty-set@@sl$Addr_0))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                         empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close)
                      f1)
                   :pattern
                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                        empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
                                                                                                         f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close
                                                                                                        f1) ))))
(assert (forall ( (x sl$Addr_0)
                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))
                      (mk-set@@sl$Addr_0 x))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (f2 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (x sl$Addr_0) )
                (! (=> (elem@@sl$Addr_0 x
                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))
                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)
                                                                                                               x)
                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2 x)))
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)
                                                                                                          x) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (f2 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (x sl$Addr_0) )
                (! (=> (and (elem@@sl$Addr_0 x
                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))
                            (not (elem@@sl$Addr_0 x
                                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2))))
                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)
                                                                                                               x)
                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)
                                                                                                          x) ))))
(assert (forall ( (x sl$Addr_0)
                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)
                                                                                                           x)
                      y)
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y)
                                                                                                          x) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (s1 (set sl$Addr_0))
                  (x sl$Addr_0) )
                (! (=> (and (elem@@sl$Addr_0 x s1)
                            (elem@@sl$Addr_0 x
                                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))
                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)
                                                                                                               x)
                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)
                                                                                                          x) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (s1 (set sl$Addr_0))
                  (x sl$Addr_0) )
                (! (=> (elem@@sl$Addr_0 x
                                        (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)
                                                             s1))
                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)
                                                                                                               x)
                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)))
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)
                                                                                                          x) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (f2 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2))
                      (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)
                             (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f2)))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (s1 (set sl$Addr_0)) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))
                      (intersect s1
                                 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-rest@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (s1 (set sl$Addr_0)) )
                (! (= (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1))
                      (set-diff@@sl$Addr_0 (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)
                                           s1))
                   :pattern
                   ( (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (dom-subt@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (x sl$Addr_0)
                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
                (! (= (and (elem@@sl$Addr_0 x
                                            (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))
                           (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)
                              y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Addr_0 x
                                      (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))
                     (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (x sl$Addr_0)
                  (x2 sl$Addr_0)
                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                                                                                                                  (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))
                                                                                                               x2)
                          (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2)))
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))
                                                                                                          x2) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
                  (x sl$Addr_0)
                  (y (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)) )
                (! (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                                                                                                              (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))
                                                                                                           x)
                      y)
                   :pattern
                   ( (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close (ovl@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1
                                                                                                                                                                                             (mk-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close x y))
                                                                                                          x) ))))
(assert (forall ( (f1 (pfun sl$Addr_0
                            (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0))) )
                (! (= (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)
                      (forall ( (x sl$Addr_0)
                                (x2 sl$Addr_0) )
                              (=> (and (elem@@sl$Addr_0 x
                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1))
                                       (elem@@sl$Addr_0 x2
                                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1)))
                                  (=> (= (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x)
                                         (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close f1) ))))
(assert (injective@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close empty-fun@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close))
(assert (forall ( (x (Record-item sl$OBJ_0))
                  (y (Record-item sl$OBJ_0)) )
                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close x (mk-set@Open@@Record-item@@sl$OBJ_0@Close y)) ))))
(assert (forall ( (x sl$Addr_0)
                  (y sl$Addr_0) )
                (! (= (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) (= x y))
                   :pattern
                   ( (elem@@sl$Addr_0 x (mk-set@@sl$Addr_0 y)) ))))
(assert (forall ( (x sl$OBJ_0)
                  (y sl$OBJ_0) )
                (! (= (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) (= x y))
                   :pattern
                   ( (elem@@sl$OBJ_0 x (mk-set@@sl$OBJ_0 y)) ))))
(assert (forall ( (x sl$State)
                  (y sl$State) )
                (! (= (elem@@sl$State x (mk-set@@sl$State y)) (= x y))
                   :pattern
                   ( (elem@@sl$State x (mk-set@@sl$State y)) ))))
(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))
                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))
                  (y (Record-item sl$OBJ_0)) )
                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close y
                                                              (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term))
                      (exists ( (x (Record-item sl$OBJ_0)) )
                              (and (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)
                                   (= (select term x) y))))
                   :pattern
                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close y
                                                             (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)) ))))
(assert (forall ( (r1 (set (Record-item sl$OBJ_0)))
                  (term (Array (Record-item sl$OBJ_0) (Record-item sl$OBJ_0)))
                  (y (Record-item sl$OBJ_0)) )
                (! (= (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)
                         (mk-set@Open@@Record-item@@sl$OBJ_0@Close y))
                      (forall ( (x (Record-item sl$OBJ_0)) )
                              (=> (elem@Open@@Record-item@@sl$OBJ_0@Close x r1)
                                  (= (select term x) y))))
                   :pattern
                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 term)
                     (mk-set@Open@@Record-item@@sl$OBJ_0@Close y) ))))
(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))
                  (s2 (set (Record-item sl$OBJ_0))) )
                (! (=> (finite@Open@@Record-item@@sl$OBJ_0@Close s1)
                       (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (finite@@sl$Addr_0 s1)
                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))
                   :pattern
                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (finite@@sl$OBJ_0 s1)
                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$State))
                  (s2 (set sl$State)) )
                (! (=> (finite@@sl$State s1)
                       (finite@@sl$State (set-diff@@sl$State s1 s2)))
                   :pattern
                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))
(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))
                  (s2 (set (Record-item sl$OBJ_0))) )
                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s1)
                            (finite@Open@@Record-item@@sl$OBJ_0@Close s2))
                       (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))
                       (finite@@sl$Addr_0 (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))
                       (finite@@sl$OBJ_0 (union s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$State))
                  (s2 (set sl$State)) )
                (! (=> (and (finite@@sl$State s1) (finite@@sl$State s2))
                       (finite@@sl$State (union s1 s2)))
                   :pattern
                   ( (finite@@sl$State (union s1 s2)) ))))
(assert (forall ( (s1 (set (Record-item sl$OBJ_0)))
                  (s2 (set (Record-item sl$OBJ_0))) )
                (! (=> (and (finite@Open@@Record-item@@sl$OBJ_0@Close s2)
                            (not (finite@Open@@Record-item@@sl$OBJ_0@Close s1)))
                       (not (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (set-diff@Open@@Record-item@@sl$OBJ_0@Close s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (and (finite@@sl$Addr_0 s2)
                            (not (finite@@sl$Addr_0 s1)))
                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))
                   :pattern
                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))
                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))
                   :pattern
                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$State))
                  (s2 (set sl$State)) )
                (! (=> (and (finite@@sl$State s2) (not (finite@@sl$State s1)))
                       (not (finite@@sl$State (set-diff@@sl$State s1 s2))))
                   :pattern
                   ( (finite@@sl$State (set-diff@@sl$State s1 s2)) ))))
(assert (forall ( (x (Record-item sl$OBJ_0)) )
                (! (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x))
                   :pattern
                   ( (finite@Open@@Record-item@@sl$OBJ_0@Close (mk-set@Open@@Record-item@@sl$OBJ_0@Close x)) ))))
(assert (forall ( (x sl$Addr_0) )
                (! (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x))
                   :pattern
                   ( (finite@@sl$Addr_0 (mk-set@@sl$Addr_0 x)) ))))
(assert (forall ( (x sl$OBJ_0) )
                (! (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x))
                   :pattern
                   ( (finite@@sl$OBJ_0 (mk-set@@sl$OBJ_0 x)) ))))
(assert (forall ( (x sl$State) )
                (! (finite@@sl$State (mk-set@@sl$State x))
                   :pattern
                   ( (finite@@sl$State (mk-set@@sl$State x)) ))))
(assert (finite@Open@@Record-item@@sl$OBJ_0@Close empty-set@Open@@Record-item@@sl$OBJ_0@Close))
(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))
(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))
(assert (finite@@sl$State empty-set@@sl$State))
(assert (forall ( (r1 (set (Record-item sl$OBJ_0))) )
                (! (= (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close)
                      r1)
                   :pattern
                   ( (set@Open@@Record-item@@sl$OBJ_0@Close@Open@@Record-item@@sl$OBJ_0@Close r1 ident@Open@@Record-item@@sl$OBJ_0@Close) ))))
(assert (forall ( (@@fv@@_0 (set sl$OBJ_0))
                  (@@bv@@_0 (Record-item sl$OBJ_0)) )
                (! (= (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0))
                      (elem@@sl$OBJ_0 (@@field@@_item @@bv@@_0) @@fv@@_0))
                   :pattern
                   ( (elem@Open@@Record-item@@sl$OBJ_0@Close @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))
; m0:asm0
(assert (not (= sl$cInit sl$cBot)))
; m0:asm1
(assert (not (= sl$cInit sl$cEmpty)))
; m0:asm2
(assert (not (= sl$cInit sl$cNonEmpty)))
; m0:asm3
(assert (not (= sl$cInit sl$cPopped)))
; m0:asm4
(assert (not (= sl$cBot sl$cEmpty)))
; m0:asm5
(assert (not (= sl$cBot sl$cNonEmpty)))
; m0:asm6
(assert (not (= sl$cBot sl$cPopped)))
; m0:asm7
(assert (not (= sl$cEmpty sl$cNonEmpty)))
; m0:asm8
(assert (not (= sl$cEmpty sl$cPopped)))
; m0:asm9
(assert (not (= sl$cNonEmpty sl$cPopped)))
; m0:inv0
(assert (subset free sl$Addr))
; m0:sch2
(assert (not (= LH dummy)))
; m0:sch3
(assert (not (= LH RH)))
; m0:thm0:ASM
(assert (elem@@sl$Addr_0 LH
                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)
                                (mk-set@@sl$Addr_0 dummy))))
; m0:thm1:ASM
(assert (elem@@sl$Addr_0 RH
                         (union (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link)
                                (mk-set@@sl$Addr_0 dummy))))
; m0:thm2:ASM
(assert (not (elem@@sl$Addr_0 LH
                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))
; m0:thm3:ASM
(assert (not (elem@@sl$Addr_0 RH
                              (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))))
; m1:inv0
(assert (= (= state sl$cBot) (and (not popL) (not remL))))
; m1:inv3
(assert (= popL
           (elem@@sl$State state
                           (union (mk-set@@sl$State sl$cInit)
                                  (mk-set@@sl$State sl$cNonEmpty)))))
; m1:inv4
(assert (=> (= state sl$cPopped)
            (and remL
                 (elem@@sl$Addr_0 lh
                                  (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash))
                 (= (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$trash lh))
                    resL))))
; m1:inv5
(assert (= remL
           (elem@@sl$State state
                           (union (mk-set@@sl$State sl$cPopped)
                                  (mk-set@@sl$State sl$cEmpty)))))
; m1:inv6
(assert (= (= state sl$cEmpty) (and remL (= resL sl$bot))))
; m1:inv7
(assert (forall ( (p sl$Addr_0) )
                (! (=> (elem@@sl$Addr_0 p
                                        (dom@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link))
                       (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))
                                       sl$OBJ))
                   :pattern
                   ( (elem@@sl$OBJ_0 (@@field@@_item (apply@@sl$Addr_0@Open@@Record-item-left-right@@sl$OBJ_0@@sl$Addr_0@@sl$Addr_0@Close sl$link p))
                                     sl$OBJ) ))))
; m1:sch0
(assert (= state sl$cNonEmpty))
; m1:sch1
(assert (= lh LH))
; v
(assert (= v ver))
(assert (not (= v ver)))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m1/hdl:popL:more/GRD/str/m0:sch0
