; m0/add:popL/SCH/m0:grd0
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes (a1 a2 a3)
                   ( (Record-item-left-right (Record-item-left-right (@@field@@_item a1)
                                                                     (@@field@@_left a2)
                                                                     (@@field@@_right a3))) ))
(define-sort guarded (a) (Maybe a))
(declare-sort sl$Addr_0 0)
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$OBJ_0 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const LH sl$Addr_0)
(declare-const RH sl$Addr_0)
(declare-const free (set sl$Addr_0))
(declare-const popL Bool)
(declare-const remL Bool)
(declare-const resL sl$OBJ_0)
(declare-const ver Int)
(declare-const sl$link
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-const sl$trash
               (pfun sl$Addr_0
                     (Record-item-left-right sl$OBJ_0 sl$Addr_0 sl$Addr_0)))
(declare-fun card@@sl$Addr_0 ( (set sl$Addr_0) ) Int)
(declare-fun card@@sl$OBJ_0 ( (set sl$OBJ_0) ) Int)
(declare-fun finite@@sl$Addr_0 ( (set sl$Addr_0) ) Bool)
(declare-fun finite@@sl$OBJ_0 ( (set sl$OBJ_0) ) Bool)
(define-fun all@@sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              true ))
(define-fun all@@sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              true ))
(define-fun compl@@sl$Addr_0
            ( (s1 (set sl$Addr_0)) )
            (set sl$Addr_0)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0)) )
            (set sl$OBJ_0)
            ( (_ map not)
              s1 ))
(define-fun empty-set@@sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              false ))
(define-fun empty-set@@sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              false ))
(define-fun set-diff@@sl$Addr_0
            ( (s1 (set sl$Addr_0))
              (s2 (set sl$Addr_0)) )
            (set sl$Addr_0)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0))
              (s2 (set sl$OBJ_0)) )
            (set sl$OBJ_0)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@sl$Addr_0
            ( (s1 (set sl$Addr_0))
              (s2 (set sl$Addr_0)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$OBJ_0
            ( (s1 (set sl$OBJ_0))
              (s2 (set sl$OBJ_0)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Addr_0
            ()
            (set sl$Addr_0)
            ( (as const (set sl$Addr_0))
              true ))
(define-fun sl$OBJ_0
            ()
            (set sl$OBJ_0)
            ( (as const (set sl$OBJ_0))
              true ))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (=> (finite@@sl$Addr_0 r) (<= 0 (card@@sl$Addr_0 r)))
                   :pattern
                   ( (<= 0 (card@@sl$Addr_0 r)) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (=> (finite@@sl$OBJ_0 r) (<= 0 (card@@sl$OBJ_0 r)))
                   :pattern
                   ( (<= 0 (card@@sl$OBJ_0 r)) ))))
(assert (forall ( (r (set sl$Addr_0)) )
                (! (= (= (card@@sl$Addr_0 r) 0)
                      (= r empty-set@@sl$Addr_0))
                   :pattern
                   ( (card@@sl$Addr_0 r) ))))
(assert (forall ( (r (set sl$OBJ_0)) )
                (! (= (= (card@@sl$OBJ_0 r) 0)
                      (= r empty-set@@sl$OBJ_0))
                   :pattern
                   ( (card@@sl$OBJ_0 r) ))))
(assert (forall ( (r (set sl$Addr_0))
                  (r0 (set sl$Addr_0)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Addr_0)
                       (= (card@@sl$Addr_0 (union r r0))
                          (+ (card@@sl$Addr_0 r) (card@@sl$Addr_0 r0))))
                   :pattern
                   ( (card@@sl$Addr_0 (union r r0)) ))))
(assert (forall ( (r (set sl$OBJ_0))
                  (r0 (set sl$OBJ_0)) )
                (! (=> (= (intersect r r0) empty-set@@sl$OBJ_0)
                       (= (card@@sl$OBJ_0 (union r r0))
                          (+ (card@@sl$OBJ_0 r) (card@@sl$OBJ_0 r0))))
                   :pattern
                   ( (card@@sl$OBJ_0 (union r r0)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (finite@@sl$Addr_0 s1)
                       (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)))
                   :pattern
                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (finite@@sl$OBJ_0 s1)
                       (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (and (finite@@sl$Addr_0 s1) (finite@@sl$Addr_0 s2))
                       (finite@@sl$Addr_0 (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Addr_0 (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (and (finite@@sl$OBJ_0 s1) (finite@@sl$OBJ_0 s2))
                       (finite@@sl$OBJ_0 (union s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ_0 (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Addr_0))
                  (s2 (set sl$Addr_0)) )
                (! (=> (and (finite@@sl$Addr_0 s2)
                            (not (finite@@sl$Addr_0 s1)))
                       (not (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2))))
                   :pattern
                   ( (finite@@sl$Addr_0 (set-diff@@sl$Addr_0 s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ_0))
                  (s2 (set sl$OBJ_0)) )
                (! (=> (and (finite@@sl$OBJ_0 s2) (not (finite@@sl$OBJ_0 s1)))
                       (not (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2))))
                   :pattern
                   ( (finite@@sl$OBJ_0 (set-diff@@sl$OBJ_0 s1 s2)) ))))
(assert (finite@@sl$Addr_0 empty-set@@sl$Addr_0))
(assert (finite@@sl$OBJ_0 empty-set@@sl$OBJ_0))
; default
(assert false)
(assert popL)
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m0/add:popL/SCH/m0:grd0
