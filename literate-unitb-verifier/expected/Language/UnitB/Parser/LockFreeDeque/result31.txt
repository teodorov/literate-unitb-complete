; m5/INIT/FIS/item
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$Node 0)
(declare-sort sl$OBJ 0)
(declare-sort sl$REQ 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const LH sl$Node)
(declare-const RH sl$Node)
(declare-const dummy sl$Node)
(declare-const emp Bool)
(declare-const insL (pfun sl$REQ sl$OBJ))
(declare-const insR (pfun sl$REQ sl$OBJ))
(declare-const item (pfun sl$Node sl$OBJ))
(declare-const left (pfun sl$Node sl$Node))
(declare-const nL (pfun sl$REQ sl$Node))
(declare-const nR (pfun sl$REQ sl$Node))
(declare-const new (set sl$Node))
(declare-const node (set sl$Node))
(declare-const p Int)
(declare-const popL (set sl$REQ))
(declare-const popR (set sl$REQ))
(declare-const ppd (set sl$REQ))
(declare-const pshL (set sl$REQ))
(declare-const pshR (set sl$REQ))
(declare-const q Int)
(declare-const qe (pfun Int sl$OBJ))
(declare-const rep (pfun Int sl$Node))
(declare-const req (set sl$REQ))
(declare-const res (pfun sl$REQ sl$OBJ))
(declare-const result sl$OBJ)
(declare-const right (pfun sl$Node sl$Node))
(declare-const ver Int)
(declare-fun apply@@Int@@sl$Node
             ( (pfun Int sl$Node)
               Int )
             sl$Node)
(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)
(declare-fun apply@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node)
               sl$Node )
             sl$Node)
(declare-fun apply@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ)
               sl$Node )
             sl$OBJ)
(declare-fun between (Int Int Int) Bool)
(declare-fun betweenL (Int Int Int) Bool)
(declare-fun betweenLR (Int Int Int) Bool)
(declare-fun betweenR (Int Int Int) Bool)
(declare-fun card@@Int ( (set Int) ) Int)
(declare-fun card@@sl$Node ( (set sl$Node) ) Int)
(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)
(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)
(declare-fun dom@@Int@@sl$Node ( (pfun Int sl$Node) ) (set Int))
(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))
(declare-fun dom@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node) )
             (set sl$Node))
(declare-fun dom@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ) )
             (set sl$Node))
(declare-fun dom@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node) )
             (set sl$REQ))
(declare-fun dom@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ) )
             (set sl$REQ))
(declare-fun dom-rest@@Int@@sl$Node
             ( (set Int)
               (pfun Int sl$Node) )
             (pfun Int sl$Node))
(declare-fun dom-rest@@Int@@sl$OBJ
             ( (set Int)
               (pfun Int sl$OBJ) )
             (pfun Int sl$OBJ))
(declare-fun dom-rest@@sl$Node@@sl$Node
             ( (set sl$Node)
               (pfun sl$Node sl$Node) )
             (pfun sl$Node sl$Node))
(declare-fun dom-rest@@sl$Node@@sl$OBJ
             ( (set sl$Node)
               (pfun sl$Node sl$OBJ) )
             (pfun sl$Node sl$OBJ))
(declare-fun dom-rest@@sl$REQ@@sl$Node
             ( (set sl$REQ)
               (pfun sl$REQ sl$Node) )
             (pfun sl$REQ sl$Node))
(declare-fun dom-rest@@sl$REQ@@sl$OBJ
             ( (set sl$REQ)
               (pfun sl$REQ sl$OBJ) )
             (pfun sl$REQ sl$OBJ))
(declare-fun dom-subt@@Int@@sl$Node
             ( (set Int)
               (pfun Int sl$Node) )
             (pfun Int sl$Node))
(declare-fun dom-subt@@Int@@sl$OBJ
             ( (set Int)
               (pfun Int sl$OBJ) )
             (pfun Int sl$OBJ))
(declare-fun dom-subt@@sl$Node@@sl$Node
             ( (set sl$Node)
               (pfun sl$Node sl$Node) )
             (pfun sl$Node sl$Node))
(declare-fun dom-subt@@sl$Node@@sl$OBJ
             ( (set sl$Node)
               (pfun sl$Node sl$OBJ) )
             (pfun sl$Node sl$OBJ))
(declare-fun dom-subt@@sl$REQ@@sl$Node
             ( (set sl$REQ)
               (pfun sl$REQ sl$Node) )
             (pfun sl$REQ sl$Node))
(declare-fun dom-subt@@sl$REQ@@sl$OBJ
             ( (set sl$REQ)
               (pfun sl$REQ sl$OBJ) )
             (pfun sl$REQ sl$OBJ))
(declare-fun empty-fun@@Int@@sl$Node () (pfun Int sl$Node))
(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))
(declare-fun empty-fun@@sl$Node@@sl$Node
             ()
             (pfun sl$Node sl$Node))
(declare-fun empty-fun@@sl$Node@@sl$OBJ
             ()
             (pfun sl$Node sl$OBJ))
(declare-fun empty-fun@@sl$REQ@@sl$Node
             ()
             (pfun sl$REQ sl$Node))
(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))
(declare-fun finite@@Int ( (set Int) ) Bool)
(declare-fun finite@@sl$Node ( (set sl$Node) ) Bool)
(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)
(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)
(declare-fun injective@@Int@@sl$Node ( (pfun Int sl$Node) ) Bool)
(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)
(declare-fun injective@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node) )
             Bool)
(declare-fun injective@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ) )
             Bool)
(declare-fun injective@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node) )
             Bool)
(declare-fun injective@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ) )
             Bool)
(declare-fun interval (Int Int) (set Int))
(declare-fun intervalL (Int Int) (set Int))
(declare-fun intervalLR (Int Int) (set Int))
(declare-fun intervalR (Int Int) (set Int))
(declare-fun mk-fun@@Int@@sl$Node
             (Int sl$Node)
             (pfun Int sl$Node))
(declare-fun mk-fun@@Int@@sl$OBJ
             (Int sl$OBJ)
             (pfun Int sl$OBJ))
(declare-fun mk-fun@@sl$Node@@sl$Node
             (sl$Node sl$Node)
             (pfun sl$Node sl$Node))
(declare-fun mk-fun@@sl$Node@@sl$OBJ
             (sl$Node sl$OBJ)
             (pfun sl$Node sl$OBJ))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@sl$Node (sl$Node) (set sl$Node))
(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))
(declare-fun ovl@@Int@@sl$Node
             ( (pfun Int sl$Node)
               (pfun Int sl$Node) )
             (pfun Int sl$Node))
(declare-fun ovl@@Int@@sl$OBJ
             ( (pfun Int sl$OBJ)
               (pfun Int sl$OBJ) )
             (pfun Int sl$OBJ))
(declare-fun ovl@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node)
               (pfun sl$Node sl$Node) )
             (pfun sl$Node sl$Node))
(declare-fun ovl@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ)
               (pfun sl$Node sl$OBJ) )
             (pfun sl$Node sl$OBJ))
(declare-fun ovl@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node)
               (pfun sl$REQ sl$Node) )
             (pfun sl$REQ sl$Node))
(declare-fun ovl@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ)
               (pfun sl$REQ sl$OBJ) )
             (pfun sl$REQ sl$OBJ))
(declare-fun ran@@Int@@sl$Node
             ( (pfun Int sl$Node) )
             (set sl$Node))
(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))
(declare-fun ran@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node) )
             (set sl$Node))
(declare-fun ran@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ) )
             (set sl$OBJ))
(declare-fun ran@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node) )
             (set sl$Node))
(declare-fun ran@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ) )
             (set sl$OBJ))
(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))
(define-fun all@@sl$Node
            ()
            (set sl$Node)
            ( (as const (set sl$Node))
              true ))
(define-fun all@@sl$OBJ
            ()
            (set sl$OBJ)
            ( (as const (set sl$OBJ))
              true ))
(define-fun all@@sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              true ))
(define-fun compl@@Int
            ( (s1 (set Int)) )
            (set Int)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$Node
            ( (s1 (set sl$Node)) )
            (set sl$Node)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$OBJ
            ( (s1 (set sl$OBJ)) )
            (set sl$OBJ)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$REQ
            ( (s1 (set sl$REQ)) )
            (set sl$REQ)
            ( (_ map not)
              s1 ))
(define-fun elem@@Int
            ( (x Int)
              (s1 (set Int)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$Node
            ( (x sl$Node)
              (s1 (set sl$Node)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$OBJ
            ( (x sl$OBJ)
              (s1 (set sl$OBJ)) )
            Bool
            (select s1 x))
(define-fun empty-set@@Int
            ()
            (set Int)
            ( (as const (set Int))
              false ))
(define-fun empty-set@@sl$Node
            ()
            (set sl$Node)
            ( (as const (set sl$Node))
              false ))
(define-fun empty-set@@sl$OBJ
            ()
            (set sl$OBJ)
            ( (as const (set sl$OBJ))
              false ))
(define-fun empty-set@@sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              false ))
(define-fun set-diff@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            (set Int)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$Node
            ( (s1 (set sl$Node))
              (s2 (set sl$Node)) )
            (set sl$Node)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$OBJ
            ( (s1 (set sl$OBJ))
              (s2 (set sl$OBJ)) )
            (set sl$OBJ)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$REQ
            ( (s1 (set sl$REQ))
              (s2 (set sl$REQ)) )
            (set sl$REQ)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$Node
            ( (s1 (set sl$Node))
              (s2 (set sl$Node)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$OBJ
            ( (s1 (set sl$OBJ))
              (s2 (set sl$OBJ)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$REQ
            ( (s1 (set sl$REQ))
              (s2 (set sl$REQ)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Node
            ()
            (set sl$Node)
            ( (as const (set sl$Node))
              true ))
(define-fun sl$OBJ
            ()
            (set sl$OBJ)
            ( (as const (set sl$OBJ))
              true ))
(define-fun sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              true ))
(assert (forall ( (r (set Int)) )
                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))
                   :pattern
                   ( (<= 0 (card@@Int r)) ))))
(assert (forall ( (r (set sl$Node)) )
                (! (=> (finite@@sl$Node r) (<= 0 (card@@sl$Node r)))
                   :pattern
                   ( (<= 0 (card@@sl$Node r)) ))))
(assert (forall ( (r (set sl$OBJ)) )
                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))
                   :pattern
                   ( (<= 0 (card@@sl$OBJ r)) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))
                   :pattern
                   ( (<= 0 (card@@sl$REQ r)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set sl$Node)) )
                (! (= (= (card@@sl$Node r) 0) (= r empty-set@@sl$Node))
                   :pattern
                   ( (card@@sl$Node r) ))))
(assert (forall ( (r (set sl$OBJ)) )
                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))
                   :pattern
                   ( (card@@sl$OBJ r) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))
                   :pattern
                   ( (card@@sl$REQ r) ))))
(assert (forall ( (x Int) )
                (! (= (card@@Int (mk-set@@Int x)) 1)
                   :pattern
                   ( (card@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x sl$Node) )
                (! (= (card@@sl$Node (mk-set@@sl$Node x)) 1)
                   :pattern
                   ( (card@@sl$Node (mk-set@@sl$Node x)) ))))
(assert (forall ( (x sl$OBJ) )
                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)
                   :pattern
                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 1)
                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set sl$Node)) )
                (! (= (= (card@@sl$Node r) 1)
                      (exists ( (x sl$Node) )
                              (and true (= r (mk-set@@sl$Node x)))))
                   :pattern
                   ( (card@@sl$Node r) ))))
(assert (forall ( (r (set sl$OBJ)) )
                (! (= (= (card@@sl$OBJ r) 1)
                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))
                   :pattern
                   ( (card@@sl$OBJ r) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int)) )
                (! (=> (= (intersect r r0) empty-set@@Int)
                       (= (card@@Int (union r r0))
                          (+ (card@@Int r) (card@@Int r0))))
                   :pattern
                   ( (card@@Int (union r r0)) ))))
(assert (forall ( (r (set sl$Node))
                  (r0 (set sl$Node)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Node)
                       (= (card@@sl$Node (union r r0))
                          (+ (card@@sl$Node r) (card@@sl$Node r0))))
                   :pattern
                   ( (card@@sl$Node (union r r0)) ))))
(assert (forall ( (r (set sl$OBJ))
                  (r0 (set sl$OBJ)) )
                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)
                       (= (card@@sl$OBJ (union r r0))
                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))
                   :pattern
                   ( (card@@sl$OBJ (union r r0)) ))))
(assert (forall ( (r (set sl$REQ))
                  (r0 (set sl$REQ)) )
                (! (=> (= (intersect r r0) empty-set@@sl$REQ)
                       (= (card@@sl$REQ (union r r0))
                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))
                   :pattern
                   ( (card@@sl$REQ (union r r0)) ))))
(assert (= (dom@@Int@@sl$Node empty-fun@@Int@@sl$Node)
           empty-set@@Int))
(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)
           empty-set@@Int))
(assert (= (dom@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)
           empty-set@@sl$Node))
(assert (= (dom@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)
           empty-set@@sl$Node))
(assert (= (dom@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)
           empty-set@@sl$REQ))
(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)
           empty-set@@sl$REQ))
(assert (forall ( (f1 (pfun Int sl$Node)) )
                (! (= (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) f1)
                   :pattern
                   ( (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ)) )
                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)
                   :pattern
                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node)) )
                (! (= (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )
                (! (= (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )
                (! (= (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )
                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))
(assert (forall ( (f1 (pfun Int sl$Node)) )
                (! (= (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) f1)
                   :pattern
                   ( (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ)) )
                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)
                   :pattern
                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node)) )
                (! (= (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )
                (! (= (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )
                (! (= (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )
                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))
(assert (forall ( (x Int)
                  (y sl$Node) )
                (! (= (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))
                      (mk-set@@Int x))
                   :pattern
                   ( (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))
(assert (forall ( (x Int)
                  (y sl$OBJ) )
                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))
                      (mk-set@@Int x))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))
                      (mk-set@@sl$Node x))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$OBJ) )
                (! (= (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))
                      (mk-set@@sl$Node x))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (f2 (pfun Int sl$Node))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$Node f2))
                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)
                          (apply@@Int@@sl$Node f2 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (f2 (pfun Int sl$OBJ))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))
                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)
                          (apply@@Int@@sl$OBJ f2 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (f2 (pfun sl$Node sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))
                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)
                          (apply@@sl$Node@@sl$Node f2 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (f2 (pfun sl$Node sl$OBJ))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))
                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)
                          (apply@@sl$Node@@sl$OBJ f2 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (f2 (pfun Int sl$Node))
                  (x Int) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))
                            (not (elem@@Int x (dom@@Int@@sl$Node f2))))
                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)
                          (apply@@Int@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (f2 (pfun Int sl$OBJ))
                  (x Int) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))
                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)
                          (apply@@Int@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (f2 (pfun sl$Node sl$Node))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))))
                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)
                          (apply@@sl$Node@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (f2 (pfun sl$Node sl$OBJ))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))))
                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)
                          (apply@@sl$Node@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (x Int)
                  (y sl$Node) )
                (! (= (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x) ))))
(assert (forall ( (x Int)
                  (y sl$OBJ) )
                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x) ))))
(assert (forall ( (x sl$Node)
                  (y sl$OBJ) )
                (! (= (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (and (elem@@Int x s1)
                            (elem@@Int x (dom@@Int@@sl$Node f1)))
                       (= (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x)
                          (apply@@Int@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (and (elem@@Int x s1)
                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))
                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)
                          (apply@@Int@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x s1)
                            (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))
                       (= (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x)
                          (apply@@sl$Node@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x s1)
                            (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))
                       (= (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x)
                          (apply@@sl$Node@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))
                       (= (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x)
                          (apply@@Int@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))
                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)
                          (apply@@Int@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))
                       (= (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x)
                          (apply@@sl$Node@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))
                       (= (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x)
                          (apply@@sl$Node@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (f2 (pfun Int sl$Node)) )
                (! (= (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2))
                      (union (dom@@Int@@sl$Node f1) (dom@@Int@@sl$Node f2)))
                   :pattern
                   ( (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (f2 (pfun Int sl$OBJ)) )
                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))
                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (f2 (pfun sl$Node sl$Node)) )
                (! (= (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2))
                      (union (dom@@sl$Node@@sl$Node f1)
                             (dom@@sl$Node@@sl$Node f2)))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (f2 (pfun sl$Node sl$OBJ)) )
                (! (= (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2))
                      (union (dom@@sl$Node@@sl$OBJ f1)
                             (dom@@sl$Node@@sl$OBJ f2)))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (f2 (pfun sl$REQ sl$Node)) )
                (! (= (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2))
                      (union (dom@@sl$REQ@@sl$Node f1)
                             (dom@@sl$REQ@@sl$Node f2)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (f2 (pfun sl$REQ sl$OBJ)) )
                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))
                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))
                      (intersect s1 (dom@@Int@@sl$Node f1)))
                   :pattern
                   ( (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))
                      (intersect s1 (dom@@Int@@sl$OBJ f1)))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))
                      (intersect s1 (dom@@sl$Node@@sl$Node f1)))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))
                      (intersect s1 (dom@@sl$Node@@sl$OBJ f1)))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))
                      (intersect s1 (dom@@sl$REQ@@sl$Node f1)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))
                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))
                      (set-diff@@Int (dom@@Int@@sl$Node f1) s1))
                   :pattern
                   ( (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))
                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))
                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))
                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))
                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))
                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (x2 Int)
                  (y sl$Node) )
                (! (=> (not (= x x2))
                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                               x2)
                          (apply@@Int@@sl$Node f1 x2)))
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                          x2) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (x2 Int)
                  (y sl$OBJ) )
                (! (=> (not (= x x2))
                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))
                                              x2)
                          (apply@@Int@@sl$OBJ f1 x2)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))
                                         x2) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (x2 sl$Node)
                  (y sl$Node) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                                   x2)
                          (apply@@sl$Node@@sl$Node f1 x2)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                              x2) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (x2 sl$Node)
                  (y sl$OBJ) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                                  x2)
                          (apply@@sl$Node@@sl$OBJ f1 x2)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                             x2) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                           x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                          x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                               x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                              x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                              x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                             x) ))))
(assert (= (ran@@Int@@sl$Node empty-fun@@Int@@sl$Node)
           empty-set@@sl$Node))
(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)
           empty-set@@sl$OBJ))
(assert (= (ran@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)
           empty-set@@sl$Node))
(assert (= (ran@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)
           empty-set@@sl$OBJ))
(assert (= (ran@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)
           empty-set@@sl$Node))
(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)
           empty-set@@sl$OBJ))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (y sl$Node) )
                (! (= (elem@@sl$Node y (ran@@Int@@sl$Node f1))
                      (exists ( (x Int) )
                              (and true
                                   (and (elem@@Int x (dom@@Int@@sl$Node f1))
                                        (= (apply@@Int@@sl$Node f1 x) y)))))
                   :pattern
                   ( (elem@@sl$Node y (ran@@Int@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))
                      (exists ( (x Int) )
                              (and true
                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))
                   :pattern
                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (y sl$Node) )
                (! (= (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1))
                      (exists ( (x sl$Node) )
                              (and true
                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                                        (= (apply@@sl$Node@@sl$Node f1 x) y)))))
                   :pattern
                   ( (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1))
                      (exists ( (x sl$Node) )
                              (and true
                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                                        (= (apply@@sl$Node@@sl$OBJ f1 x) y)))))
                   :pattern
                   ( (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1)) ))))
(assert (forall ( (x Int)
                  (y sl$Node) )
                (! (= (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))
                      (mk-set@@sl$Node y))
                   :pattern
                   ( (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))
(assert (forall ( (x Int)
                  (y sl$OBJ) )
                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))
                      (mk-set@@sl$OBJ y))
                   :pattern
                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))
                      (mk-set@@sl$Node y))
                   :pattern
                   ( (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$OBJ) )
                (! (= (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))
                      (mk-set@@sl$OBJ y))
                   :pattern
                   ( (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))
(assert (forall ( (f1 (pfun Int sl$Node)) )
                (! (= (injective@@Int@@sl$Node f1)
                      (forall ( (x Int)
                                (x2 Int) )
                              (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))
                                       (elem@@Int x2 (dom@@Int@@sl$Node f1)))
                                  (=> (= (apply@@Int@@sl$Node f1 x)
                                         (apply@@Int@@sl$Node f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@Int@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ)) )
                (! (= (injective@@Int@@sl$OBJ f1)
                      (forall ( (x Int)
                                (x2 Int) )
                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))
                                  (=> (= (apply@@Int@@sl$OBJ f1 x)
                                         (apply@@Int@@sl$OBJ f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@Int@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node)) )
                (! (= (injective@@sl$Node@@sl$Node f1)
                      (forall ( (x sl$Node)
                                (x2 sl$Node) )
                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$Node f1)))
                                  (=> (= (apply@@sl$Node@@sl$Node f1 x)
                                         (apply@@sl$Node@@sl$Node f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$Node@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )
                (! (= (injective@@sl$Node@@sl$OBJ f1)
                      (forall ( (x sl$Node)
                                (x2 sl$Node) )
                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$OBJ f1)))
                                  (=> (= (apply@@sl$Node@@sl$OBJ f1 x)
                                         (apply@@sl$Node@@sl$OBJ f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$Node@@sl$OBJ f1) ))))
(assert (injective@@Int@@sl$Node empty-fun@@Int@@sl$Node))
(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))
(assert (injective@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node))
(assert (injective@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ))
(assert (injective@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node))
(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$Node f1))
                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)))
                   :pattern
                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))
                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                      (ran@@sl$Node@@sl$Node f1)))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                    (ran@@sl$Node@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                     (ran@@sl$Node@@sl$OBJ f1)))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                   (ran@@sl$Node@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                      (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                    (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                      (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                    (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                     (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                   (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                      (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                    (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                      (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                    (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                     (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                   (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))
                            (injective@@Int@@sl$Node f1))
                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))
                          (union (set-diff@@sl$Node (ran@@Int@@sl$Node f1)
                                                    (mk-set@@sl$Node (apply@@Int@@sl$Node f1 x)))
                                 (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                            (injective@@Int@@sl$OBJ f1))
                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))
                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)
                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))
                                 (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                            (injective@@sl$Node@@sl$Node f1))
                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))
                          (union (set-diff@@sl$Node (ran@@sl$Node@@sl$Node f1)
                                                    (mk-set@@sl$Node (apply@@sl$Node@@sl$Node f1 x)))
                                 (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                            (injective@@sl$Node@@sl$OBJ f1))
                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))
                          (union (set-diff@@sl$OBJ (ran@@sl$Node@@sl$OBJ f1)
                                                   (mk-set@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)))
                                 (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (=> (not (elem@@Int x (dom@@Int@@sl$Node f1)))
                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))
                          (union (ran@@Int@@sl$Node f1) (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))
                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))
                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))
                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))
                          (union (ran@@sl$Node@@sl$Node f1) (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))
                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))
                          (union (ran@@sl$Node@@sl$OBJ f1) (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))
                   :pattern
                   ( (elem@@Int x (mk-set@@Int y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (elem@@sl$Node x (mk-set@@sl$Node y)) (= x y))
                   :pattern
                   ( (elem@@sl$Node x (mk-set@@sl$Node y)) ))))
(assert (forall ( (x sl$OBJ)
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))
                   :pattern
                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (finite@@Int s1)
                       (finite@@Int (set-diff@@Int s1 s2)))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (=> (finite@@sl$Node s1)
                       (finite@@sl$Node (set-diff@@sl$Node s1 s2)))
                   :pattern
                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ))
                  (s2 (set sl$OBJ)) )
                (! (=> (finite@@sl$OBJ s1)
                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (finite@@sl$REQ s1)
                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))
                   :pattern
                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s1) (finite@@Int s2))
                       (finite@@Int (union s1 s2)))
                   :pattern
                   ( (finite@@Int (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (=> (and (finite@@sl$Node s1) (finite@@sl$Node s2))
                       (finite@@sl$Node (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Node (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ))
                  (s2 (set sl$OBJ)) )
                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))
                       (finite@@sl$OBJ (union s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))
                       (finite@@sl$REQ (union s1 s2)))
                   :pattern
                   ( (finite@@sl$REQ (union s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))
                       (not (finite@@Int (set-diff@@Int s1 s2))))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (=> (and (finite@@sl$Node s2) (not (finite@@sl$Node s1)))
                       (not (finite@@sl$Node (set-diff@@sl$Node s1 s2))))
                   :pattern
                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ))
                  (s2 (set sl$OBJ)) )
                (! (=> (and (finite@@sl$OBJ s2) (not (finite@@sl$OBJ s1)))
                       (not (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2))))
                   :pattern
                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))
                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))
                   :pattern
                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))
(assert (forall ( (x Int) )
                (! (finite@@Int (mk-set@@Int x))
                   :pattern
                   ( (finite@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x sl$Node) )
                (! (finite@@sl$Node (mk-set@@sl$Node x))
                   :pattern
                   ( (finite@@sl$Node (mk-set@@sl$Node x)) ))))
(assert (forall ( (x sl$OBJ) )
                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))
                   :pattern
                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))
(assert (finite@@Int empty-set@@Int))
(assert (finite@@sl$Node empty-set@@sl$Node))
(assert (finite@@sl$OBJ empty-set@@sl$OBJ))
(assert (finite@@sl$REQ empty-set@@sl$REQ))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (interval m n))
                      (and (<= m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (interval m n)) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalR m n))
                      (and (<= m x) (< x n)))
                   :pattern
                   ( (elem@@Int x (intervalR m n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (intervalR m n) (mk-set@@Int n))
                          (intervalR m (+ n 1))))
                   :pattern
                   ( (union (intervalR m n) (mk-set@@Int n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))
                          (intervalL m (+ n 1))))
                   :pattern
                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))
                          (intervalR (- m 1) n)))
                   :pattern
                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (mk-set@@Int m) (intervalL m n))
                          (intervalL (- m 1) n)))
                   :pattern
                   ( (union (mk-set@@Int m) (intervalL m n)) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (between x y z) (and (<= x y) (<= y z)))
                   :pattern
                   ( (between x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenR x y z) (and (<= x y) (< y z)))
                   :pattern
                   ( (betweenR x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenL x y z) (and (< x y) (<= y z)))
                   :pattern
                   ( (betweenL x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenLR x y z) (and (< x y) (< y z)))
                   :pattern
                   ( (betweenLR x y z) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalL m n))
                      (and (< m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (intervalL m n)) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalL m n))
                      (and (< m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (intervalL m n)) ))))
(assert (forall ( (m Int) )
                (! (= (intervalR m m) empty-set@@Int)
                   :pattern
                   ( (intervalR m m) ))))
(assert (forall ( (m Int) )
                (! (= (intervalL m m) empty-set@@Int)
                   :pattern
                   ( (intervalL m m) ))))
(assert (forall ( (m Int) )
                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))
                   :pattern
                   ( (intervalR m (+ m 1)) ))))
(assert (forall ( (m Int) )
                (! (= (intervalL (- m 1) m) (mk-set@@Int m))
                   :pattern
                   ( (intervalL (- m 1) m) ))))
(assert (forall ( (m Int)
                  (n Int)
                  (p Int) )
                (! (=> (and (<= m n) (<= n p))
                       (= (union (intervalR m n) (intervalR n p))
                          (intervalR m p)))
                   :pattern
                   ( (union (intervalR m n) (intervalR n p)) ))))
(assert (forall ( (m Int)
                  (n Int)
                  (p Int) )
                (! (=> (and (<= m n) (<= n p))
                       (= (union (intervalL m n) (intervalL n p))
                          (intervalL m p)))
                   :pattern
                   ( (union (intervalL m n) (intervalL n p)) ))))
; m1:init0
(assert (= ver 0))
; m2:init0
(assert (= pshL empty-set@@sl$REQ))
; m2:init1
(assert (= popL empty-set@@sl$REQ))
; m2:init2
(assert (= pshR empty-set@@sl$REQ))
; m2:init3
(assert (= popR empty-set@@sl$REQ))
; m2:init4
(assert (= ppd empty-set@@sl$REQ))
; m3:init0
(assert (= q 0))
; m3:init1
(assert (= qe empty-fun@@Int@@sl$OBJ))
; m3:init2
(assert (= insL empty-fun@@sl$REQ@@sl$OBJ))
; m3:init3
(assert (= res empty-fun@@sl$REQ@@sl$OBJ))
; m3:init4
(assert (= insR empty-fun@@sl$REQ@@sl$OBJ))
; m4:asm0
(assert (not (finite@@sl$Node sl$Node)))
; m4:init0
(assert (= rep empty-fun@@Int@@sl$Node))
; m4:init2
(assert (= node (mk-set@@sl$Node dummy)))
; m4:init3
(assert (= nL empty-fun@@sl$REQ@@sl$Node))
; m4:init4
(assert (= nR empty-fun@@sl$REQ@@sl$Node))
; m5:init0
(assert (= left (mk-fun@@sl$Node@@sl$Node dummy dummy)))
; m5:init1
(assert (= right (mk-fun@@sl$Node@@sl$Node dummy dummy)))
; m5:init2
(assert (= RH dummy))
(assert (not (exists ( (item (pfun sl$Node sl$OBJ))
                       (val sl$OBJ) )
                     (and true (= item (mk-fun@@sl$Node@@sl$OBJ dummy val))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m5/INIT/FIS/item
