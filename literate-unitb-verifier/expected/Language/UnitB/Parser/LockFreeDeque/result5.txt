; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
; comment: we don't need to declare the sort Bool
(declare-sort sl$G 0)
; comment: we don't need to declare the sort Int
(declare-sort sl$REQ 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const emp Bool)
(declare-const emp@prime Bool)
(declare-const p Int)
(declare-const p@prime Int)
(declare-const popL (set sl$REQ))
(declare-const popL@prime (set sl$REQ))
(declare-const popR (set sl$REQ))
(declare-const popR@prime (set sl$REQ))
(declare-const pshL (pfun sl$REQ sl$G))
(declare-const pshL@prime (pfun sl$REQ sl$G))
(declare-const pshR (pfun sl$REQ sl$G))
(declare-const pshR@prime (pfun sl$REQ sl$G))
(declare-const q Int)
(declare-const q@prime Int)
(declare-const qe (pfun Int sl$G))
(declare-const qe@prime (pfun Int sl$G))
(declare-const r sl$REQ)
(declare-const res sl$G)
(declare-const res@prime sl$G)
(declare-const resL (pfun sl$REQ sl$G))
(declare-const resL@prime (pfun sl$REQ sl$G))
(declare-const resR (pfun sl$REQ sl$G))
(declare-const resR@prime (pfun sl$REQ sl$G))
(declare-fun between (Int Int Int) Bool)
(declare-fun betweenL (Int Int Int) Bool)
(declare-fun betweenLR (Int Int Int) Bool)
(declare-fun betweenR (Int Int Int) Bool)
(declare-fun card@@Int ( (set Int) ) Int)
(declare-fun card@@sl$G ( (set sl$G) ) Int)
(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)
(declare-fun card@Open@@pfun@@Int@@sl$G@Close
             ( (set (pfun Int sl$G)) )
             Int)
(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))
(declare-fun dom@@sl$REQ@@sl$G
             ( (pfun sl$REQ sl$G) )
             (set sl$REQ))
(declare-fun dom-rest@@Int@@sl$G
             ( (set Int)
               (pfun Int sl$G) )
             (pfun Int sl$G))
(declare-fun dom-rest@@sl$REQ@@sl$G
             ( (set sl$REQ)
               (pfun sl$REQ sl$G) )
             (pfun sl$REQ sl$G))
(declare-fun dom-subt@@Int@@sl$G
             ( (set Int)
               (pfun Int sl$G) )
             (pfun Int sl$G))
(declare-fun dom-subt@@sl$REQ@@sl$G
             ( (set sl$REQ)
               (pfun sl$REQ sl$G) )
             (pfun sl$REQ sl$G))
(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))
(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))
(declare-fun finite@@Int ( (set Int) ) Bool)
(declare-fun finite@@sl$G ( (set sl$G) ) Bool)
(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)
(declare-fun finite@Open@@pfun@@Int@@sl$G@Close
             ( (set (pfun Int sl$G)) )
             Bool)
(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)
(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)
(declare-fun interval (Int Int) (set Int))
(declare-fun intervalL (Int Int) (set Int))
(declare-fun intervalLR (Int Int) (set Int))
(declare-fun intervalR (Int Int) (set Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))
(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close
             ( (pfun Int sl$G) )
             (set (pfun Int sl$G)))
(declare-fun ovl@@Int@@sl$G
             ( (pfun Int sl$G)
               (pfun Int sl$G) )
             (pfun Int sl$G))
(declare-fun ovl@@sl$REQ@@sl$G
             ( (pfun sl$REQ sl$G)
               (pfun sl$REQ sl$G) )
             (pfun sl$REQ sl$G))
(declare-fun pfun@@Int@@sl$G
             ( (set Int)
               (set sl$G) )
             (set (pfun Int sl$G)))
(declare-fun r@param () sl$REQ)
(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))
(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))
(declare-fun tfun@@Int@@sl$G
             ( (set Int)
               (set sl$G) )
             (set (pfun Int sl$G)))
(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))
(define-fun all@@sl$G
            ()
            (set sl$G)
            ( (as const (set sl$G))
              true ))
(define-fun all@@sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              true ))
(define-fun all@Open@@pfun@@Int@@sl$G@Close
            ()
            (set (pfun Int sl$G))
            ( (as const (set (pfun Int sl$G)))
              true ))
(define-fun compl@@Int
            ( (s1 (set Int)) )
            (set Int)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$G
            ( (s1 (set sl$G)) )
            (set sl$G)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$REQ
            ( (s1 (set sl$REQ)) )
            (set sl$REQ)
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@Int@@sl$G@Close
            ( (s1 (set (pfun Int sl$G))) )
            (set (pfun Int sl$G))
            ( (_ map not)
              s1 ))
(define-fun elem@@Int
            ( (x Int)
              (s1 (set Int)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$REQ
            ( (x sl$REQ)
              (s1 (set sl$REQ)) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@Int@@sl$G@Close
            ( (x (pfun Int sl$G))
              (s1 (set (pfun Int sl$G))) )
            Bool
            (select s1 x))
(define-fun empty-set@@Int
            ()
            (set Int)
            ( (as const (set Int))
              false ))
(define-fun empty-set@@sl$G
            ()
            (set sl$G)
            ( (as const (set sl$G))
              false ))
(define-fun empty-set@@sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              false ))
(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close
            ()
            (set (pfun Int sl$G))
            ( (as const (set (pfun Int sl$G)))
              false ))
(define-fun set-diff@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            (set Int)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$G
            ( (s1 (set sl$G))
              (s2 (set sl$G)) )
            (set sl$G)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$REQ
            ( (s1 (set sl$REQ))
              (s2 (set sl$REQ)) )
            (set sl$REQ)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close
            ( (s1 (set (pfun Int sl$G)))
              (s2 (set (pfun Int sl$G))) )
            (set (pfun Int sl$G))
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$G
            ( (s1 (set sl$G))
              (s2 (set sl$G)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$REQ
            ( (s1 (set sl$REQ))
              (s2 (set sl$REQ)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close
            ( (s1 (set (pfun Int sl$G)))
              (s2 (set (pfun Int sl$G))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))
(define-fun sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              true ))
(assert (forall ( (r (set Int)) )
                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))
                   :pattern
                   ( (<= 0 (card@@Int r)) ))))
(assert (forall ( (r (set (pfun Int sl$G))) )
                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)
                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))
(assert (forall ( (r (set sl$G)) )
                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))
                   :pattern
                   ( (<= 0 (card@@sl$G r)) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))
                   :pattern
                   ( (<= 0 (card@@sl$REQ r)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set (pfun Int sl$G))) )
                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)
                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))
(assert (forall ( (r (set sl$G)) )
                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))
                   :pattern
                   ( (card@@sl$G r) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))
                   :pattern
                   ( (card@@sl$REQ r) ))))
(assert (forall ( (x Int) )
                (! (= (card@@Int (mk-set@@Int x)) 1)
                   :pattern
                   ( (card@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x (pfun Int sl$G)) )
                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))
(assert (forall ( (x sl$REQ) )
                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)
                   :pattern
                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 1)
                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set (pfun Int sl$G))) )
                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)
                      (exists ( (x (pfun Int sl$G)) )
                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (= (= (card@@sl$REQ r) 1)
                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))
                   :pattern
                   ( (card@@sl$REQ r) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int)) )
                (! (=> (= (intersect r r0) empty-set@@Int)
                       (= (card@@Int (union r r0))
                          (+ (card@@Int r) (card@@Int r0))))
                   :pattern
                   ( (card@@Int (union r r0)) ))))
(assert (forall ( (r (set (pfun Int sl$G)))
                  (r0 (set (pfun Int sl$G))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@Int@@sl$G@Close)
                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))
                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)
                             (card@Open@@pfun@@Int@@sl$G@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))
(assert (forall ( (r (set sl$G))
                  (r0 (set sl$G)) )
                (! (=> (= (intersect r r0) empty-set@@sl$G)
                       (= (card@@sl$G (union r r0))
                          (+ (card@@sl$G r) (card@@sl$G r0))))
                   :pattern
                   ( (card@@sl$G (union r r0)) ))))
(assert (forall ( (r (set sl$REQ))
                  (r0 (set sl$REQ)) )
                (! (=> (= (intersect r r0) empty-set@@sl$REQ)
                       (= (card@@sl$REQ (union r r0))
                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))
                   :pattern
                   ( (card@@sl$REQ (union r r0)) ))))
(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)
           empty-set@@Int))
(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)
           empty-set@@sl$REQ))
(assert (forall ( (f1 (pfun Int sl$G)) )
                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)
                   :pattern
                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$G)) )
                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))
(assert (forall ( (f1 (pfun Int sl$G)) )
                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)
                   :pattern
                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$G)) )
                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))
(assert (forall ( (s2 (set sl$G)) )
                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G
                                                     (tfun@@Int@@sl$G empty-set@@Int s2))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G
                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))
(assert (forall ( (f1 (pfun Int sl$G))
                  (f2 (pfun Int sl$G)) )
                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))
                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))
                   :pattern
                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$G))
                  (f2 (pfun sl$REQ sl$G)) )
                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))
                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))
(assert (forall ( (f1 (pfun Int sl$G))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))
                      (intersect s1 (dom@@Int@@sl$G f1)))
                   :pattern
                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$G))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))
                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$G))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))
                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))
                   :pattern
                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$G))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))
                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))
                   :pattern
                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))
(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)
           empty-set@@sl$G))
(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)
           empty-set@@sl$G))
(assert (forall ( (f1 (pfun Int sl$G))
                  (s1 (set Int))
                  (s2 (set sl$G)) )
                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))
                      (and (= s1 (dom@@Int@@sl$G f1))
                           (subset (ran@@Int@@sl$G f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))
(assert (forall ( (f1 (pfun Int sl$G))
                  (s1 (set Int))
                  (s2 (set sl$G)) )
                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))
                      (and (subset (dom@@Int@@sl$G f1) s1)
                           (subset (ran@@Int@@sl$G f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))
(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))
(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))
                   :pattern
                   ( (elem@@Int x (mk-set@@Int y)) ))))
(assert (forall ( (x (pfun Int sl$G))
                  (y (pfun Int sl$G)) )
                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$REQ) )
                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))
                   :pattern
                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (finite@@Int s1)
                       (finite@@Int (set-diff@@Int s1 s2)))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$G)))
                  (s2 (set (pfun Int sl$G))) )
                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)
                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))
(assert (forall ( (s1 (set sl$G))
                  (s2 (set sl$G)) )
                (! (=> (finite@@sl$G s1)
                       (finite@@sl$G (set-diff@@sl$G s1 s2)))
                   :pattern
                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (finite@@sl$REQ s1)
                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))
                   :pattern
                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s1) (finite@@Int s2))
                       (finite@@Int (union s1 s2)))
                   :pattern
                   ( (finite@@Int (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$G)))
                  (s2 (set (pfun Int sl$G))) )
                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)
                            (finite@Open@@pfun@@Int@@sl$G@Close s2))
                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$G))
                  (s2 (set sl$G)) )
                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))
                       (finite@@sl$G (union s1 s2)))
                   :pattern
                   ( (finite@@sl$G (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))
                       (finite@@sl$REQ (union s1 s2)))
                   :pattern
                   ( (finite@@sl$REQ (union s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))
                       (not (finite@@Int (set-diff@@Int s1 s2))))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$G)))
                  (s2 (set (pfun Int sl$G))) )
                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s2)
                            (not (finite@Open@@pfun@@Int@@sl$G@Close s1)))
                       (not (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))
(assert (forall ( (s1 (set sl$G))
                  (s2 (set sl$G)) )
                (! (=> (and (finite@@sl$G s2) (not (finite@@sl$G s1)))
                       (not (finite@@sl$G (set-diff@@sl$G s1 s2))))
                   :pattern
                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))
                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))
                   :pattern
                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))
(assert (forall ( (x Int) )
                (! (finite@@Int (mk-set@@Int x))
                   :pattern
                   ( (finite@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x (pfun Int sl$G)) )
                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))
(assert (forall ( (x sl$REQ) )
                (! (finite@@sl$REQ (mk-set@@sl$REQ x))
                   :pattern
                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))
(assert (finite@@Int empty-set@@Int))
(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))
(assert (finite@@sl$G empty-set@@sl$G))
(assert (finite@@sl$REQ empty-set@@sl$REQ))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (interval m n))
                      (and (<= m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (interval m n)) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalR m n))
                      (and (<= m x) (< x n)))
                   :pattern
                   ( (elem@@Int x (intervalR m n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (intervalR m n) (mk-set@@Int n))
                          (intervalR m (+ n 1))))
                   :pattern
                   ( (union (intervalR m n) (mk-set@@Int n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))
                          (intervalL m (+ n 1))))
                   :pattern
                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))
                          (intervalR (- m 1) n)))
                   :pattern
                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (mk-set@@Int m) (intervalL m n))
                          (intervalL (- m 1) n)))
                   :pattern
                   ( (union (mk-set@@Int m) (intervalL m n)) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (between x y z) (and (<= x y) (<= y z)))
                   :pattern
                   ( (between x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenR x y z) (and (<= x y) (< y z)))
                   :pattern
                   ( (betweenR x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenL x y z) (and (< x y) (<= y z)))
                   :pattern
                   ( (betweenL x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenLR x y z) (and (< x y) (< y z)))
                   :pattern
                   ( (betweenLR x y z) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalL m n))
                      (and (< m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (intervalL m n)) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalL m n))
                      (and (< m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (intervalL m n)) ))))
(assert (forall ( (m Int) )
                (! (= (intervalR m m) empty-set@@Int)
                   :pattern
                   ( (intervalR m m) ))))
(assert (forall ( (m Int) )
                (! (= (intervalL m m) empty-set@@Int)
                   :pattern
                   ( (intervalL m m) ))))
(assert (forall ( (m Int) )
                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))
                   :pattern
                   ( (intervalR m (+ m 1)) ))))
(assert (forall ( (m Int) )
                (! (= (intervalL (- m 1) m) (mk-set@@Int m))
                   :pattern
                   ( (intervalL (- m 1) m) ))))
(assert (forall ( (m Int)
                  (n Int)
                  (p Int) )
                (! (=> (and (<= m n) (<= n p))
                       (= (union (intervalR m n) (intervalR n p))
                          (intervalR m p)))
                   :pattern
                   ( (union (intervalR m n) (intervalR n p)) ))))
(assert (forall ( (m Int)
                  (n Int)
                  (p Int) )
                (! (=> (and (<= m n) (<= n p))
                       (= (union (intervalL m n) (intervalL n p))
                          (intervalL m p)))
                   :pattern
                   ( (union (intervalL m n) (intervalL n p)) ))))
(assert (= r@param r))
; m0:inv0
(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))
; m0:inv1
(assert (<= p q))
; m1:inv0
(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)
           empty-set@@sl$REQ))
; m1:inv1
(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)
           empty-set@@sl$REQ))
(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))
                 (elem@@sl$REQ r@param popL))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN
