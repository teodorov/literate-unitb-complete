; m5/INV/WD
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$Node 0)
(declare-sort sl$OBJ 0)
(declare-sort sl$REQ 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const LH sl$Node)
(declare-const RH sl$Node)
(declare-const dummy sl$Node)
(declare-const emp Bool)
(declare-const insL (pfun sl$REQ sl$OBJ))
(declare-const insR (pfun sl$REQ sl$OBJ))
(declare-const item (pfun sl$Node sl$OBJ))
(declare-const left (pfun sl$Node sl$Node))
(declare-const nL (pfun sl$REQ sl$Node))
(declare-const nR (pfun sl$REQ sl$Node))
(declare-const new (set sl$Node))
(declare-const node (set sl$Node))
(declare-const p Int)
(declare-const popL (set sl$REQ))
(declare-const popR (set sl$REQ))
(declare-const ppd (set sl$REQ))
(declare-const pshL (set sl$REQ))
(declare-const pshR (set sl$REQ))
(declare-const q Int)
(declare-const qe (pfun Int sl$OBJ))
(declare-const rep (pfun Int sl$Node))
(declare-const req (set sl$REQ))
(declare-const res (pfun sl$REQ sl$OBJ))
(declare-const result sl$OBJ)
(declare-const right (pfun sl$Node sl$Node))
(declare-const ver Int)
(declare-fun apply@@Int@@sl$Node
             ( (pfun Int sl$Node)
               Int )
             sl$Node)
(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)
(declare-fun apply@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node)
               sl$Node )
             sl$Node)
(declare-fun apply@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ)
               sl$Node )
             sl$OBJ)
(declare-fun apply@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node)
               sl$REQ )
             sl$Node)
(declare-fun apply@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ)
               sl$REQ )
             sl$OBJ)
(declare-fun between (Int Int Int) Bool)
(declare-fun betweenL (Int Int Int) Bool)
(declare-fun betweenLR (Int Int Int) Bool)
(declare-fun betweenR (Int Int Int) Bool)
(declare-fun card@@Int ( (set Int) ) Int)
(declare-fun card@@sl$Node ( (set sl$Node) ) Int)
(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)
(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)
(declare-fun card@Open@@pfun@@Int@@sl$Node@Close
             ( (set (pfun Int sl$Node)) )
             Int)
(declare-fun card@Open@@pfun@@Int@@sl$OBJ@Close
             ( (set (pfun Int sl$OBJ)) )
             Int)
(declare-fun card@Open@@pfun@@sl$Node@@sl$Node@Close
             ( (set (pfun sl$Node sl$Node)) )
             Int)
(declare-fun card@Open@@pfun@@sl$Node@@sl$OBJ@Close
             ( (set (pfun sl$Node sl$OBJ)) )
             Int)
(declare-fun card@Open@@pfun@@sl$REQ@@sl$Node@Close
             ( (set (pfun sl$REQ sl$Node)) )
             Int)
(declare-fun card@Open@@pfun@@sl$REQ@@sl$OBJ@Close
             ( (set (pfun sl$REQ sl$OBJ)) )
             Int)
(declare-fun dom@@Int@@sl$Node ( (pfun Int sl$Node) ) (set Int))
(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))
(declare-fun dom@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node) )
             (set sl$Node))
(declare-fun dom@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ) )
             (set sl$Node))
(declare-fun dom@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node) )
             (set sl$REQ))
(declare-fun dom@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ) )
             (set sl$REQ))
(declare-fun dom-rest@@Int@@sl$Node
             ( (set Int)
               (pfun Int sl$Node) )
             (pfun Int sl$Node))
(declare-fun dom-rest@@Int@@sl$OBJ
             ( (set Int)
               (pfun Int sl$OBJ) )
             (pfun Int sl$OBJ))
(declare-fun dom-rest@@sl$Node@@sl$Node
             ( (set sl$Node)
               (pfun sl$Node sl$Node) )
             (pfun sl$Node sl$Node))
(declare-fun dom-rest@@sl$Node@@sl$OBJ
             ( (set sl$Node)
               (pfun sl$Node sl$OBJ) )
             (pfun sl$Node sl$OBJ))
(declare-fun dom-rest@@sl$REQ@@sl$Node
             ( (set sl$REQ)
               (pfun sl$REQ sl$Node) )
             (pfun sl$REQ sl$Node))
(declare-fun dom-rest@@sl$REQ@@sl$OBJ
             ( (set sl$REQ)
               (pfun sl$REQ sl$OBJ) )
             (pfun sl$REQ sl$OBJ))
(declare-fun dom-subt@@Int@@sl$Node
             ( (set Int)
               (pfun Int sl$Node) )
             (pfun Int sl$Node))
(declare-fun dom-subt@@Int@@sl$OBJ
             ( (set Int)
               (pfun Int sl$OBJ) )
             (pfun Int sl$OBJ))
(declare-fun dom-subt@@sl$Node@@sl$Node
             ( (set sl$Node)
               (pfun sl$Node sl$Node) )
             (pfun sl$Node sl$Node))
(declare-fun dom-subt@@sl$Node@@sl$OBJ
             ( (set sl$Node)
               (pfun sl$Node sl$OBJ) )
             (pfun sl$Node sl$OBJ))
(declare-fun dom-subt@@sl$REQ@@sl$Node
             ( (set sl$REQ)
               (pfun sl$REQ sl$Node) )
             (pfun sl$REQ sl$Node))
(declare-fun dom-subt@@sl$REQ@@sl$OBJ
             ( (set sl$REQ)
               (pfun sl$REQ sl$OBJ) )
             (pfun sl$REQ sl$OBJ))
(declare-fun empty-fun@@Int@@sl$Node () (pfun Int sl$Node))
(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))
(declare-fun empty-fun@@sl$Node@@sl$Node
             ()
             (pfun sl$Node sl$Node))
(declare-fun empty-fun@@sl$Node@@sl$OBJ
             ()
             (pfun sl$Node sl$OBJ))
(declare-fun empty-fun@@sl$REQ@@sl$Node
             ()
             (pfun sl$REQ sl$Node))
(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))
(declare-fun finite@@Int ( (set Int) ) Bool)
(declare-fun finite@@sl$Node ( (set sl$Node) ) Bool)
(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)
(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)
(declare-fun finite@Open@@pfun@@Int@@sl$Node@Close
             ( (set (pfun Int sl$Node)) )
             Bool)
(declare-fun finite@Open@@pfun@@Int@@sl$OBJ@Close
             ( (set (pfun Int sl$OBJ)) )
             Bool)
(declare-fun finite@Open@@pfun@@sl$Node@@sl$Node@Close
             ( (set (pfun sl$Node sl$Node)) )
             Bool)
(declare-fun finite@Open@@pfun@@sl$Node@@sl$OBJ@Close
             ( (set (pfun sl$Node sl$OBJ)) )
             Bool)
(declare-fun finite@Open@@pfun@@sl$REQ@@sl$Node@Close
             ( (set (pfun sl$REQ sl$Node)) )
             Bool)
(declare-fun finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close
             ( (set (pfun sl$REQ sl$OBJ)) )
             Bool)
(declare-fun injective@@Int@@sl$Node ( (pfun Int sl$Node) ) Bool)
(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)
(declare-fun injective@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node) )
             Bool)
(declare-fun injective@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ) )
             Bool)
(declare-fun injective@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node) )
             Bool)
(declare-fun injective@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ) )
             Bool)
(declare-fun interval (Int Int) (set Int))
(declare-fun intervalL (Int Int) (set Int))
(declare-fun intervalLR (Int Int) (set Int))
(declare-fun intervalR (Int Int) (set Int))
(declare-fun mk-fun@@Int@@sl$Node
             (Int sl$Node)
             (pfun Int sl$Node))
(declare-fun mk-fun@@Int@@sl$OBJ
             (Int sl$OBJ)
             (pfun Int sl$OBJ))
(declare-fun mk-fun@@sl$Node@@sl$Node
             (sl$Node sl$Node)
             (pfun sl$Node sl$Node))
(declare-fun mk-fun@@sl$Node@@sl$OBJ
             (sl$Node sl$OBJ)
             (pfun sl$Node sl$OBJ))
(declare-fun mk-fun@@sl$REQ@@sl$Node
             (sl$REQ sl$Node)
             (pfun sl$REQ sl$Node))
(declare-fun mk-fun@@sl$REQ@@sl$OBJ
             (sl$REQ sl$OBJ)
             (pfun sl$REQ sl$OBJ))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@sl$Node (sl$Node) (set sl$Node))
(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))
(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))
(declare-fun mk-set@Open@@pfun@@Int@@sl$Node@Close
             ( (pfun Int sl$Node) )
             (set (pfun Int sl$Node)))
(declare-fun mk-set@Open@@pfun@@Int@@sl$OBJ@Close
             ( (pfun Int sl$OBJ) )
             (set (pfun Int sl$OBJ)))
(declare-fun mk-set@Open@@pfun@@sl$Node@@sl$Node@Close
             ( (pfun sl$Node sl$Node) )
             (set (pfun sl$Node sl$Node)))
(declare-fun mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close
             ( (pfun sl$Node sl$OBJ) )
             (set (pfun sl$Node sl$OBJ)))
(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close
             ( (pfun sl$REQ sl$Node) )
             (set (pfun sl$REQ sl$Node)))
(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close
             ( (pfun sl$REQ sl$OBJ) )
             (set (pfun sl$REQ sl$OBJ)))
(declare-fun ovl@@Int@@sl$Node
             ( (pfun Int sl$Node)
               (pfun Int sl$Node) )
             (pfun Int sl$Node))
(declare-fun ovl@@Int@@sl$OBJ
             ( (pfun Int sl$OBJ)
               (pfun Int sl$OBJ) )
             (pfun Int sl$OBJ))
(declare-fun ovl@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node)
               (pfun sl$Node sl$Node) )
             (pfun sl$Node sl$Node))
(declare-fun ovl@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ)
               (pfun sl$Node sl$OBJ) )
             (pfun sl$Node sl$OBJ))
(declare-fun ovl@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node)
               (pfun sl$REQ sl$Node) )
             (pfun sl$REQ sl$Node))
(declare-fun ovl@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ)
               (pfun sl$REQ sl$OBJ) )
             (pfun sl$REQ sl$OBJ))
(declare-fun pfun@@Int@@sl$Node
             ( (set Int)
               (set sl$Node) )
             (set (pfun Int sl$Node)))
(declare-fun pfun@@Int@@sl$OBJ
             ( (set Int)
               (set sl$OBJ) )
             (set (pfun Int sl$OBJ)))
(declare-fun pfun@@sl$Node@@sl$Node
             ( (set sl$Node)
               (set sl$Node) )
             (set (pfun sl$Node sl$Node)))
(declare-fun pfun@@sl$Node@@sl$OBJ
             ( (set sl$Node)
               (set sl$OBJ) )
             (set (pfun sl$Node sl$OBJ)))
(declare-fun pfun@@sl$REQ@@sl$Node
             ( (set sl$REQ)
               (set sl$Node) )
             (set (pfun sl$REQ sl$Node)))
(declare-fun pfun@@sl$REQ@@sl$OBJ
             ( (set sl$REQ)
               (set sl$OBJ) )
             (set (pfun sl$REQ sl$OBJ)))
(declare-fun ran@@Int@@sl$Node
             ( (pfun Int sl$Node) )
             (set sl$Node))
(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))
(declare-fun ran@@sl$Node@@sl$Node
             ( (pfun sl$Node sl$Node) )
             (set sl$Node))
(declare-fun ran@@sl$Node@@sl$OBJ
             ( (pfun sl$Node sl$OBJ) )
             (set sl$OBJ))
(declare-fun ran@@sl$REQ@@sl$Node
             ( (pfun sl$REQ sl$Node) )
             (set sl$Node))
(declare-fun ran@@sl$REQ@@sl$OBJ
             ( (pfun sl$REQ sl$OBJ) )
             (set sl$OBJ))
(declare-fun tfun@@Int@@sl$Node
             ( (set Int)
               (set sl$Node) )
             (set (pfun Int sl$Node)))
(declare-fun tfun@@Int@@sl$OBJ
             ( (set Int)
               (set sl$OBJ) )
             (set (pfun Int sl$OBJ)))
(declare-fun tfun@@sl$Node@@sl$Node
             ( (set sl$Node)
               (set sl$Node) )
             (set (pfun sl$Node sl$Node)))
(declare-fun tfun@@sl$Node@@sl$OBJ
             ( (set sl$Node)
               (set sl$OBJ) )
             (set (pfun sl$Node sl$OBJ)))
(declare-fun tfun@@sl$REQ@@sl$Node
             ( (set sl$REQ)
               (set sl$Node) )
             (set (pfun sl$REQ sl$Node)))
(declare-fun tfun@@sl$REQ@@sl$OBJ
             ( (set sl$REQ)
               (set sl$OBJ) )
             (set (pfun sl$REQ sl$OBJ)))
(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))
(define-fun all@@sl$Node
            ()
            (set sl$Node)
            ( (as const (set sl$Node))
              true ))
(define-fun all@@sl$OBJ
            ()
            (set sl$OBJ)
            ( (as const (set sl$OBJ))
              true ))
(define-fun all@@sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              true ))
(define-fun all@Open@@pfun@@Int@@sl$Node@Close
            ()
            (set (pfun Int sl$Node))
            ( (as const (set (pfun Int sl$Node)))
              true ))
(define-fun all@Open@@pfun@@Int@@sl$OBJ@Close
            ()
            (set (pfun Int sl$OBJ))
            ( (as const (set (pfun Int sl$OBJ)))
              true ))
(define-fun all@Open@@pfun@@sl$Node@@sl$Node@Close
            ()
            (set (pfun sl$Node sl$Node))
            ( (as const (set (pfun sl$Node sl$Node)))
              true ))
(define-fun all@Open@@pfun@@sl$Node@@sl$OBJ@Close
            ()
            (set (pfun sl$Node sl$OBJ))
            ( (as const (set (pfun sl$Node sl$OBJ)))
              true ))
(define-fun all@Open@@pfun@@sl$REQ@@sl$Node@Close
            ()
            (set (pfun sl$REQ sl$Node))
            ( (as const (set (pfun sl$REQ sl$Node)))
              true ))
(define-fun all@Open@@pfun@@sl$REQ@@sl$OBJ@Close
            ()
            (set (pfun sl$REQ sl$OBJ))
            ( (as const (set (pfun sl$REQ sl$OBJ)))
              true ))
(define-fun compl@@Int
            ( (s1 (set Int)) )
            (set Int)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$Node
            ( (s1 (set sl$Node)) )
            (set sl$Node)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$OBJ
            ( (s1 (set sl$OBJ)) )
            (set sl$OBJ)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$REQ
            ( (s1 (set sl$REQ)) )
            (set sl$REQ)
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@Int@@sl$Node@Close
            ( (s1 (set (pfun Int sl$Node))) )
            (set (pfun Int sl$Node))
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@Int@@sl$OBJ@Close
            ( (s1 (set (pfun Int sl$OBJ))) )
            (set (pfun Int sl$OBJ))
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@sl$Node@@sl$Node@Close
            ( (s1 (set (pfun sl$Node sl$Node))) )
            (set (pfun sl$Node sl$Node))
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@sl$Node@@sl$OBJ@Close
            ( (s1 (set (pfun sl$Node sl$OBJ))) )
            (set (pfun sl$Node sl$OBJ))
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@sl$REQ@@sl$Node@Close
            ( (s1 (set (pfun sl$REQ sl$Node))) )
            (set (pfun sl$REQ sl$Node))
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@pfun@@sl$REQ@@sl$OBJ@Close
            ( (s1 (set (pfun sl$REQ sl$OBJ))) )
            (set (pfun sl$REQ sl$OBJ))
            ( (_ map not)
              s1 ))
(define-fun elem@@Int
            ( (x Int)
              (s1 (set Int)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$Node
            ( (x sl$Node)
              (s1 (set sl$Node)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$OBJ
            ( (x sl$OBJ)
              (s1 (set sl$OBJ)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$REQ
            ( (x sl$REQ)
              (s1 (set sl$REQ)) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@Int@@sl$Node@Close
            ( (x (pfun Int sl$Node))
              (s1 (set (pfun Int sl$Node))) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@Int@@sl$OBJ@Close
            ( (x (pfun Int sl$OBJ))
              (s1 (set (pfun Int sl$OBJ))) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@sl$Node@@sl$Node@Close
            ( (x (pfun sl$Node sl$Node))
              (s1 (set (pfun sl$Node sl$Node))) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@sl$Node@@sl$OBJ@Close
            ( (x (pfun sl$Node sl$OBJ))
              (s1 (set (pfun sl$Node sl$OBJ))) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@sl$REQ@@sl$Node@Close
            ( (x (pfun sl$REQ sl$Node))
              (s1 (set (pfun sl$REQ sl$Node))) )
            Bool
            (select s1 x))
(define-fun elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close
            ( (x (pfun sl$REQ sl$OBJ))
              (s1 (set (pfun sl$REQ sl$OBJ))) )
            Bool
            (select s1 x))
(define-fun empty-set@@Int
            ()
            (set Int)
            ( (as const (set Int))
              false ))
(define-fun empty-set@@sl$Node
            ()
            (set sl$Node)
            ( (as const (set sl$Node))
              false ))
(define-fun empty-set@@sl$OBJ
            ()
            (set sl$OBJ)
            ( (as const (set sl$OBJ))
              false ))
(define-fun empty-set@@sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              false ))
(define-fun empty-set@Open@@pfun@@Int@@sl$Node@Close
            ()
            (set (pfun Int sl$Node))
            ( (as const (set (pfun Int sl$Node)))
              false ))
(define-fun empty-set@Open@@pfun@@Int@@sl$OBJ@Close
            ()
            (set (pfun Int sl$OBJ))
            ( (as const (set (pfun Int sl$OBJ)))
              false ))
(define-fun empty-set@Open@@pfun@@sl$Node@@sl$Node@Close
            ()
            (set (pfun sl$Node sl$Node))
            ( (as const (set (pfun sl$Node sl$Node)))
              false ))
(define-fun empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close
            ()
            (set (pfun sl$Node sl$OBJ))
            ( (as const (set (pfun sl$Node sl$OBJ)))
              false ))
(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close
            ()
            (set (pfun sl$REQ sl$Node))
            ( (as const (set (pfun sl$REQ sl$Node)))
              false ))
(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close
            ()
            (set (pfun sl$REQ sl$OBJ))
            ( (as const (set (pfun sl$REQ sl$OBJ)))
              false ))
(define-fun set-diff@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            (set Int)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$Node
            ( (s1 (set sl$Node))
              (s2 (set sl$Node)) )
            (set sl$Node)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$OBJ
            ( (s1 (set sl$OBJ))
              (s2 (set sl$OBJ)) )
            (set sl$OBJ)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$REQ
            ( (s1 (set sl$REQ))
              (s2 (set sl$REQ)) )
            (set sl$REQ)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@Int@@sl$Node@Close
            ( (s1 (set (pfun Int sl$Node)))
              (s2 (set (pfun Int sl$Node))) )
            (set (pfun Int sl$Node))
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@Int@@sl$OBJ@Close
            ( (s1 (set (pfun Int sl$OBJ)))
              (s2 (set (pfun Int sl$OBJ))) )
            (set (pfun Int sl$OBJ))
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@sl$Node@@sl$Node@Close
            ( (s1 (set (pfun sl$Node sl$Node)))
              (s2 (set (pfun sl$Node sl$Node))) )
            (set (pfun sl$Node sl$Node))
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close
            ( (s1 (set (pfun sl$Node sl$OBJ)))
              (s2 (set (pfun sl$Node sl$OBJ))) )
            (set (pfun sl$Node sl$OBJ))
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close
            ( (s1 (set (pfun sl$REQ sl$Node)))
              (s2 (set (pfun sl$REQ sl$Node))) )
            (set (pfun sl$REQ sl$Node))
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close
            ( (s1 (set (pfun sl$REQ sl$OBJ)))
              (s2 (set (pfun sl$REQ sl$OBJ))) )
            (set (pfun sl$REQ sl$OBJ))
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$Node
            ( (s1 (set sl$Node))
              (s2 (set sl$Node)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$OBJ
            ( (s1 (set sl$OBJ))
              (s2 (set sl$OBJ)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$REQ
            ( (s1 (set sl$REQ))
              (s2 (set sl$REQ)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@Int@@sl$Node@Close
            ( (s1 (set (pfun Int sl$Node)))
              (s2 (set (pfun Int sl$Node))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@Int@@sl$OBJ@Close
            ( (s1 (set (pfun Int sl$OBJ)))
              (s2 (set (pfun Int sl$OBJ))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@sl$Node@@sl$Node@Close
            ( (s1 (set (pfun sl$Node sl$Node)))
              (s2 (set (pfun sl$Node sl$Node))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@sl$Node@@sl$OBJ@Close
            ( (s1 (set (pfun sl$Node sl$OBJ)))
              (s2 (set (pfun sl$Node sl$OBJ))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$Node@Close
            ( (s1 (set (pfun sl$REQ sl$Node)))
              (s2 (set (pfun sl$REQ sl$Node))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$OBJ@Close
            ( (s1 (set (pfun sl$REQ sl$OBJ)))
              (s2 (set (pfun sl$REQ sl$OBJ))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Node
            ()
            (set sl$Node)
            ( (as const (set sl$Node))
              true ))
(define-fun sl$OBJ
            ()
            (set sl$OBJ)
            ( (as const (set sl$OBJ))
              true ))
(define-fun sl$REQ
            ()
            (set sl$REQ)
            ( (as const (set sl$REQ))
              true ))
(assert (forall ( (r (set Int)) )
                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))
                   :pattern
                   ( (<= 0 (card@@Int r)) ))))
(assert (forall ( (r (set (pfun Int sl$Node))) )
                (! (=> (finite@Open@@pfun@@Int@@sl$Node@Close r)
                       (<= 0 (card@Open@@pfun@@Int@@sl$Node@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@Int@@sl$Node@Close r)) ))))
(assert (forall ( (r (set (pfun Int sl$OBJ))) )
                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close r)
                       (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)) ))))
(assert (forall ( (r (set (pfun sl$Node sl$Node))) )
                (! (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close r)
                       (<= 0 (card@Open@@pfun@@sl$Node@@sl$Node@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@sl$Node@@sl$Node@Close r)) ))))
(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )
                (! (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close r)
                       (<= 0 (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )
                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close r)
                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )
                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)
                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)))
                   :pattern
                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)) ))))
(assert (forall ( (r (set sl$Node)) )
                (! (=> (finite@@sl$Node r) (<= 0 (card@@sl$Node r)))
                   :pattern
                   ( (<= 0 (card@@sl$Node r)) ))))
(assert (forall ( (r (set sl$OBJ)) )
                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))
                   :pattern
                   ( (<= 0 (card@@sl$OBJ r)) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))
                   :pattern
                   ( (<= 0 (card@@sl$REQ r)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set (pfun Int sl$Node))) )
                (! (= (= (card@Open@@pfun@@Int@@sl$Node@Close r) 0)
                      (= r empty-set@Open@@pfun@@Int@@sl$Node@Close))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$Node@Close r) ))))
(assert (forall ( (r (set (pfun Int sl$OBJ))) )
                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 0)
                      (= r empty-set@Open@@pfun@@Int@@sl$OBJ@Close))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))
(assert (forall ( (r (set (pfun sl$Node sl$Node))) )
                (! (= (= (card@Open@@pfun@@sl$Node@@sl$Node@Close r) 0)
                      (= r empty-set@Open@@pfun@@sl$Node@@sl$Node@Close))
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close r) ))))
(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )
                (! (= (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) 0)
                      (= r empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close))
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )
                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) 0)
                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close))
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )
                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 0)
                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))
(assert (forall ( (r (set sl$Node)) )
                (! (= (= (card@@sl$Node r) 0) (= r empty-set@@sl$Node))
                   :pattern
                   ( (card@@sl$Node r) ))))
(assert (forall ( (r (set sl$OBJ)) )
                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))
                   :pattern
                   ( (card@@sl$OBJ r) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))
                   :pattern
                   ( (card@@sl$REQ r) ))))
(assert (forall ( (x Int) )
                (! (= (card@@Int (mk-set@@Int x)) 1)
                   :pattern
                   ( (card@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x (pfun Int sl$Node)) )
                (! (= (card@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x)) ))))
(assert (forall ( (x (pfun Int sl$OBJ)) )
                (! (= (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))
(assert (forall ( (x (pfun sl$Node sl$Node)) )
                (! (= (card@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)) ))))
(assert (forall ( (x (pfun sl$Node sl$OBJ)) )
                (! (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)) ))))
(assert (forall ( (x (pfun sl$REQ sl$Node)) )
                (! (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)) ))))
(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )
                (! (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))
                      1)
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))
(assert (forall ( (x sl$Node) )
                (! (= (card@@sl$Node (mk-set@@sl$Node x)) 1)
                   :pattern
                   ( (card@@sl$Node (mk-set@@sl$Node x)) ))))
(assert (forall ( (x sl$OBJ) )
                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)
                   :pattern
                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))
(assert (forall ( (x sl$REQ) )
                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)
                   :pattern
                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 1)
                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set (pfun Int sl$Node))) )
                (! (= (= (card@Open@@pfun@@Int@@sl$Node@Close r) 1)
                      (exists ( (x (pfun Int sl$Node)) )
                              (and true
                                   (= r (mk-set@Open@@pfun@@Int@@sl$Node@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$Node@Close r) ))))
(assert (forall ( (r (set (pfun Int sl$OBJ))) )
                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 1)
                      (exists ( (x (pfun Int sl$OBJ)) )
                              (and true
                                   (= r (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))
(assert (forall ( (r (set (pfun sl$Node sl$Node))) )
                (! (= (= (card@Open@@pfun@@sl$Node@@sl$Node@Close r) 1)
                      (exists ( (x (pfun sl$Node sl$Node)) )
                              (and true
                                   (= r (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close r) ))))
(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )
                (! (= (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) 1)
                      (exists ( (x (pfun sl$Node sl$OBJ)) )
                              (and true
                                   (= r (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )
                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) 1)
                      (exists ( (x (pfun sl$REQ sl$Node)) )
                              (and true
                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )
                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 1)
                      (exists ( (x (pfun sl$REQ sl$OBJ)) )
                              (and true
                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)))))
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))
(assert (forall ( (r (set sl$Node)) )
                (! (= (= (card@@sl$Node r) 1)
                      (exists ( (x sl$Node) )
                              (and true (= r (mk-set@@sl$Node x)))))
                   :pattern
                   ( (card@@sl$Node r) ))))
(assert (forall ( (r (set sl$OBJ)) )
                (! (= (= (card@@sl$OBJ r) 1)
                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))
                   :pattern
                   ( (card@@sl$OBJ r) ))))
(assert (forall ( (r (set sl$REQ)) )
                (! (= (= (card@@sl$REQ r) 1)
                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))
                   :pattern
                   ( (card@@sl$REQ r) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int)) )
                (! (=> (= (intersect r r0) empty-set@@Int)
                       (= (card@@Int (union r r0))
                          (+ (card@@Int r) (card@@Int r0))))
                   :pattern
                   ( (card@@Int (union r r0)) ))))
(assert (forall ( (r (set (pfun Int sl$Node)))
                  (r0 (set (pfun Int sl$Node))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@Int@@sl$Node@Close)
                       (= (card@Open@@pfun@@Int@@sl$Node@Close (union r r0))
                          (+ (card@Open@@pfun@@Int@@sl$Node@Close r)
                             (card@Open@@pfun@@Int@@sl$Node@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$Node@Close (union r r0)) ))))
(assert (forall ( (r (set (pfun Int sl$OBJ)))
                  (r0 (set (pfun Int sl$OBJ))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@Int@@sl$OBJ@Close)
                       (= (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0))
                          (+ (card@Open@@pfun@@Int@@sl$OBJ@Close r)
                             (card@Open@@pfun@@Int@@sl$OBJ@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0)) ))))
(assert (forall ( (r (set (pfun sl$Node sl$Node)))
                  (r0 (set (pfun sl$Node sl$Node))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@sl$Node@@sl$Node@Close)
                       (= (card@Open@@pfun@@sl$Node@@sl$Node@Close (union r r0))
                          (+ (card@Open@@pfun@@sl$Node@@sl$Node@Close r)
                             (card@Open@@pfun@@sl$Node@@sl$Node@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close (union r r0)) ))))
(assert (forall ( (r (set (pfun sl$Node sl$OBJ)))
                  (r0 (set (pfun sl$Node sl$OBJ))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close)
                       (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (union r r0))
                          (+ (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)
                             (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (union r r0)) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$Node)))
                  (r0 (set (pfun sl$REQ sl$Node))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close)
                       (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close (union r r0))
                          (+ (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)
                             (card@Open@@pfun@@sl$REQ@@sl$Node@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close (union r r0)) ))))
(assert (forall ( (r (set (pfun sl$REQ sl$OBJ)))
                  (r0 (set (pfun sl$REQ sl$OBJ))) )
                (! (=> (= (intersect r r0)
                          empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close)
                       (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0))
                          (+ (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)
                             (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r0))))
                   :pattern
                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0)) ))))
(assert (forall ( (r (set sl$Node))
                  (r0 (set sl$Node)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Node)
                       (= (card@@sl$Node (union r r0))
                          (+ (card@@sl$Node r) (card@@sl$Node r0))))
                   :pattern
                   ( (card@@sl$Node (union r r0)) ))))
(assert (forall ( (r (set sl$OBJ))
                  (r0 (set sl$OBJ)) )
                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)
                       (= (card@@sl$OBJ (union r r0))
                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))
                   :pattern
                   ( (card@@sl$OBJ (union r r0)) ))))
(assert (forall ( (r (set sl$REQ))
                  (r0 (set sl$REQ)) )
                (! (=> (= (intersect r r0) empty-set@@sl$REQ)
                       (= (card@@sl$REQ (union r r0))
                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))
                   :pattern
                   ( (card@@sl$REQ (union r r0)) ))))
(assert (= (dom@@Int@@sl$Node empty-fun@@Int@@sl$Node)
           empty-set@@Int))
(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)
           empty-set@@Int))
(assert (= (dom@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)
           empty-set@@sl$Node))
(assert (= (dom@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)
           empty-set@@sl$Node))
(assert (= (dom@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)
           empty-set@@sl$REQ))
(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)
           empty-set@@sl$REQ))
(assert (forall ( (f1 (pfun Int sl$Node)) )
                (! (= (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) f1)
                   :pattern
                   ( (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ)) )
                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)
                   :pattern
                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node)) )
                (! (= (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )
                (! (= (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )
                (! (= (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )
                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))
(assert (forall ( (f1 (pfun Int sl$Node)) )
                (! (= (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) f1)
                   :pattern
                   ( (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ)) )
                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)
                   :pattern
                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node)) )
                (! (= (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )
                (! (= (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )
                (! (= (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )
                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))
(assert (forall ( (x Int)
                  (y sl$Node) )
                (! (= (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))
                      (mk-set@@Int x))
                   :pattern
                   ( (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))
(assert (forall ( (x Int)
                  (y sl$OBJ) )
                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))
                      (mk-set@@Int x))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))
                      (mk-set@@sl$Node x))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$OBJ) )
                (! (= (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))
                      (mk-set@@sl$Node x))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$Node) )
                (! (= (dom@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y))
                      (mk-set@@sl$REQ x))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y)) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))
                      (mk-set@@sl$REQ x))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (f2 (pfun Int sl$Node))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$Node f2))
                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)
                          (apply@@Int@@sl$Node f2 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (f2 (pfun Int sl$OBJ))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))
                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)
                          (apply@@Int@@sl$OBJ f2 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (f2 (pfun sl$Node sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))
                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)
                          (apply@@sl$Node@@sl$Node f2 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (f2 (pfun sl$Node sl$OBJ))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))
                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)
                          (apply@@sl$Node@@sl$OBJ f2 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (f2 (pfun sl$REQ sl$Node))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f2))
                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x)
                          (apply@@sl$REQ@@sl$Node f2 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (f2 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))
                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)
                          (apply@@sl$REQ@@sl$OBJ f2 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (f2 (pfun Int sl$Node))
                  (x Int) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))
                            (not (elem@@Int x (dom@@Int@@sl$Node f2))))
                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)
                          (apply@@Int@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (f2 (pfun Int sl$OBJ))
                  (x Int) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))
                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)
                          (apply@@Int@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (f2 (pfun sl$Node sl$Node))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))))
                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)
                          (apply@@sl$Node@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (f2 (pfun sl$Node sl$OBJ))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))))
                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)
                          (apply@@sl$Node@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (f2 (pfun sl$REQ sl$Node))
                  (x sl$REQ) )
                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f2))))
                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x)
                          (apply@@sl$REQ@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (f2 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ) )
                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))))
                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)
                          (apply@@sl$REQ@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))
(assert (forall ( (x Int)
                  (y sl$Node) )
                (! (= (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x) ))))
(assert (forall ( (x Int)
                  (y sl$OBJ) )
                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x) ))))
(assert (forall ( (x sl$Node)
                  (y sl$OBJ) )
                (! (= (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$Node) )
                (! (= (apply@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y) x) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (and (elem@@Int x s1)
                            (elem@@Int x (dom@@Int@@sl$Node f1)))
                       (= (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x)
                          (apply@@Int@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (and (elem@@Int x s1)
                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))
                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)
                          (apply@@Int@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x s1)
                            (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))
                       (= (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x)
                          (apply@@sl$Node@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (and (elem@@sl$Node x s1)
                            (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))
                       (= (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x)
                          (apply@@sl$Node@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (and (elem@@sl$REQ x s1)
                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1)))
                       (= (apply@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1) x)
                          (apply@@sl$REQ@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (and (elem@@sl$REQ x s1)
                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))
                       (= (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x)
                          (apply@@sl$REQ@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))
                       (= (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x)
                          (apply@@Int@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))
                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)
                          (apply@@Int@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))
                       (= (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x)
                          (apply@@sl$Node@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))
                       (= (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x)
                          (apply@@sl$Node@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))
                       (= (apply@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1) x)
                          (apply@@sl$REQ@@sl$Node f1 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))
                       (= (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x)
                          (apply@@sl$REQ@@sl$OBJ f1 x)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x) ))))
(assert (forall ( (s2 (set sl$Node)) )
                (! (elem@Open@@pfun@@Int@@sl$Node@Close empty-fun@@Int@@sl$Node
                                                        (tfun@@Int@@sl$Node empty-set@@Int s2))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$Node@Close empty-fun@@Int@@sl$Node
                                                          (tfun@@Int@@sl$Node empty-set@@Int s2)) ))))
(assert (forall ( (s2 (set sl$OBJ)) )
                (! (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ
                                                       (tfun@@Int@@sl$OBJ empty-set@@Int s2))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ
                                                         (tfun@@Int@@sl$OBJ empty-set@@Int s2)) ))))
(assert (forall ( (s2 (set sl$Node)) )
                (! (elem@Open@@pfun@@sl$Node@@sl$Node@Close empty-fun@@sl$Node@@sl$Node
                                                            (tfun@@sl$Node@@sl$Node empty-set@@sl$Node s2))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close empty-fun@@sl$Node@@sl$Node
                                                              (tfun@@sl$Node@@sl$Node empty-set@@sl$Node s2)) ))))
(assert (forall ( (s2 (set sl$OBJ)) )
                (! (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-fun@@sl$Node@@sl$OBJ
                                                           (tfun@@sl$Node@@sl$OBJ empty-set@@sl$Node s2))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-fun@@sl$Node@@sl$OBJ
                                                             (tfun@@sl$Node@@sl$OBJ empty-set@@sl$Node s2)) ))))
(assert (forall ( (s2 (set sl$Node)) )
                (! (elem@Open@@pfun@@sl$REQ@@sl$Node@Close empty-fun@@sl$REQ@@sl$Node
                                                           (tfun@@sl$REQ@@sl$Node empty-set@@sl$REQ s2))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close empty-fun@@sl$REQ@@sl$Node
                                                             (tfun@@sl$REQ@@sl$Node empty-set@@sl$REQ s2)) ))))
(assert (forall ( (s2 (set sl$OBJ)) )
                (! (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ
                                                          (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ
                                                            (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (f2 (pfun Int sl$Node)) )
                (! (= (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2))
                      (union (dom@@Int@@sl$Node f1) (dom@@Int@@sl$Node f2)))
                   :pattern
                   ( (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (f2 (pfun Int sl$OBJ)) )
                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))
                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (f2 (pfun sl$Node sl$Node)) )
                (! (= (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2))
                      (union (dom@@sl$Node@@sl$Node f1)
                             (dom@@sl$Node@@sl$Node f2)))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (f2 (pfun sl$Node sl$OBJ)) )
                (! (= (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2))
                      (union (dom@@sl$Node@@sl$OBJ f1)
                             (dom@@sl$Node@@sl$OBJ f2)))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (f2 (pfun sl$REQ sl$Node)) )
                (! (= (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2))
                      (union (dom@@sl$REQ@@sl$Node f1)
                             (dom@@sl$REQ@@sl$Node f2)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (f2 (pfun sl$REQ sl$OBJ)) )
                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))
                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))
                      (intersect s1 (dom@@Int@@sl$Node f1)))
                   :pattern
                   ( (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))
                      (intersect s1 (dom@@Int@@sl$OBJ f1)))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))
                      (intersect s1 (dom@@sl$Node@@sl$Node f1)))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))
                      (intersect s1 (dom@@sl$Node@@sl$OBJ f1)))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))
                      (intersect s1 (dom@@sl$REQ@@sl$Node f1)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))
                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))
                      (set-diff@@Int (dom@@Int@@sl$Node f1) s1))
                   :pattern
                   ( (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))
                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))
                   :pattern
                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))
                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))
                   :pattern
                   ( (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node)) )
                (! (= (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))
                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))
                   :pattern
                   ( (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))
                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))
                   :pattern
                   ( (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ)) )
                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))
                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))
                   :pattern
                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))
                           (= (apply@@Int@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$Node f1))
                     (apply@@Int@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                           (= (apply@@Int@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))
                     (apply@@Int@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                           (= (apply@@sl$Node@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                     (apply@@sl$Node@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                     (apply@@sl$Node@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                           (= (apply@@sl$REQ@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                     (apply@@sl$REQ@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                           (= (apply@@sl$REQ@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                     (apply@@sl$REQ@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                           (= (apply@@sl$REQ@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                     (apply@@sl$REQ@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                           (= (apply@@sl$REQ@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                     (apply@@sl$REQ@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                           (= (apply@@sl$REQ@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                     (apply@@sl$REQ@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                           (= (apply@@sl$REQ@@sl$Node f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                     (apply@@sl$REQ@@sl$Node f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                     (apply@@sl$REQ@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                     (apply@@sl$REQ@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                     (apply@@sl$REQ@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                     (apply@@sl$REQ@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                     (apply@@sl$REQ@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                     (apply@@sl$REQ@@sl$OBJ f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (x2 Int)
                  (y sl$Node) )
                (! (=> (not (= x x2))
                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                               x2)
                          (apply@@Int@@sl$Node f1 x2)))
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                          x2) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (x2 Int)
                  (y sl$OBJ) )
                (! (=> (not (= x x2))
                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))
                                              x2)
                          (apply@@Int@@sl$OBJ f1 x2)))
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))
                                         x2) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (x2 sl$Node)
                  (y sl$Node) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                                   x2)
                          (apply@@sl$Node@@sl$Node f1 x2)))
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                              x2) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (x2 sl$Node)
                  (y sl$OBJ) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                                  x2)
                          (apply@@sl$Node@@sl$OBJ f1 x2)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                             x2) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (x2 sl$REQ)
                  (y sl$Node) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))
                                                  x2)
                          (apply@@sl$REQ@@sl$Node f1 x2)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))
                                             x2) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (x2 sl$REQ)
                  (y sl$OBJ) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))
                                                 x2)
                          (apply@@sl$REQ@@sl$OBJ f1 x2)))
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))
                                            x2) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                           x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))
                                          x) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)
                      y)
                   :pattern
                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                               x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))
                                              x) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                              x)
                      y)
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))
                                             x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))
                                              x)
                      y)
                   :pattern
                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))
                                             x) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))
                                             x)
                      y)
                   :pattern
                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))
                                            x) ))))
(assert (= (ran@@Int@@sl$Node empty-fun@@Int@@sl$Node)
           empty-set@@sl$Node))
(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)
           empty-set@@sl$OBJ))
(assert (= (ran@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)
           empty-set@@sl$Node))
(assert (= (ran@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)
           empty-set@@sl$OBJ))
(assert (= (ran@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)
           empty-set@@sl$Node))
(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)
           empty-set@@sl$OBJ))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (y sl$Node) )
                (! (= (elem@@sl$Node y (ran@@Int@@sl$Node f1))
                      (exists ( (x Int) )
                              (and true
                                   (and (elem@@Int x (dom@@Int@@sl$Node f1))
                                        (= (apply@@Int@@sl$Node f1 x) y)))))
                   :pattern
                   ( (elem@@sl$Node y (ran@@Int@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))
                      (exists ( (x Int) )
                              (and true
                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))
                   :pattern
                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (y sl$Node) )
                (! (= (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1))
                      (exists ( (x sl$Node) )
                              (and true
                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                                        (= (apply@@sl$Node@@sl$Node f1 x) y)))))
                   :pattern
                   ( (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1))
                      (exists ( (x sl$Node) )
                              (and true
                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                                        (= (apply@@sl$Node@@sl$OBJ f1 x) y)))))
                   :pattern
                   ( (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (y sl$Node) )
                (! (= (elem@@sl$Node y (ran@@sl$REQ@@sl$Node f1))
                      (exists ( (x sl$REQ) )
                              (and true
                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                                        (= (apply@@sl$REQ@@sl$Node f1 x) y)))))
                   :pattern
                   ( (elem@@sl$Node y (ran@@sl$REQ@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1))
                      (exists ( (x sl$REQ) )
                              (and true
                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                                        (= (apply@@sl$REQ@@sl$OBJ f1 x) y)))))
                   :pattern
                   ( (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1)) ))))
(assert (forall ( (x Int)
                  (y sl$Node) )
                (! (= (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))
                      (mk-set@@sl$Node y))
                   :pattern
                   ( (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))
(assert (forall ( (x Int)
                  (y sl$OBJ) )
                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))
                      (mk-set@@sl$OBJ y))
                   :pattern
                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))
                      (mk-set@@sl$Node y))
                   :pattern
                   ( (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$OBJ) )
                (! (= (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))
                      (mk-set@@sl$OBJ y))
                   :pattern
                   ( (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$Node) )
                (! (= (ran@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y))
                      (mk-set@@sl$Node y))
                   :pattern
                   ( (ran@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y)) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$OBJ) )
                (! (= (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))
                      (mk-set@@sl$OBJ y))
                   :pattern
                   ( (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (s2 (set sl$Node)) )
                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close f1 (tfun@@Int@@sl$Node s1 s2))
                      (and (= s1 (dom@@Int@@sl$Node f1))
                           (subset (ran@@Int@@sl$Node f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$Node@Close f1 (tfun@@Int@@sl$Node s1 s2)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (s2 (set sl$OBJ)) )
                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2))
                      (and (= s1 (dom@@Int@@sl$OBJ f1))
                           (subset (ran@@Int@@sl$OBJ f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (tfun@@sl$Node@@sl$Node s1 s2))
                      (and (= s1 (dom@@sl$Node@@sl$Node f1))
                           (subset (ran@@sl$Node@@sl$Node f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (tfun@@sl$Node@@sl$Node s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (s2 (set sl$OBJ)) )
                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (tfun@@sl$Node@@sl$OBJ s1 s2))
                      (and (= s1 (dom@@sl$Node@@sl$OBJ f1))
                           (subset (ran@@sl$Node@@sl$OBJ f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (tfun@@sl$Node@@sl$OBJ s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ))
                  (s2 (set sl$Node)) )
                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (tfun@@sl$REQ@@sl$Node s1 s2))
                      (and (= s1 (dom@@sl$REQ@@sl$Node f1))
                           (subset (ran@@sl$REQ@@sl$Node f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (tfun@@sl$REQ@@sl$Node s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ))
                  (s2 (set sl$OBJ)) )
                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2))
                      (and (= s1 (dom@@sl$REQ@@sl$OBJ f1))
                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (s2 (set sl$Node)) )
                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close f1 (pfun@@Int@@sl$Node s1 s2))
                      (and (subset (dom@@Int@@sl$Node f1) s1)
                           (subset (ran@@Int@@sl$Node f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$Node@Close f1 (pfun@@Int@@sl$Node s1 s2)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (s2 (set sl$OBJ)) )
                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2))
                      (and (subset (dom@@Int@@sl$OBJ f1) s1)
                           (subset (ran@@Int@@sl$OBJ f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (pfun@@sl$Node@@sl$Node s1 s2))
                      (and (subset (dom@@sl$Node@@sl$Node f1) s1)
                           (subset (ran@@sl$Node@@sl$Node f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (pfun@@sl$Node@@sl$Node s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (s2 (set sl$OBJ)) )
                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (pfun@@sl$Node@@sl$OBJ s1 s2))
                      (and (subset (dom@@sl$Node@@sl$OBJ f1) s1)
                           (subset (ran@@sl$Node@@sl$OBJ f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (pfun@@sl$Node@@sl$OBJ s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ))
                  (s2 (set sl$Node)) )
                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (pfun@@sl$REQ@@sl$Node s1 s2))
                      (and (subset (dom@@sl$REQ@@sl$Node f1) s1)
                           (subset (ran@@sl$REQ@@sl$Node f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (pfun@@sl$REQ@@sl$Node s1 s2)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ))
                  (s2 (set sl$OBJ)) )
                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2))
                      (and (subset (dom@@sl$REQ@@sl$OBJ f1) s1)
                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2)) ))))
(assert (forall ( (f1 (pfun Int sl$Node)) )
                (! (= (injective@@Int@@sl$Node f1)
                      (forall ( (x Int)
                                (x2 Int) )
                              (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))
                                       (elem@@Int x2 (dom@@Int@@sl$Node f1)))
                                  (=> (= (apply@@Int@@sl$Node f1 x)
                                         (apply@@Int@@sl$Node f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@Int@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ)) )
                (! (= (injective@@Int@@sl$OBJ f1)
                      (forall ( (x Int)
                                (x2 Int) )
                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))
                                  (=> (= (apply@@Int@@sl$OBJ f1 x)
                                         (apply@@Int@@sl$OBJ f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@Int@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node)) )
                (! (= (injective@@sl$Node@@sl$Node f1)
                      (forall ( (x sl$Node)
                                (x2 sl$Node) )
                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$Node f1)))
                                  (=> (= (apply@@sl$Node@@sl$Node f1 x)
                                         (apply@@sl$Node@@sl$Node f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$Node@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )
                (! (= (injective@@sl$Node@@sl$OBJ f1)
                      (forall ( (x sl$Node)
                                (x2 sl$Node) )
                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$OBJ f1)))
                                  (=> (= (apply@@sl$Node@@sl$OBJ f1 x)
                                         (apply@@sl$Node@@sl$OBJ f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$Node@@sl$OBJ f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )
                (! (= (injective@@sl$REQ@@sl$Node f1)
                      (forall ( (x sl$REQ)
                                (x2 sl$REQ) )
                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$Node f1)))
                                  (=> (= (apply@@sl$REQ@@sl$Node f1 x)
                                         (apply@@sl$REQ@@sl$Node f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$REQ@@sl$Node f1) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )
                (! (= (injective@@sl$REQ@@sl$OBJ f1)
                      (forall ( (x sl$REQ)
                                (x2 sl$REQ) )
                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$OBJ f1)))
                                  (=> (= (apply@@sl$REQ@@sl$OBJ f1 x)
                                         (apply@@sl$REQ@@sl$OBJ f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$REQ@@sl$OBJ f1) ))))
(assert (injective@@Int@@sl$Node empty-fun@@Int@@sl$Node))
(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))
(assert (injective@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node))
(assert (injective@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ))
(assert (injective@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node))
(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$Node f1))
                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)))
                   :pattern
                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))
                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                      (ran@@sl$Node@@sl$Node f1)))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                    (ran@@sl$Node@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                     (ran@@sl$Node@@sl$OBJ f1)))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                   (ran@@sl$Node@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)
                                      (ran@@sl$REQ@@sl$Node f1)))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)
                                    (ran@@sl$REQ@@sl$Node f1)) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)
                                     (ran@@sl$REQ@@sl$OBJ f1)))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)
                                   (ran@@sl$REQ@@sl$OBJ f1)) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                      (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                    (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                      (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                    (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x
                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                     (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                   (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)
                                      (ran@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)
                                    (ran@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)
                                     (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)
                                   (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                      (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)
                                    (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)
                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                      (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)
                                    (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (s1 (set sl$Node))
                  (x sl$Node) )
                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                     (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)
                                   (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$Node f1) s1))
                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)
                                      (ran@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))))
                   :pattern
                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)
                                    (ran@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (s1 (set sl$REQ))
                  (x sl$REQ) )
                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$OBJ f1) s1))
                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)
                                     (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))))
                   :pattern
                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)
                                   (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))
                            (injective@@Int@@sl$Node f1))
                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))
                          (union (set-diff@@sl$Node (ran@@Int@@sl$Node f1)
                                                    (mk-set@@sl$Node (apply@@Int@@sl$Node f1 x)))
                                 (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))
                            (injective@@Int@@sl$OBJ f1))
                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))
                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)
                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))
                                 (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))
                            (injective@@sl$Node@@sl$Node f1))
                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))
                          (union (set-diff@@sl$Node (ran@@sl$Node@@sl$Node f1)
                                                    (mk-set@@sl$Node (apply@@sl$Node@@sl$Node f1 x)))
                                 (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))
                            (injective@@sl$Node@@sl$OBJ f1))
                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))
                          (union (set-diff@@sl$OBJ (ran@@sl$Node@@sl$OBJ f1)
                                                   (mk-set@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)))
                                 (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))
                            (injective@@sl$REQ@@sl$Node f1))
                       (= (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y)))
                          (union (set-diff@@sl$Node (ran@@sl$REQ@@sl$Node f1)
                                                    (mk-set@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)))
                                 (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))
                            (injective@@sl$REQ@@sl$OBJ f1))
                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))
                          (union (set-diff@@sl$OBJ (ran@@sl$REQ@@sl$OBJ f1)
                                                   (mk-set@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)))
                                 (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun Int sl$Node))
                  (x Int)
                  (y sl$Node) )
                (! (=> (not (elem@@Int x (dom@@Int@@sl$Node f1)))
                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))
                          (union (ran@@Int@@sl$Node f1) (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun Int sl$OBJ))
                  (x Int)
                  (y sl$OBJ) )
                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))
                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))
                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$Node))
                  (x sl$Node)
                  (y sl$Node) )
                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))
                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))
                          (union (ran@@sl$Node@@sl$Node f1) (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun sl$Node sl$OBJ))
                  (x sl$Node)
                  (y sl$OBJ) )
                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))
                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))
                          (union (ran@@sl$Node@@sl$OBJ f1) (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$Node))
                  (x sl$REQ)
                  (y sl$Node) )
                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1)))
                       (= (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y)))
                          (union (ran@@sl$REQ@@sl$Node f1) (mk-set@@sl$Node y))))
                   :pattern
                   ( (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))) ))))
(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))
                  (x sl$REQ)
                  (y sl$OBJ) )
                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))
                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))
                          (union (ran@@sl$REQ@@sl$OBJ f1) (mk-set@@sl$OBJ y))))
                   :pattern
                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))
                   :pattern
                   ( (elem@@Int x (mk-set@@Int y)) ))))
(assert (forall ( (x (pfun Int sl$Node))
                  (y (pfun Int sl$Node)) )
                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close x (mk-set@Open@@pfun@@Int@@sl$Node@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$Node@Close x (mk-set@Open@@pfun@@Int@@sl$Node@Close y)) ))))
(assert (forall ( (x (pfun Int sl$OBJ))
                  (y (pfun Int sl$OBJ)) )
                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y)) ))))
(assert (forall ( (x (pfun sl$Node sl$Node))
                  (y (pfun sl$Node sl$Node)) )
                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close x (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close x (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close y)) ))))
(assert (forall ( (x (pfun sl$Node sl$OBJ))
                  (y (pfun sl$Node sl$OBJ)) )
                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close y)) ))))
(assert (forall ( (x (pfun sl$REQ sl$Node))
                  (y (pfun sl$REQ sl$Node)) )
                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close y)) ))))
(assert (forall ( (x (pfun sl$REQ sl$OBJ))
                  (y (pfun sl$REQ sl$OBJ)) )
                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y))
                      (= x y))
                   :pattern
                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y)) ))))
(assert (forall ( (x sl$Node)
                  (y sl$Node) )
                (! (= (elem@@sl$Node x (mk-set@@sl$Node y)) (= x y))
                   :pattern
                   ( (elem@@sl$Node x (mk-set@@sl$Node y)) ))))
(assert (forall ( (x sl$OBJ)
                  (y sl$OBJ) )
                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))
                   :pattern
                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))
(assert (forall ( (x sl$REQ)
                  (y sl$REQ) )
                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))
                   :pattern
                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (finite@@Int s1)
                       (finite@@Int (set-diff@@Int s1 s2)))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$Node)))
                  (s2 (set (pfun Int sl$Node))) )
                (! (=> (finite@Open@@pfun@@Int@@sl$Node@Close s1)
                       (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$OBJ)))
                  (s2 (set (pfun Int sl$OBJ))) )
                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)
                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))
                  (s2 (set (pfun sl$Node sl$Node))) )
                (! (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)
                       (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))
                  (s2 (set (pfun sl$Node sl$OBJ))) )
                (! (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)
                       (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))
                  (s2 (set (pfun sl$REQ sl$Node))) )
                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)
                       (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))
                  (s2 (set (pfun sl$REQ sl$OBJ))) )
                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)
                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))
(assert (forall ( (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (=> (finite@@sl$Node s1)
                       (finite@@sl$Node (set-diff@@sl$Node s1 s2)))
                   :pattern
                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ))
                  (s2 (set sl$OBJ)) )
                (! (=> (finite@@sl$OBJ s1)
                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (finite@@sl$REQ s1)
                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))
                   :pattern
                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s1) (finite@@Int s2))
                       (finite@@Int (union s1 s2)))
                   :pattern
                   ( (finite@@Int (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$Node)))
                  (s2 (set (pfun Int sl$Node))) )
                (! (=> (and (finite@Open@@pfun@@Int@@sl$Node@Close s1)
                            (finite@Open@@pfun@@Int@@sl$Node@Close s2))
                       (finite@Open@@pfun@@Int@@sl$Node@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$OBJ)))
                  (s2 (set (pfun Int sl$OBJ))) )
                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)
                            (finite@Open@@pfun@@Int@@sl$OBJ@Close s2))
                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))
                  (s2 (set (pfun sl$Node sl$Node))) )
                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)
                            (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2))
                       (finite@Open@@pfun@@sl$Node@@sl$Node@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))
                  (s2 (set (pfun sl$Node sl$OBJ))) )
                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)
                            (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2))
                       (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))
                  (s2 (set (pfun sl$REQ sl$Node))) )
                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)
                            (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2))
                       (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))
                  (s2 (set (pfun sl$REQ sl$OBJ))) )
                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)
                            (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2))
                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (=> (and (finite@@sl$Node s1) (finite@@sl$Node s2))
                       (finite@@sl$Node (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Node (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ))
                  (s2 (set sl$OBJ)) )
                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))
                       (finite@@sl$OBJ (union s1 s2)))
                   :pattern
                   ( (finite@@sl$OBJ (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))
                       (finite@@sl$REQ (union s1 s2)))
                   :pattern
                   ( (finite@@sl$REQ (union s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))
                       (not (finite@@Int (set-diff@@Int s1 s2))))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$Node)))
                  (s2 (set (pfun Int sl$Node))) )
                (! (=> (and (finite@Open@@pfun@@Int@@sl$Node@Close s2)
                            (not (finite@Open@@pfun@@Int@@sl$Node@Close s1)))
                       (not (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun Int sl$OBJ)))
                  (s2 (set (pfun Int sl$OBJ))) )
                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s2)
                            (not (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)))
                       (not (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))
                  (s2 (set (pfun sl$Node sl$Node))) )
                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2)
                            (not (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)))
                       (not (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))
                  (s2 (set (pfun sl$Node sl$OBJ))) )
                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2)
                            (not (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)))
                       (not (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))
                  (s2 (set (pfun sl$REQ sl$Node))) )
                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2)
                            (not (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)))
                       (not (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)) ))))
(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))
                  (s2 (set (pfun sl$REQ sl$OBJ))) )
                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2)
                            (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)))
                       (not (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2))))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))
(assert (forall ( (s1 (set sl$Node))
                  (s2 (set sl$Node)) )
                (! (=> (and (finite@@sl$Node s2) (not (finite@@sl$Node s1)))
                       (not (finite@@sl$Node (set-diff@@sl$Node s1 s2))))
                   :pattern
                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))
(assert (forall ( (s1 (set sl$OBJ))
                  (s2 (set sl$OBJ)) )
                (! (=> (and (finite@@sl$OBJ s2) (not (finite@@sl$OBJ s1)))
                       (not (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2))))
                   :pattern
                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))
(assert (forall ( (s1 (set sl$REQ))
                  (s2 (set sl$REQ)) )
                (! (=> (and (finite@@sl$REQ s2) (not (finite@@sl$REQ s1)))
                       (not (finite@@sl$REQ (set-diff@@sl$REQ s1 s2))))
                   :pattern
                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))
(assert (forall ( (x Int) )
                (! (finite@@Int (mk-set@@Int x))
                   :pattern
                   ( (finite@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x (pfun Int sl$Node)) )
                (! (finite@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x)) ))))
(assert (forall ( (x (pfun Int sl$OBJ)) )
                (! (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))
(assert (forall ( (x (pfun sl$Node sl$Node)) )
                (! (finite@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)) ))))
(assert (forall ( (x (pfun sl$Node sl$OBJ)) )
                (! (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)) ))))
(assert (forall ( (x (pfun sl$REQ sl$Node)) )
                (! (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)) ))))
(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )
                (! (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))
                   :pattern
                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))
(assert (forall ( (x sl$Node) )
                (! (finite@@sl$Node (mk-set@@sl$Node x))
                   :pattern
                   ( (finite@@sl$Node (mk-set@@sl$Node x)) ))))
(assert (forall ( (x sl$OBJ) )
                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))
                   :pattern
                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))
(assert (forall ( (x sl$REQ) )
                (! (finite@@sl$REQ (mk-set@@sl$REQ x))
                   :pattern
                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))
(assert (finite@@Int empty-set@@Int))
(assert (finite@Open@@pfun@@Int@@sl$Node@Close empty-set@Open@@pfun@@Int@@sl$Node@Close))
(assert (finite@Open@@pfun@@Int@@sl$OBJ@Close empty-set@Open@@pfun@@Int@@sl$OBJ@Close))
(assert (finite@Open@@pfun@@sl$Node@@sl$Node@Close empty-set@Open@@pfun@@sl$Node@@sl$Node@Close))
(assert (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close))
(assert (finite@Open@@pfun@@sl$REQ@@sl$Node@Close empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close))
(assert (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))
(assert (finite@@sl$Node empty-set@@sl$Node))
(assert (finite@@sl$OBJ empty-set@@sl$OBJ))
(assert (finite@@sl$REQ empty-set@@sl$REQ))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (interval m n))
                      (and (<= m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (interval m n)) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalR m n))
                      (and (<= m x) (< x n)))
                   :pattern
                   ( (elem@@Int x (intervalR m n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (intervalR m n) (mk-set@@Int n))
                          (intervalR m (+ n 1))))
                   :pattern
                   ( (union (intervalR m n) (mk-set@@Int n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))
                          (intervalL m (+ n 1))))
                   :pattern
                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))
                          (intervalR (- m 1) n)))
                   :pattern
                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))
(assert (forall ( (m Int)
                  (n Int) )
                (! (=> (<= m n)
                       (= (union (mk-set@@Int m) (intervalL m n))
                          (intervalL (- m 1) n)))
                   :pattern
                   ( (union (mk-set@@Int m) (intervalL m n)) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (between x y z) (and (<= x y) (<= y z)))
                   :pattern
                   ( (between x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenR x y z) (and (<= x y) (< y z)))
                   :pattern
                   ( (betweenR x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenL x y z) (and (< x y) (<= y z)))
                   :pattern
                   ( (betweenL x y z) ))))
(assert (forall ( (x Int)
                  (y Int)
                  (z Int) )
                (! (= (betweenLR x y z) (and (< x y) (< y z)))
                   :pattern
                   ( (betweenLR x y z) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalL m n))
                      (and (< m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (intervalL m n)) ))))
(assert (forall ( (x Int)
                  (m Int)
                  (n Int) )
                (! (= (elem@@Int x (intervalL m n))
                      (and (< m x) (<= x n)))
                   :pattern
                   ( (elem@@Int x (intervalL m n)) ))))
(assert (forall ( (m Int) )
                (! (= (intervalR m m) empty-set@@Int)
                   :pattern
                   ( (intervalR m m) ))))
(assert (forall ( (m Int) )
                (! (= (intervalL m m) empty-set@@Int)
                   :pattern
                   ( (intervalL m m) ))))
(assert (forall ( (m Int) )
                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))
                   :pattern
                   ( (intervalR m (+ m 1)) ))))
(assert (forall ( (m Int) )
                (! (= (intervalL (- m 1) m) (mk-set@@Int m))
                   :pattern
                   ( (intervalL (- m 1) m) ))))
(assert (forall ( (m Int)
                  (n Int)
                  (p Int) )
                (! (=> (and (<= m n) (<= n p))
                       (= (union (intervalR m n) (intervalR n p))
                          (intervalR m p)))
                   :pattern
                   ( (union (intervalR m n) (intervalR n p)) ))))
(assert (forall ( (m Int)
                  (n Int)
                  (p Int) )
                (! (=> (and (<= m n) (<= n p))
                       (= (union (intervalL m n) (intervalL n p))
                          (intervalL m p)))
                   :pattern
                   ( (union (intervalL m n) (intervalL n p)) ))))
; m2:inv0
(assert (= (union (union (union pshL pshR) popL) popR) req))
; m2:inv1
(assert (= (intersect pshL pshR) empty-set@@sl$REQ))
; m2:inv2
(assert (= (intersect pshL popL) empty-set@@sl$REQ))
; m2:inv3
(assert (= (intersect pshL popR) empty-set@@sl$REQ))
; m2:inv4
(assert (= (intersect pshR popL) empty-set@@sl$REQ))
; m2:inv5
(assert (= (intersect pshR popR) empty-set@@sl$REQ))
; m2:inv6
(assert (= (intersect popL popR) empty-set@@sl$REQ))
; m3:inv0
(assert (elem@Open@@pfun@@Int@@sl$OBJ@Close qe (tfun@@Int@@sl$OBJ (intervalR p q) sl$OBJ)))
; m3:inv1
(assert (<= p q))
; m3:inv2
(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insL (tfun@@sl$REQ@@sl$OBJ pshL sl$OBJ)))
; m3:inv3
(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insR (tfun@@sl$REQ@@sl$OBJ pshR sl$OBJ)))
; m3:inv4
(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close res (pfun@@sl$REQ@@sl$OBJ ppd sl$OBJ)))
; m4:asm0
(assert (not (finite@@sl$Node sl$Node)))
; m4:inv0
(assert (elem@Open@@pfun@@Int@@sl$Node@Close rep (tfun@@Int@@sl$Node (intervalR p q) node)))
; m4:inv1
(assert (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close item (tfun@@sl$Node@@sl$OBJ node sl$OBJ)))
; m4:inv10
(assert (not (elem@@sl$Node dummy (ran@@Int@@sl$Node rep))))
; m4:inv11
(assert (not (elem@@sl$Node dummy (ran@@sl$REQ@@sl$Node nL))))
; m4:inv12
(assert (not (elem@@sl$Node dummy (ran@@sl$REQ@@sl$Node nR))))
; m4:inv3
(assert (forall ( (i Int) )
                (! (=> (betweenR p i q)
                       (= (apply@@Int@@sl$OBJ qe i)
                          (apply@@sl$Node@@sl$OBJ item (apply@@Int@@sl$Node rep i))))
                   :pattern
                   ( (apply@@Int@@sl$OBJ qe i) ))))
; m4:inv4
(assert (elem@Open@@pfun@@sl$REQ@@sl$Node@Close nL (pfun@@sl$REQ@@sl$Node pshL node)))
; m4:inv5
(assert (elem@Open@@pfun@@sl$REQ@@sl$Node@Close nR (pfun@@sl$REQ@@sl$Node pshR node)))
; m4:inv6
(assert (forall ( (r sl$REQ) )
                (! (=> (elem@@sl$REQ r (dom@@sl$REQ@@sl$Node nL))
                       (= (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nL r))
                          (apply@@sl$REQ@@sl$OBJ insL r)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nL r)) ))))
; m4:inv7
(assert (forall ( (r sl$REQ) )
                (! (=> (elem@@sl$REQ r (dom@@sl$REQ@@sl$Node nR))
                       (= (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nR r))
                          (apply@@sl$REQ@@sl$OBJ insR r)))
                   :pattern
                   ( (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nR r)) ))))
; m4:inv8
(assert (finite@@sl$Node node))
; m4:inv9
(assert (elem@@sl$Node dummy node))
(assert (not (=> (and (elem@Open@@pfun@@sl$Node@@sl$Node@Close left (tfun@@sl$Node@@sl$Node node node))
                      (elem@Open@@pfun@@sl$Node@@sl$Node@Close right (tfun@@sl$Node@@sl$Node node node))
                      (=> (= p q) (and (= LH dummy) (= RH dummy))))
                 (or (and (or (not (< p q))
                              (and (= LH (apply@@Int@@sl$Node rep p))
                                   (elem@@Int p (dom@@Int@@sl$Node rep))
                                   (= RH (apply@@Int@@sl$Node rep (- q 1)))
                                   (elem@@Int (- q 1) (dom@@Int@@sl$Node rep))))
                          (= (apply@@sl$Node@@sl$Node left dummy) dummy)
                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node left))
                          (= (apply@@sl$Node@@sl$Node right dummy) dummy)
                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node right))
                          (forall ( (i Int) )
                                  (=> true
                                      (or (not (betweenR p i (- q 1)))
                                          (and (= (apply@@sl$Node@@sl$Node right (apply@@Int@@sl$Node rep i))
                                                  (apply@@Int@@sl$Node rep (+ i 1)))
                                               (elem@@sl$Node (apply@@Int@@sl$Node rep i)
                                                              (dom@@sl$Node@@sl$Node right))
                                               (elem@@Int i (dom@@Int@@sl$Node rep))
                                               (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))))))
                          (forall ( (i Int) )
                                  (=> true
                                      (or (not (betweenR p i (- q 1)))
                                          (and (= (apply@@sl$Node@@sl$Node left (apply@@Int@@sl$Node rep (+ i 1)))
                                                  (apply@@Int@@sl$Node rep i))
                                               (elem@@sl$Node (apply@@Int@@sl$Node rep (+ i 1))
                                                              (dom@@sl$Node@@sl$Node left))
                                               (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))
                                               (elem@@Int i (dom@@Int@@sl$Node rep))))))
                          (= (apply@@sl$Node@@sl$Node left LH) dummy)
                          (elem@@sl$Node LH (dom@@sl$Node@@sl$Node left))
                          (= (apply@@sl$Node@@sl$Node right RH) dummy)
                          (elem@@sl$Node RH (dom@@sl$Node@@sl$Node right)))
                     (and (< p q)
                          (or (and (not (= LH (apply@@Int@@sl$Node rep p)))
                                   (elem@@Int p (dom@@Int@@sl$Node rep)))
                              (and (not (= RH (apply@@Int@@sl$Node rep (- q 1))))
                                   (elem@@Int (- q 1) (dom@@Int@@sl$Node rep)))))
                     (and (not (= (apply@@sl$Node@@sl$Node left dummy) dummy))
                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node left)))
                     (and (not (= (apply@@sl$Node@@sl$Node right dummy) dummy))
                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node right)))
                     (exists ( (i Int) )
                             (and true
                                  (and (betweenR p i (- q 1))
                                       (not (= (apply@@sl$Node@@sl$Node right (apply@@Int@@sl$Node rep i))
                                               (apply@@Int@@sl$Node rep (+ i 1))))
                                       (elem@@sl$Node (apply@@Int@@sl$Node rep i)
                                                      (dom@@sl$Node@@sl$Node right))
                                       (elem@@Int i (dom@@Int@@sl$Node rep))
                                       (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep)))))
                     (exists ( (i Int) )
                             (and true
                                  (and (betweenR p i (- q 1))
                                       (not (= (apply@@sl$Node@@sl$Node left (apply@@Int@@sl$Node rep (+ i 1)))
                                               (apply@@Int@@sl$Node rep i)))
                                       (elem@@sl$Node (apply@@Int@@sl$Node rep (+ i 1))
                                                      (dom@@sl$Node@@sl$Node left))
                                       (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))
                                       (elem@@Int i (dom@@Int@@sl$Node rep)))))
                     (and (not (= (apply@@sl$Node@@sl$Node left LH) dummy))
                          (elem@@sl$Node LH (dom@@sl$Node@@sl$Node left)))
                     (and (not (= (apply@@sl$Node@@sl$Node right RH) dummy))
                          (elem@@sl$Node RH (dom@@sl$Node@@sl$Node right)))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m5/INV/WD
