; m1/THM/thm0/main goal/assertion/lmm0/step 3
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-sort Node 0)
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const E (set (Pair Node Node)))
(declare-const free (set Node))
(declare-const live (set Node))
(declare-const p Node)
(declare-const ptr (set (Pair Node Node)))
(declare-const q Node)
(declare-const r Node)
(declare-const ref Node)
(declare-const rr (set (Pair Node Node)))
(declare-fun asrel@@Node ( (set Node) ) (set (Pair Node Node)))
(declare-fun card@@Node ( (set Node) ) Int)
(declare-fun card@Open@@Pair@@Node@@Node@Close
             ( (set (Pair Node Node)) )
             Int)
(declare-fun finite@@Node ( (set Node) ) Bool)
(declare-fun finite@Open@@Pair@@Node@@Node@Close
             ( (set (Pair Node Node)) )
             Bool)
(declare-fun id@@Node () (set (Pair Node Node)))
(declare-fun lookup@@Node@@Node
             ( (set (Pair Node Node))
               (set Node) )
             (set Node))
(declare-fun mk-set@@Node (Node) (set Node))
(declare-fun mk-set@Open@@Pair@@Node@@Node@Close
             ( (Pair Node Node) )
             (set (Pair Node Node)))
(declare-fun plus@@Node
             ( (set (Pair Node Node)) )
             (set (Pair Node Node)))
(declare-fun reldom@@Node@@Node
             ( (set (Pair Node Node)) )
             (set Node))
(declare-fun seq@@Node@@Node@@Node
             ( (set (Pair Node Node))
               (set (Pair Node Node)) )
             (set (Pair Node Node)))
(declare-fun star@@Node
             ( (set (Pair Node Node)) )
             (set (Pair Node Node)))
(define-fun Node () (set Node) ( (as const (set Node)) true ))
(define-fun all@@Node
            ()
            (set Node)
            ( (as const (set Node))
              true ))
(define-fun all@Open@@Pair@@Node@@Node@Close
            ()
            (set (Pair Node Node))
            ( (as const (set (Pair Node Node)))
              true ))
(define-fun compl@@Node
            ( (s1 (set Node)) )
            (set Node)
            ( (_ map not)
              s1 ))
(define-fun compl@Open@@Pair@@Node@@Node@Close
            ( (s1 (set (Pair Node Node))) )
            (set (Pair Node Node))
            ( (_ map not)
              s1 ))
(define-fun elem@@Node
            ( (x Node)
              (s1 (set Node)) )
            Bool
            (select s1 x))
(define-fun elem@Open@@Pair@@Node@@Node@Close
            ( (x (Pair Node Node))
              (s1 (set (Pair Node Node))) )
            Bool
            (select s1 x))
(define-fun empty-set@@Node
            ()
            (set Node)
            ( (as const (set Node))
              false ))
(define-fun empty-set@Open@@Pair@@Node@@Node@Close
            ()
            (set (Pair Node Node))
            ( (as const (set (Pair Node Node)))
              false ))
(define-fun set-diff@@Node
            ( (s1 (set Node))
              (s2 (set Node)) )
            (set Node)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@Open@@Pair@@Node@@Node@Close
            ( (s1 (set (Pair Node Node)))
              (s2 (set (Pair Node Node))) )
            (set (Pair Node Node))
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@Node
            ( (s1 (set Node))
              (s2 (set Node)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@Open@@Pair@@Node@@Node@Close
            ( (s1 (set (Pair Node Node)))
              (s2 (set (Pair Node Node))) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(assert (= E (mk-set (pair p q))))
(assert (= rr (asrel (mk-set r))))
(assert (forall ( (r (set Node)) )
                (! (=> (finite r) (<= 0 (card r)))
                   :pattern
                   ( (<= 0 (card r)) ))))
(assert (forall ( (r (set (Pair Node Node))) )
                (! (=> (finite r) (<= 0 (card r)))
                   :pattern
                   ( (<= 0 (card r)) ))))
(assert (forall ( (r (set Node)) )
                (! (= (= (card r) 0) (= r empty-set))
                   :pattern
                   ( (card r) ))))
(assert (forall ( (r (set (Pair Node Node))) )
                (! (= (= (card r) 0) (= r empty-set))
                   :pattern
                   ( (card r) ))))
(assert (forall ( (x Node) )
                (! (= (card (mk-set x)) 1)
                   :pattern
                   ( (card (mk-set x)) ))))
(assert (forall ( (x (Pair Node Node)) )
                (! (= (card (mk-set x)) 1)
                   :pattern
                   ( (card (mk-set x)) ))))
(assert (forall ( (r (set Node)) )
                (! (= (= (card r) 1)
                      (exists ( (x Node) ) (and true (= r (mk-set x)))))
                   :pattern
                   ( (card r) ))))
(assert (forall ( (r (set (Pair Node Node))) )
                (! (= (= (card r) 1)
                      (exists ( (x (Pair Node Node)) )
                              (and true (= r (mk-set x)))))
                   :pattern
                   ( (card r) ))))
(assert (forall ( (r (set Node))
                  (r0 (set Node)) )
                (! (=> (= (intersect r r0) empty-set)
                       (= (card (union r r0)) (+ (card r) (card r0))))
                   :pattern
                   ( (card (union r r0)) ))))
(assert (forall ( (r (set (Pair Node Node)))
                  (r0 (set (Pair Node Node))) )
                (! (=> (= (intersect r r0) empty-set)
                       (= (card (union r r0)) (+ (card r) (card r0))))
                   :pattern
                   ( (card (union r r0)) ))))
(assert (forall ( (x Node)
                  (y Node) )
                (! (= (elem x (mk-set y)) (= x y))
                   :pattern
                   ( (elem x (mk-set y)) ))))
(assert (forall ( (x (Pair Node Node))
                  (y (Pair Node Node)) )
                (! (= (elem x (mk-set y)) (= x y))
                   :pattern
                   ( (elem x (mk-set y)) ))))
(assert (forall ( (s1 (set Node))
                  (s2 (set Node)) )
                (! (=> (finite s1) (finite (set-diff s1 s2)))
                   :pattern
                   ( (finite (set-diff s1 s2)) ))))
(assert (forall ( (s1 (set (Pair Node Node)))
                  (s2 (set (Pair Node Node))) )
                (! (=> (finite s1) (finite (set-diff s1 s2)))
                   :pattern
                   ( (finite (set-diff s1 s2)) ))))
(assert (forall ( (s1 (set Node))
                  (s2 (set Node)) )
                (! (=> (and (finite s1) (finite s2))
                       (finite (union s1 s2)))
                   :pattern
                   ( (finite (union s1 s2)) ))))
(assert (forall ( (s1 (set (Pair Node Node)))
                  (s2 (set (Pair Node Node))) )
                (! (=> (and (finite s1) (finite s2))
                       (finite (union s1 s2)))
                   :pattern
                   ( (finite (union s1 s2)) ))))
(assert (forall ( (s1 (set Node))
                  (s2 (set Node)) )
                (! (=> (and (finite s2) (not (finite s1)))
                       (not (finite (set-diff s1 s2))))
                   :pattern
                   ( (finite (set-diff s1 s2)) ))))
(assert (forall ( (s1 (set (Pair Node Node)))
                  (s2 (set (Pair Node Node))) )
                (! (=> (and (finite s2) (not (finite s1)))
                       (not (finite (set-diff s1 s2))))
                   :pattern
                   ( (finite (set-diff s1 s2)) ))))
(assert (forall ( (x Node) )
                (! (finite (mk-set x))
                   :pattern
                   ( (finite (mk-set x)) ))))
(assert (forall ( (x (Pair Node Node)) )
                (! (finite (mk-set x))
                   :pattern
                   ( (finite (mk-set x)) ))))
(assert (finite empty-set))
(assert (finite empty-set))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (x1 Node)
                  (x2 Node) )
                (! (=> (elem (pair x1 x2) r1) (elem x1 (reldom r1)))
                   :pattern
                   ( (elem (pair x1 x2) r1)
                     (elem x1 (reldom r1)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (s1 (set Node)) )
                (! (= (reldom (seq (asrel s1) r1))
                      (intersect s1 (reldom r1)))
                   :pattern
                   ( (reldom (seq (asrel s1) r1)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (x1 Node)
                  (x2 Node) )
                (! (= (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1))
                      (elem (pair x1 x2) r1))
                   :pattern
                   ( (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1)) ))))
(assert (forall ( (x1 Node) )
                (! (= (asrel (mk-set x1)) (mk-set (pair x1 x1)))
                   :pattern
                   ( (asrel (mk-set x1)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r3 (set (Pair Node Node)))
                  (r5 (set (Pair Node Node))) )
                (! (= (seq (seq r1 r3) r5) (seq r1 (seq r3 r5)))
                   :pattern
                   ( (seq (seq r1 r3) r5) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r2 (set (Pair Node Node)))
                  (r3 (set (Pair Node Node))) )
                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))
                   :pattern
                   ( (subset (seq r1 r3) (seq r2 r3)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r2 (set (Pair Node Node)))
                  (r4 (set (Pair Node Node))) )
                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))
                   :pattern
                   ( (subset (seq r4 r1) (seq r4 r2)) ))))
(assert (forall ( (rr (set (Pair Node Node)))
                  (rr2 (set (Pair Node Node))) )
                (! (= (star (union rr rr2))
                      (seq (star (seq (star rr) rr2)) (star rr)))
                   :pattern
                   ( (star (union rr rr2)) ))))
(assert (forall ( (rr (set (Pair Node Node)))
                  (rr2 (set (Pair Node Node))) )
                (! (= (star (union rr rr2))
                      (seq (star rr2) (star (seq rr (star rr2)))))
                   :pattern
                   ( (star (union rr rr2)) ))))
(assert (forall ( (rr (set (Pair Node Node))) )
                (! (= (union (seq (star rr) rr) id) (star rr))
                   :pattern
                   ( (union (seq (star rr) rr) id) ))))
(assert (forall ( (rr (set (Pair Node Node))) )
                (! (= (union (seq rr (star rr)) id) (star rr))
                   :pattern
                   ( (union (seq rr (star rr)) id) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r2 (set (Pair Node Node)))
                  (r3 (set (Pair Node Node))) )
                (! (= (seq (union r1 r2) r3)
                      (union (seq r1 r3) (seq r2 r3)))
                   :pattern
                   ( (seq (union r1 r2) r3) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r2 (set (Pair Node Node)))
                  (r4 (set (Pair Node Node))) )
                (! (= (seq r4 (union r1 r2))
                      (union (seq r4 r1) (seq r4 r2)))
                   :pattern
                   ( (seq r4 (union r1 r2)) ))))
(assert (forall ( (x1 Node)
                  (x3 Node) )
                (! (= (seq (mk-set (pair x1 x3)) all)
                      (seq (asrel (mk-set x1)) all))
                   :pattern
                   ( (seq (mk-set (pair x1 x3)) all) ))))
(assert (forall ( (x1 Node)
                  (x2 Node)
                  (x4 Node)
                  (x5 Node) )
                (! (= (seq (seq (mk-set (pair x1 x2)) all)
                           (mk-set (pair x4 x5)))
                      (mk-set (pair x1 x5)))
                   :pattern
                   ( (seq (seq (mk-set (pair x1 x2)) all)
                          (mk-set (pair x4 x5))) ))))
(assert (forall ( (x1 Node)
                  (x2 Node) )
                (! (= (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2)))
                      (mk-set (pair x1 x2)))
                   :pattern
                   ( (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2))) ))))
(assert (forall ( (x1 Node)
                  (x3 Node) )
                (! (= (elem (pair x1 x3) id) (= x1 x3))
                   :pattern
                   ( (elem (pair x1 x3) id) ))))
(assert (forall ( (r1 (set (Pair Node Node))) )
                (! (= (seq id r1) r1) :pattern ( (seq id r1) ))))
(assert (forall ( (r1 (set (Pair Node Node))) )
                (! (= (seq r1 id) r1) :pattern ( (seq r1 id) ))))
(assert (forall ( (rr (set (Pair Node Node))) )
                (! (subset rr (star rr))
                   :pattern
                   ( (subset rr (star rr)) ))))
(assert (forall ( (rr (set (Pair Node Node)))
                  (rr2 (set (Pair Node Node))) )
                (! (=> (subset rr rr2) (subset (star rr) (star rr2)))
                   :pattern
                   ( (subset (star rr) (star rr2)) ))))
(assert (forall ( (rr (set (Pair Node Node)))
                  (rr2 (set (Pair Node Node)))
                  (x1 Node)
                  (x3 Node) )
                (! (=> (elem (pair x1 x3) (star (intersect rr rr2)))
                       (elem (pair x1 x3) (star rr)))
                   :pattern
                   ( (elem (pair x1 x3) (star (intersect rr rr2)))
                     (elem (pair x1 x3) (star rr)) ))))
(assert (forall ( (rr (set (Pair Node Node)))
                  (rr2 (set (Pair Node Node)))
                  (x1 Node)
                  (x3 Node) )
                (! (=> (elem (pair x1 x3) (star rr))
                       (elem (pair x1 x3) (star (union rr rr2))))
                   :pattern
                   ( (elem (pair x1 x3) (star (union rr rr2))) ))))
(assert (forall ( (rr (set (Pair Node Node))) )
                (! (= (seq (star rr) (star rr)) (star rr))
                   :pattern
                   ( (seq (star rr) (star rr)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r2 (set (Pair Node Node)))
                  (r3 (set (Pair Node Node))) )
                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))
                   :pattern
                   ( (subset (seq r1 r3) (seq r2 r3)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (r2 (set (Pair Node Node)))
                  (r4 (set (Pair Node Node))) )
                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))
                   :pattern
                   ( (subset (seq r4 r1) (seq r4 r2)) ))))
(assert (forall ( (rr (set (Pair Node Node))) )
                (! (= (plus rr) (seq (star rr) rr))
                   :pattern
                   ( (plus rr) ))))
(assert (forall ( (rr (set (Pair Node Node))) )
                (! (= (plus rr) (seq rr (star rr)))
                   :pattern
                   ( (plus rr) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (s1 (set Node))
                  (x2 Node) )
                (! (= (elem x2 (lookup r1 s1))
                      (exists ( (x1 Node) )
                              (and (elem x1 s1) (elem (pair x1 x2) r1))))
                   :pattern
                   ( (elem x2 (lookup r1 s1)) ))))
(assert (forall ( (r1 (set (Pair Node Node)))
                  (s1 (set Node))
                  (x1 Node)
                  (x2 Node) )
                (! (=> (elem x1 s1)
                       (=> (elem (pair x1 x2) r1) (elem x2 (lookup r1 s1))))
                   :pattern
                   ( (elem (pair x1 x2) r1)
                     (elem x2 (lookup r1 s1)) ))))
(assert true)
(assert true)
(assert (not (subset (union (seq (seq (seq rr (seq (star (seq (star ptr) E)) (star ptr)))
                                      E)
                                 (star ptr))
                            (seq rr (star ptr)))
                     (union (seq (seq rr (seq all E)) (star ptr))
                            (seq rr (star ptr))))))
(assert (not (subset (seq (seq (seq rr (seq (star (seq (star ptr) E)) (star ptr)))
                               E)
                          (star ptr))
                     (seq (seq rr (seq all E)) (star ptr)))))
(assert (not (subset (seq (seq rr (seq (star (seq (star ptr) E)) (star ptr)))
                          E)
                     (seq rr (seq all E)))))
(assert (not (subset (seq (star (seq (star ptr) E)) (star ptr)) all)))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m1/THM/thm0/main goal/assertion/lmm0/step 3
