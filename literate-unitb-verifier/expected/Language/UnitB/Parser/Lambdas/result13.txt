; m0/evt/INV/inv6
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const a Int)
(declare-const a@prime Int)
(declare-const b Int)
(declare-const b@prime Int)
(declare-const c Int)
(declare-const c@prime Int)
(declare-const f (pfun Int Int))
(declare-const f@prime (pfun Int Int))
(declare-const n Int)
(declare-const n@prime Int)
(declare-fun apply@@Int@@Int ( (pfun Int Int) Int ) Int)
(declare-fun card@@Int ( (set Int) ) Int)
(declare-fun const@@Int@@Int (Int) (Array Int Int))
(declare-fun dom@@Int@@Int ( (pfun Int Int) ) (set Int))
(declare-fun dom-rest@@Int@@Int
             ( (set Int)
               (pfun Int Int) )
             (pfun Int Int))
(declare-fun dom-subt@@Int@@Int
             ( (set Int)
               (pfun Int Int) )
             (pfun Int Int))
(declare-fun empty-fun@@Int@@Int () (pfun Int Int))
(declare-fun finite@@Int ( (set Int) ) Bool)
(declare-fun ident@@Int () (Array Int Int))
(declare-fun injective@@Int@@Int ( (pfun Int Int) ) Bool)
(declare-fun lambda@@Int@@Int
             ( (set Int)
               (Array Int Int) )
             (pfun Int Int))
(declare-fun mk-fun@@Int@@Int (Int Int) (pfun Int Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun ovl@@Int@@Int
             ( (pfun Int Int)
               (pfun Int Int) )
             (pfun Int Int))
(declare-fun qsum@@Int ( (set Int) (Array Int Int) ) Int)
(declare-fun ran@@Int@@Int ( (pfun Int Int) ) (set Int))
(declare-fun set@@Int@@Int
             ( (set Int)
               (Array Int Int) )
             (set Int))
(declare-fun @@lambda@@_0 (Int Int) (set Int))
(declare-fun @@lambda@@_1 (Int) (Array Int Int))
(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))
(define-fun compl@@Int
            ( (s1 (set Int)) )
            (set Int)
            ( (_ map not)
              s1 ))
(define-fun elem@@Int
            ( (x Int)
              (s1 (set Int)) )
            Bool
            (select s1 x))
(define-fun empty-set@@Int
            ()
            (set Int)
            ( (as const (set Int))
              false ))
(define-fun set-diff@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            (set Int)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(assert (forall ( (term (Array Int Int)) )
                (! (= (qsum@@Int empty-set@@Int term) 0)
                   :pattern
                   ( (qsum@@Int empty-set@@Int term) ))))
(assert (forall ( (r (set Int))
                  (term (Array Int Int))
                  (x Int) )
                (! (=> (not (elem@@Int x r))
                       (= (qsum@@Int (union r (mk-set@@Int x)) term)
                          (+ (qsum@@Int r term) (select term x))))
                   :pattern
                   ( (qsum@@Int (union r (mk-set@@Int x)) term) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int))
                  (term (Array Int Int)) )
                (! (=> (= (intersect r r0) empty-set@@Int)
                       (= (qsum@@Int (union r r0) term)
                          (+ (qsum@@Int r term) (qsum@@Int r0 term))))
                   :pattern
                   ( (qsum@@Int (union r r0) term) ))))
(assert (forall ( (r (set Int)) )
                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))
                   :pattern
                   ( (<= 0 (card@@Int r)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (x Int) )
                (! (= (card@@Int (mk-set@@Int x)) 1)
                   :pattern
                   ( (card@@Int (mk-set@@Int x)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 1)
                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int)) )
                (! (=> (= (intersect r r0) empty-set@@Int)
                       (= (card@@Int (union r r0))
                          (+ (card@@Int r) (card@@Int r0))))
                   :pattern
                   ( (card@@Int (union r r0)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (card@@Int r) (qsum@@Int r (const@@Int@@Int 1)))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (select (const@@Int@@Int x) y) x)
                   :pattern
                   ( (select (const@@Int@@Int x) y) ))))
(assert (forall ( (x Int) )
                (! (= (select ident@@Int x) x)
                   :pattern
                   ( (select ident@@Int x) ))))
(assert (= (dom@@Int@@Int empty-fun@@Int@@Int)
           empty-set@@Int))
(assert (forall ( (t (Array Int Int)) )
                (! (= (lambda@@Int@@Int empty-set@@Int t)
                      empty-fun@@Int@@Int)
                   :pattern
                   ( (lambda@@Int@@Int empty-set@@Int t) ))))
(assert (forall ( (r (set Int))
                  (t (Array Int Int)) )
                (! (= (dom@@Int@@Int (lambda@@Int@@Int r t)) r)
                   :pattern
                   ( (dom@@Int@@Int (lambda@@Int@@Int r t)) ))))
(assert (forall ( (t (Array Int Int))
                  (x Int) )
                (! (= (lambda@@Int@@Int (mk-set@@Int x) t)
                      (mk-fun@@Int@@Int x (select t x)))
                   :pattern
                   ( (lambda@@Int@@Int (mk-set@@Int x) t) ))))
(assert (forall ( (r (set Int))
                  (t (Array Int Int))
                  (x Int) )
                (! (= (ovl@@Int@@Int (lambda@@Int@@Int r t)
                                     (mk-fun@@Int@@Int x (select t x)))
                      (lambda@@Int@@Int (union r (mk-set@@Int x)) t))
                   :pattern
                   ( (ovl@@Int@@Int (lambda@@Int@@Int r t)
                                    (mk-fun@@Int@@Int x (select t x))) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int))
                  (t (Array Int Int)) )
                (! (= (ovl@@Int@@Int (lambda@@Int@@Int r t) (lambda@@Int@@Int r0 t))
                      (lambda@@Int@@Int (union r r0) t))
                   :pattern
                   ( (ovl@@Int@@Int (lambda@@Int@@Int r t) (lambda@@Int@@Int r0 t)) ))))
(assert (forall ( (f1 (pfun Int Int)) )
                (! (= (ovl@@Int@@Int f1 empty-fun@@Int@@Int) f1)
                   :pattern
                   ( (ovl@@Int@@Int f1 empty-fun@@Int@@Int) ))))
(assert (forall ( (f1 (pfun Int Int)) )
                (! (= (ovl@@Int@@Int empty-fun@@Int@@Int f1) f1)
                   :pattern
                   ( (ovl@@Int@@Int empty-fun@@Int@@Int f1) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (dom@@Int@@Int (mk-fun@@Int@@Int x y))
                      (mk-set@@Int x))
                   :pattern
                   ( (dom@@Int@@Int (mk-fun@@Int@@Int x y)) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (f2 (pfun Int Int))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@Int f2))
                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)
                          (apply@@Int@@Int f2 x)))
                   :pattern
                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (f2 (pfun Int Int))
                  (x Int) )
                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))
                            (not (elem@@Int x (dom@@Int@@Int f2))))
                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)
                          (apply@@Int@@Int f1 x)))
                   :pattern
                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) y)
                   :pattern
                   ( (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Int f1)))
                       (= (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x)
                          (apply@@Int@@Int f1 x)))
                   :pattern
                   ( (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))
                       (= (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x)
                          (apply@@Int@@Int f1 x)))
                   :pattern
                   ( (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (f2 (pfun Int Int)) )
                (! (= (dom@@Int@@Int (ovl@@Int@@Int f1 f2))
                      (union (dom@@Int@@Int f1) (dom@@Int@@Int f2)))
                   :pattern
                   ( (dom@@Int@@Int (ovl@@Int@@Int f1 f2)) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1))
                      (intersect s1 (dom@@Int@@Int f1)))
                   :pattern
                   ( (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1)) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (s1 (set Int)) )
                (! (= (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1))
                      (set-diff@@Int (dom@@Int@@Int f1) s1))
                   :pattern
                   ( (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1)) ))))
(assert (forall ( (r (set Int))
                  (t (Array Int Int))
                  (x Int) )
                (! (=> (elem@@Int x r)
                       (= (apply@@Int@@Int (lambda@@Int@@Int r t) x)
                          (select t x)))
                   :pattern
                   ( (apply@@Int@@Int (lambda@@Int@@Int r t) x) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (x Int)
                  (y Int) )
                (! (= (and (elem@@Int x (dom@@Int@@Int f1))
                           (= (apply@@Int@@Int f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@Int x (dom@@Int@@Int f1))
                     (apply@@Int@@Int f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (x Int)
                  (x2 Int)
                  (y Int) )
                (! (=> (not (= x x2))
                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2)
                          (apply@@Int@@Int f1 x2)))
                   :pattern
                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (x Int)
                  (y Int) )
                (! (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x)
                      y)
                   :pattern
                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x) ))))
(assert (= (ran@@Int@@Int empty-fun@@Int@@Int)
           empty-set@@Int))
(assert (forall ( (f1 (pfun Int Int))
                  (y Int) )
                (! (= (elem@@Int y (ran@@Int@@Int f1))
                      (exists ( (x Int) )
                              (and true
                                   (and (elem@@Int x (dom@@Int@@Int f1))
                                        (= (apply@@Int@@Int f1 x) y)))))
                   :pattern
                   ( (elem@@Int y (ran@@Int@@Int f1)) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (ran@@Int@@Int (mk-fun@@Int@@Int x y))
                      (mk-set@@Int y))
                   :pattern
                   ( (ran@@Int@@Int (mk-fun@@Int@@Int x y)) ))))
(assert (forall ( (f1 (pfun Int Int)) )
                (! (= (injective@@Int@@Int f1)
                      (forall ( (x Int)
                                (x2 Int) )
                              (=> (and (elem@@Int x (dom@@Int@@Int f1))
                                       (elem@@Int x2 (dom@@Int@@Int f1)))
                                  (=> (= (apply@@Int@@Int f1 x) (apply@@Int@@Int f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@Int@@Int f1) ))))
(assert (injective@@Int@@Int empty-fun@@Int@@Int))
(assert (forall ( (f1 (pfun Int Int))
                  (x Int) )
                (! (=> (elem@@Int x (dom@@Int@@Int f1))
                       (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)))
                   :pattern
                   ( (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))
                       (elem@@Int (apply@@Int@@Int f1 x)
                                  (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))))
                   :pattern
                   ( (elem@@Int (apply@@Int@@Int f1 x)
                                (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (s1 (set Int))
                  (x Int) )
                (! (=> (elem@@Int x (intersect (dom@@Int@@Int f1) s1))
                       (elem@@Int (apply@@Int@@Int f1 x)
                                  (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))))
                   :pattern
                   ( (elem@@Int (apply@@Int@@Int f1 x)
                                (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (x Int)
                  (y Int) )
                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))
                            (injective@@Int@@Int f1))
                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))
                          (union (set-diff@@Int (ran@@Int@@Int f1)
                                                (mk-set@@Int (apply@@Int@@Int f1 x)))
                                 (mk-set@@Int y))))
                   :pattern
                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))
(assert (forall ( (f1 (pfun Int Int))
                  (x Int)
                  (y Int) )
                (! (=> (not (elem@@Int x (dom@@Int@@Int f1)))
                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))
                          (union (ran@@Int@@Int f1) (mk-set@@Int y))))
                   :pattern
                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))
                   :pattern
                   ( (elem@@Int x (mk-set@@Int y)) ))))
(assert (forall ( (r1 (set Int))
                  (term (Array Int Int))
                  (y Int) )
                (! (= (elem@@Int y (set@@Int@@Int r1 term))
                      (exists ( (x Int) )
                              (and (elem@@Int x r1) (= (select term x) y))))
                   :pattern
                   ( (elem@@Int y (set@@Int@@Int r1 term)) ))))
(assert (forall ( (r1 (set Int))
                  (term (Array Int Int))
                  (y Int) )
                (! (= (= (set@@Int@@Int r1 term) (mk-set@@Int y))
                      (forall ( (x Int) )
                              (=> (elem@@Int x r1) (= (select term x) y))))
                   :pattern
                   ( (set@@Int@@Int r1 term)
                     (mk-set@@Int y) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (finite@@Int s1)
                       (finite@@Int (set-diff@@Int s1 s2)))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s1) (finite@@Int s2))
                       (finite@@Int (union s1 s2)))
                   :pattern
                   ( (finite@@Int (union s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))
                       (not (finite@@Int (set-diff@@Int s1 s2))))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (x Int) )
                (! (finite@@Int (mk-set@@Int x))
                   :pattern
                   ( (finite@@Int (mk-set@@Int x)) ))))
(assert (finite@@Int empty-set@@Int))
(assert (forall ( (r1 (set Int)) )
                (! (= (set@@Int@@Int r1 ident@@Int) r1)
                   :pattern
                   ( (set@@Int@@Int r1 ident@@Int) ))))
(assert (forall ( (@@fv@@_0 Int)
                  (@@bv@@_0 Int) )
                (! (= (select (@@lambda@@_1 @@fv@@_0) @@bv@@_0)
                      (^ @@bv@@_0 @@fv@@_0))
                   :pattern
                   ( (select (@@lambda@@_1 @@fv@@_0) @@bv@@_0) ))))
(assert (forall ( (@@fv@@_0 Int)
                  (@@fv@@_1 Int)
                  (@@bv@@_0 Int) )
                (! (= (elem@@Int @@bv@@_0 (@@lambda@@_0 @@fv@@_0 @@fv@@_1))
                      (and (<= @@fv@@_0 @@bv@@_0) (< @@bv@@_0 @@fv@@_1)))
                   :pattern
                   ( (elem@@Int @@bv@@_0 (@@lambda@@_0 @@fv@@_0 @@fv@@_1)) ))))
; a0
(assert (= n@prime (+ n 1)))
; a1
(assert (= a@prime (+ a b)))
; a2
(assert (= b@prime (+ b c)))
; a3
(assert (= c@prime (+ c 6)))
; a4
(assert (= f@prime (ovl@@Int@@Int f (mk-fun@@Int@@Int n a))))
; inv0
(assert (= a (^ n 3)))
; inv1
(assert (= b (+ (+ (* 3 (^ n 2)) (* 3 n)) 1)))
; inv2
(assert (= c (+ (* 6 n) 6)))
; inv3
(assert (= f
           (lambda@@Int@@Int (@@lambda@@_0 0 n) (@@lambda@@_1 3))))
; inv4
(assert (<= 0 n))
; inv5
(assert (forall ( (i Int) )
                (! (=> (and (<= 0 i) (< i n))
                       (= (apply@@Int@@Int f i) (^ i 3)))
                   :pattern
                   ( (apply@@Int@@Int f i) ))))
; inv6
(assert (= (dom@@Int@@Int f)
           (set@@Int@@Int (@@lambda@@_0 0 n) ident@@Int)))
(assert (not (= (dom@@Int@@Int f@prime)
                (set@@Int@@Int (@@lambda@@_0 0 n@prime) ident@@Int))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m0/evt/INV/inv6
