; train0/leave/FIS/in@prime
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
(declare-sort sl$BLK 0)
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$LOC 0)
; comment: we don't need to declare the sort Real
(declare-sort sl$TRAIN 0)
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const PLF (set sl$BLK))
(declare-const ent sl$BLK)
(declare-const ext sl$BLK)
(declare-const in (set sl$TRAIN))
(declare-const in@prime (set sl$TRAIN))
(declare-const loc (pfun sl$TRAIN sl$BLK))
(declare-const loc@prime (pfun sl$TRAIN sl$BLK))
(declare-const t sl$TRAIN)
(declare-fun apply@@sl$TRAIN@@sl$BLK
             ( (pfun sl$TRAIN sl$BLK)
               sl$TRAIN )
             sl$BLK)
(declare-fun card@@sl$BLK ( (set sl$BLK) ) Int)
(declare-fun card@@sl$LOC ( (set sl$LOC) ) Int)
(declare-fun card@@sl$TRAIN ( (set sl$TRAIN) ) Int)
(declare-fun dom@@sl$TRAIN@@sl$BLK
             ( (pfun sl$TRAIN sl$BLK) )
             (set sl$TRAIN))
(declare-fun dom-rest@@sl$TRAIN@@sl$BLK
             ( (set sl$TRAIN)
               (pfun sl$TRAIN sl$BLK) )
             (pfun sl$TRAIN sl$BLK))
(declare-fun dom-subt@@sl$TRAIN@@sl$BLK
             ( (set sl$TRAIN)
               (pfun sl$TRAIN sl$BLK) )
             (pfun sl$TRAIN sl$BLK))
(declare-fun empty-fun@@sl$TRAIN@@sl$BLK
             ()
             (pfun sl$TRAIN sl$BLK))
(declare-fun finite@@sl$BLK ( (set sl$BLK) ) Bool)
(declare-fun finite@@sl$LOC ( (set sl$LOC) ) Bool)
(declare-fun finite@@sl$TRAIN ( (set sl$TRAIN) ) Bool)
(declare-fun injective@@sl$TRAIN@@sl$BLK
             ( (pfun sl$TRAIN sl$BLK) )
             Bool)
(declare-fun mk-fun@@sl$TRAIN@@sl$BLK
             (sl$TRAIN sl$BLK)
             (pfun sl$TRAIN sl$BLK))
(declare-fun mk-set@@sl$BLK (sl$BLK) (set sl$BLK))
(declare-fun mk-set@@sl$TRAIN (sl$TRAIN) (set sl$TRAIN))
(declare-fun ovl@@sl$TRAIN@@sl$BLK
             ( (pfun sl$TRAIN sl$BLK)
               (pfun sl$TRAIN sl$BLK) )
             (pfun sl$TRAIN sl$BLK))
(declare-fun ran@@sl$TRAIN@@sl$BLK
             ( (pfun sl$TRAIN sl$BLK) )
             (set sl$BLK))
(define-fun all@@sl$BLK
            ()
            (set sl$BLK)
            ( (as const (set sl$BLK))
              true ))
(define-fun all@@sl$LOC
            ()
            (set sl$LOC)
            ( (as const (set sl$LOC))
              true ))
(define-fun all@@sl$TRAIN
            ()
            (set sl$TRAIN)
            ( (as const (set sl$TRAIN))
              true ))
(define-fun compl@@sl$BLK
            ( (s1 (set sl$BLK)) )
            (set sl$BLK)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$LOC
            ( (s1 (set sl$LOC)) )
            (set sl$LOC)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$TRAIN
            ( (s1 (set sl$TRAIN)) )
            (set sl$TRAIN)
            ( (_ map not)
              s1 ))
(define-fun elem@@sl$BLK
            ( (x sl$BLK)
              (s1 (set sl$BLK)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$TRAIN
            ( (x sl$TRAIN)
              (s1 (set sl$TRAIN)) )
            Bool
            (select s1 x))
(define-fun empty-set@@sl$BLK
            ()
            (set sl$BLK)
            ( (as const (set sl$BLK))
              false ))
(define-fun empty-set@@sl$LOC
            ()
            (set sl$LOC)
            ( (as const (set sl$LOC))
              false ))
(define-fun empty-set@@sl$TRAIN
            ()
            (set sl$TRAIN)
            ( (as const (set sl$TRAIN))
              false ))
(define-fun set-diff@@sl$BLK
            ( (s1 (set sl$BLK))
              (s2 (set sl$BLK)) )
            (set sl$BLK)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$LOC
            ( (s1 (set sl$LOC))
              (s2 (set sl$LOC)) )
            (set sl$LOC)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$TRAIN
            ( (s1 (set sl$TRAIN))
              (s2 (set sl$TRAIN)) )
            (set sl$TRAIN)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@sl$BLK
            ( (s1 (set sl$BLK))
              (s2 (set sl$BLK)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$LOC
            ( (s1 (set sl$LOC))
              (s2 (set sl$LOC)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$TRAIN
            ( (s1 (set sl$TRAIN))
              (s2 (set sl$TRAIN)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$BLK
            ()
            (set sl$BLK)
            ( (as const (set sl$BLK))
              true ))
(define-fun sl$LOC
            ()
            (set sl$LOC)
            ( (as const (set sl$LOC))
              true ))
(define-fun sl$TRAIN
            ()
            (set sl$TRAIN)
            ( (as const (set sl$TRAIN))
              true ))
(assert (forall ( (r (set sl$BLK)) )
                (! (=> (finite@@sl$BLK r) (<= 0 (card@@sl$BLK r)))
                   :pattern
                   ( (<= 0 (card@@sl$BLK r)) ))))
(assert (forall ( (r (set sl$LOC)) )
                (! (=> (finite@@sl$LOC r) (<= 0 (card@@sl$LOC r)))
                   :pattern
                   ( (<= 0 (card@@sl$LOC r)) ))))
(assert (forall ( (r (set sl$TRAIN)) )
                (! (=> (finite@@sl$TRAIN r) (<= 0 (card@@sl$TRAIN r)))
                   :pattern
                   ( (<= 0 (card@@sl$TRAIN r)) ))))
(assert (forall ( (r (set sl$BLK)) )
                (! (= (= (card@@sl$BLK r) 0) (= r empty-set@@sl$BLK))
                   :pattern
                   ( (card@@sl$BLK r) ))))
(assert (forall ( (r (set sl$LOC)) )
                (! (= (= (card@@sl$LOC r) 0) (= r empty-set@@sl$LOC))
                   :pattern
                   ( (card@@sl$LOC r) ))))
(assert (forall ( (r (set sl$TRAIN)) )
                (! (= (= (card@@sl$TRAIN r) 0)
                      (= r empty-set@@sl$TRAIN))
                   :pattern
                   ( (card@@sl$TRAIN r) ))))
(assert (forall ( (x sl$BLK) )
                (! (= (card@@sl$BLK (mk-set@@sl$BLK x)) 1)
                   :pattern
                   ( (card@@sl$BLK (mk-set@@sl$BLK x)) ))))
(assert (forall ( (x sl$TRAIN) )
                (! (= (card@@sl$TRAIN (mk-set@@sl$TRAIN x)) 1)
                   :pattern
                   ( (card@@sl$TRAIN (mk-set@@sl$TRAIN x)) ))))
(assert (forall ( (r (set sl$BLK)) )
                (! (= (= (card@@sl$BLK r) 1)
                      (exists ( (x sl$BLK) ) (and true (= r (mk-set@@sl$BLK x)))))
                   :pattern
                   ( (card@@sl$BLK r) ))))
(assert (forall ( (r (set sl$TRAIN)) )
                (! (= (= (card@@sl$TRAIN r) 1)
                      (exists ( (x sl$TRAIN) )
                              (and true (= r (mk-set@@sl$TRAIN x)))))
                   :pattern
                   ( (card@@sl$TRAIN r) ))))
(assert (forall ( (r (set sl$BLK))
                  (r0 (set sl$BLK)) )
                (! (=> (= (intersect r r0) empty-set@@sl$BLK)
                       (= (card@@sl$BLK (union r r0))
                          (+ (card@@sl$BLK r) (card@@sl$BLK r0))))
                   :pattern
                   ( (card@@sl$BLK (union r r0)) ))))
(assert (forall ( (r (set sl$LOC))
                  (r0 (set sl$LOC)) )
                (! (=> (= (intersect r r0) empty-set@@sl$LOC)
                       (= (card@@sl$LOC (union r r0))
                          (+ (card@@sl$LOC r) (card@@sl$LOC r0))))
                   :pattern
                   ( (card@@sl$LOC (union r r0)) ))))
(assert (forall ( (r (set sl$TRAIN))
                  (r0 (set sl$TRAIN)) )
                (! (=> (= (intersect r r0) empty-set@@sl$TRAIN)
                       (= (card@@sl$TRAIN (union r r0))
                          (+ (card@@sl$TRAIN r) (card@@sl$TRAIN r0))))
                   :pattern
                   ( (card@@sl$TRAIN (union r r0)) ))))
(assert (= (dom@@sl$TRAIN@@sl$BLK empty-fun@@sl$TRAIN@@sl$BLK)
           empty-set@@sl$TRAIN))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK)) )
                (! (= (ovl@@sl$TRAIN@@sl$BLK f1 empty-fun@@sl$TRAIN@@sl$BLK)
                      f1)
                   :pattern
                   ( (ovl@@sl$TRAIN@@sl$BLK f1 empty-fun@@sl$TRAIN@@sl$BLK) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK)) )
                (! (= (ovl@@sl$TRAIN@@sl$BLK empty-fun@@sl$TRAIN@@sl$BLK f1)
                      f1)
                   :pattern
                   ( (ovl@@sl$TRAIN@@sl$BLK empty-fun@@sl$TRAIN@@sl$BLK f1) ))))
(assert (forall ( (x sl$TRAIN)
                  (y sl$BLK) )
                (! (= (dom@@sl$TRAIN@@sl$BLK (mk-fun@@sl$TRAIN@@sl$BLK x y))
                      (mk-set@@sl$TRAIN x))
                   :pattern
                   ( (dom@@sl$TRAIN@@sl$BLK (mk-fun@@sl$TRAIN@@sl$BLK x y)) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (f2 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN) )
                (! (=> (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f2))
                       (= (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 f2) x)
                          (apply@@sl$TRAIN@@sl$BLK f2 x)))
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 f2) x) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (f2 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN) )
                (! (=> (and (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                            (not (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f2))))
                       (= (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 f2) x)
                          (apply@@sl$TRAIN@@sl$BLK f1 x)))
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 f2) x) ))))
(assert (forall ( (x sl$TRAIN)
                  (y sl$BLK) )
                (! (= (apply@@sl$TRAIN@@sl$BLK (mk-fun@@sl$TRAIN@@sl$BLK x y) x)
                      y)
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (mk-fun@@sl$TRAIN@@sl$BLK x y) x) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (s1 (set sl$TRAIN))
                  (x sl$TRAIN) )
                (! (=> (and (elem@@sl$TRAIN x s1)
                            (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1)))
                       (= (apply@@sl$TRAIN@@sl$BLK (dom-rest@@sl$TRAIN@@sl$BLK s1 f1) x)
                          (apply@@sl$TRAIN@@sl$BLK f1 x)))
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (dom-rest@@sl$TRAIN@@sl$BLK s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (s1 (set sl$TRAIN))
                  (x sl$TRAIN) )
                (! (=> (elem@@sl$TRAIN x
                                       (set-diff@@sl$TRAIN (dom@@sl$TRAIN@@sl$BLK f1) s1))
                       (= (apply@@sl$TRAIN@@sl$BLK (dom-subt@@sl$TRAIN@@sl$BLK s1 f1) x)
                          (apply@@sl$TRAIN@@sl$BLK f1 x)))
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (dom-subt@@sl$TRAIN@@sl$BLK s1 f1) x) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (f2 (pfun sl$TRAIN sl$BLK)) )
                (! (= (dom@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 f2))
                      (union (dom@@sl$TRAIN@@sl$BLK f1)
                             (dom@@sl$TRAIN@@sl$BLK f2)))
                   :pattern
                   ( (dom@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 f2)) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (s1 (set sl$TRAIN)) )
                (! (= (dom@@sl$TRAIN@@sl$BLK (dom-rest@@sl$TRAIN@@sl$BLK s1 f1))
                      (intersect s1 (dom@@sl$TRAIN@@sl$BLK f1)))
                   :pattern
                   ( (dom@@sl$TRAIN@@sl$BLK (dom-rest@@sl$TRAIN@@sl$BLK s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (s1 (set sl$TRAIN)) )
                (! (= (dom@@sl$TRAIN@@sl$BLK (dom-subt@@sl$TRAIN@@sl$BLK s1 f1))
                      (set-diff@@sl$TRAIN (dom@@sl$TRAIN@@sl$BLK f1) s1))
                   :pattern
                   ( (dom@@sl$TRAIN@@sl$BLK (dom-subt@@sl$TRAIN@@sl$BLK s1 f1)) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN)
                  (y sl$BLK) )
                (! (= (and (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                           (= (apply@@sl$TRAIN@@sl$BLK f1 x) y))
                      (= (select f1 x) (Just y)))
                   :pattern
                   ( (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                     (apply@@sl$TRAIN@@sl$BLK f1 x)
                     (select f1 x)
                     (Just y) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN)
                  (x2 sl$TRAIN)
                  (y sl$BLK) )
                (! (=> (not (= x x2))
                       (= (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y))
                                                   x2)
                          (apply@@sl$TRAIN@@sl$BLK f1 x2)))
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y))
                                              x2) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN)
                  (y sl$BLK) )
                (! (= (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y))
                                               x)
                      y)
                   :pattern
                   ( (apply@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y))
                                              x) ))))
(assert (= (ran@@sl$TRAIN@@sl$BLK empty-fun@@sl$TRAIN@@sl$BLK)
           empty-set@@sl$BLK))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (y sl$BLK) )
                (! (= (elem@@sl$BLK y (ran@@sl$TRAIN@@sl$BLK f1))
                      (exists ( (x sl$TRAIN) )
                              (and true
                                   (and (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                                        (= (apply@@sl$TRAIN@@sl$BLK f1 x) y)))))
                   :pattern
                   ( (elem@@sl$BLK y (ran@@sl$TRAIN@@sl$BLK f1)) ))))
(assert (forall ( (x sl$TRAIN)
                  (y sl$BLK) )
                (! (= (ran@@sl$TRAIN@@sl$BLK (mk-fun@@sl$TRAIN@@sl$BLK x y))
                      (mk-set@@sl$BLK y))
                   :pattern
                   ( (ran@@sl$TRAIN@@sl$BLK (mk-fun@@sl$TRAIN@@sl$BLK x y)) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK)) )
                (! (= (injective@@sl$TRAIN@@sl$BLK f1)
                      (forall ( (x sl$TRAIN)
                                (x2 sl$TRAIN) )
                              (=> (and (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                                       (elem@@sl$TRAIN x2 (dom@@sl$TRAIN@@sl$BLK f1)))
                                  (=> (= (apply@@sl$TRAIN@@sl$BLK f1 x)
                                         (apply@@sl$TRAIN@@sl$BLK f1 x2))
                                      (= x x2)))))
                   :pattern
                   ( (injective@@sl$TRAIN@@sl$BLK f1) ))))
(assert (injective@@sl$TRAIN@@sl$BLK empty-fun@@sl$TRAIN@@sl$BLK))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN) )
                (! (=> (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                       (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)
                                     (ran@@sl$TRAIN@@sl$BLK f1)))
                   :pattern
                   ( (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)
                                   (ran@@sl$TRAIN@@sl$BLK f1)) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (s1 (set sl$TRAIN))
                  (x sl$TRAIN) )
                (! (=> (elem@@sl$TRAIN x
                                       (set-diff@@sl$TRAIN (dom@@sl$TRAIN@@sl$BLK f1) s1))
                       (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)
                                     (ran@@sl$TRAIN@@sl$BLK (dom-subt@@sl$TRAIN@@sl$BLK s1 f1))))
                   :pattern
                   ( (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)
                                   (ran@@sl$TRAIN@@sl$BLK (dom-subt@@sl$TRAIN@@sl$BLK s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (s1 (set sl$TRAIN))
                  (x sl$TRAIN) )
                (! (=> (elem@@sl$TRAIN x (intersect (dom@@sl$TRAIN@@sl$BLK f1) s1))
                       (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)
                                     (ran@@sl$TRAIN@@sl$BLK (dom-rest@@sl$TRAIN@@sl$BLK s1 f1))))
                   :pattern
                   ( (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)
                                   (ran@@sl$TRAIN@@sl$BLK (dom-rest@@sl$TRAIN@@sl$BLK s1 f1))) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN)
                  (y sl$BLK) )
                (! (=> (and (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1))
                            (injective@@sl$TRAIN@@sl$BLK f1))
                       (= (ran@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y)))
                          (union (set-diff@@sl$BLK (ran@@sl$TRAIN@@sl$BLK f1)
                                                   (mk-set@@sl$BLK (apply@@sl$TRAIN@@sl$BLK f1 x)))
                                 (mk-set@@sl$BLK y))))
                   :pattern
                   ( (ran@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y))) ))))
(assert (forall ( (f1 (pfun sl$TRAIN sl$BLK))
                  (x sl$TRAIN)
                  (y sl$BLK) )
                (! (=> (not (elem@@sl$TRAIN x (dom@@sl$TRAIN@@sl$BLK f1)))
                       (= (ran@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y)))
                          (union (ran@@sl$TRAIN@@sl$BLK f1) (mk-set@@sl$BLK y))))
                   :pattern
                   ( (ran@@sl$TRAIN@@sl$BLK (ovl@@sl$TRAIN@@sl$BLK f1 (mk-fun@@sl$TRAIN@@sl$BLK x y))) ))))
(assert (forall ( (x sl$BLK)
                  (y sl$BLK) )
                (! (= (elem@@sl$BLK x (mk-set@@sl$BLK y)) (= x y))
                   :pattern
                   ( (elem@@sl$BLK x (mk-set@@sl$BLK y)) ))))
(assert (forall ( (x sl$TRAIN)
                  (y sl$TRAIN) )
                (! (= (elem@@sl$TRAIN x (mk-set@@sl$TRAIN y)) (= x y))
                   :pattern
                   ( (elem@@sl$TRAIN x (mk-set@@sl$TRAIN y)) ))))
(assert (forall ( (s1 (set sl$BLK))
                  (s2 (set sl$BLK)) )
                (! (=> (finite@@sl$BLK s1)
                       (finite@@sl$BLK (set-diff@@sl$BLK s1 s2)))
                   :pattern
                   ( (finite@@sl$BLK (set-diff@@sl$BLK s1 s2)) ))))
(assert (forall ( (s1 (set sl$LOC))
                  (s2 (set sl$LOC)) )
                (! (=> (finite@@sl$LOC s1)
                       (finite@@sl$LOC (set-diff@@sl$LOC s1 s2)))
                   :pattern
                   ( (finite@@sl$LOC (set-diff@@sl$LOC s1 s2)) ))))
(assert (forall ( (s1 (set sl$TRAIN))
                  (s2 (set sl$TRAIN)) )
                (! (=> (finite@@sl$TRAIN s1)
                       (finite@@sl$TRAIN (set-diff@@sl$TRAIN s1 s2)))
                   :pattern
                   ( (finite@@sl$TRAIN (set-diff@@sl$TRAIN s1 s2)) ))))
(assert (forall ( (s1 (set sl$BLK))
                  (s2 (set sl$BLK)) )
                (! (=> (and (finite@@sl$BLK s1) (finite@@sl$BLK s2))
                       (finite@@sl$BLK (union s1 s2)))
                   :pattern
                   ( (finite@@sl$BLK (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$LOC))
                  (s2 (set sl$LOC)) )
                (! (=> (and (finite@@sl$LOC s1) (finite@@sl$LOC s2))
                       (finite@@sl$LOC (union s1 s2)))
                   :pattern
                   ( (finite@@sl$LOC (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$TRAIN))
                  (s2 (set sl$TRAIN)) )
                (! (=> (and (finite@@sl$TRAIN s1) (finite@@sl$TRAIN s2))
                       (finite@@sl$TRAIN (union s1 s2)))
                   :pattern
                   ( (finite@@sl$TRAIN (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$BLK))
                  (s2 (set sl$BLK)) )
                (! (=> (and (finite@@sl$BLK s2) (not (finite@@sl$BLK s1)))
                       (not (finite@@sl$BLK (set-diff@@sl$BLK s1 s2))))
                   :pattern
                   ( (finite@@sl$BLK (set-diff@@sl$BLK s1 s2)) ))))
(assert (forall ( (s1 (set sl$LOC))
                  (s2 (set sl$LOC)) )
                (! (=> (and (finite@@sl$LOC s2) (not (finite@@sl$LOC s1)))
                       (not (finite@@sl$LOC (set-diff@@sl$LOC s1 s2))))
                   :pattern
                   ( (finite@@sl$LOC (set-diff@@sl$LOC s1 s2)) ))))
(assert (forall ( (s1 (set sl$TRAIN))
                  (s2 (set sl$TRAIN)) )
                (! (=> (and (finite@@sl$TRAIN s2) (not (finite@@sl$TRAIN s1)))
                       (not (finite@@sl$TRAIN (set-diff@@sl$TRAIN s1 s2))))
                   :pattern
                   ( (finite@@sl$TRAIN (set-diff@@sl$TRAIN s1 s2)) ))))
(assert (forall ( (x sl$BLK) )
                (! (finite@@sl$BLK (mk-set@@sl$BLK x))
                   :pattern
                   ( (finite@@sl$BLK (mk-set@@sl$BLK x)) ))))
(assert (forall ( (x sl$TRAIN) )
                (! (finite@@sl$TRAIN (mk-set@@sl$TRAIN x))
                   :pattern
                   ( (finite@@sl$TRAIN (mk-set@@sl$TRAIN x)) ))))
(assert (finite@@sl$BLK empty-set@@sl$BLK))
(assert (finite@@sl$LOC empty-set@@sl$LOC))
(assert (finite@@sl$TRAIN empty-set@@sl$TRAIN))
(assert (not (exists ( (in@prime (set sl$TRAIN)) )
                     (and true
                          (= in@prime
                             (set-diff@@sl$TRAIN in (mk-set@@sl$TRAIN t)))))))
; asm2
(assert (and (not (= ent ext))
             (not (elem@@sl$BLK ent PLF))
             (not (elem@@sl$BLK ext PLF))))
; asm3
(assert (forall ( (p sl$BLK) )
                (! (= (not (= p ext))
                      (elem@@sl$BLK p (union (mk-set@@sl$BLK ent) PLF)))
                   :pattern
                   ( (elem@@sl$BLK p (union (mk-set@@sl$BLK ent) PLF)) ))))
; asm4
(assert (forall ( (p sl$BLK) )
                (! (= (not (= p ent))
                      (elem@@sl$BLK p (union (mk-set@@sl$BLK ext) PLF)))
                   :pattern
                   ( (elem@@sl$BLK p (union (mk-set@@sl$BLK ext) PLF)) ))))
; asm5
(assert (forall ( (p sl$BLK) )
                (! (= (or (= p ent) (= p ext))
                      (not (elem@@sl$BLK p PLF)))
                   :pattern
                   ( (elem@@sl$BLK p PLF) ))))
; axm0
(assert (= sl$BLK
           (union (union (mk-set@@sl$BLK ent) (mk-set@@sl$BLK ext))
                  PLF)))
; c0
(assert (elem@@sl$TRAIN t in))
; grd0
(assert (and (= (apply@@sl$TRAIN@@sl$BLK loc t) ext)
             (elem@@sl$TRAIN t in)))
; inv1
(assert (forall ( (t sl$TRAIN) )
                (! (=> (elem@@sl$TRAIN t in)
                       (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK loc t) sl$BLK))
                   :pattern
                   ( (elem@@sl$BLK (apply@@sl$TRAIN@@sl$BLK loc t) sl$BLK) ))))
; inv2
(assert (= (dom@@sl$TRAIN@@sl$BLK loc) in))
(assert (not true))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; train0/leave/FIS/in@prime
