; m3/visit/INV/m3:inv0
(set-option :auto-config false)
(set-option :smt.timeout 3000)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes () ( (Null null) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(define-sort guarded (a) (Maybe a))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort sl$Pcs 0)
; comment: we don't need to declare the sort Real
(define-sort set (a) (Array a Bool))
(declare-const b Bool)
(declare-const b@prime Bool)
(declare-const c Int)
(declare-const c@prime Int)
(declare-const cs (set sl$Pcs))
(declare-const cs@prime (set sl$Pcs))
(declare-const fs (set sl$Pcs))
(declare-const fs@prime (set sl$Pcs))
(declare-const n Int)
(declare-const n@prime Int)
(declare-const p sl$Pcs)
(declare-const ts (set sl$Pcs))
(declare-const ts@prime (set sl$Pcs))
(declare-const vs (set sl$Pcs))
(declare-const vs@prime (set sl$Pcs))
(declare-fun card@@Int ( (set Int) ) Int)
(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)
(declare-fun const@@sl$Pcs@@Int (Int) (Array sl$Pcs Int))
(declare-fun finite@@Int ( (set Int) ) Bool)
(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@sl$Pcs (sl$Pcs) (set sl$Pcs))
(declare-fun qsum@@sl$Pcs
             ( (set sl$Pcs)
               (Array sl$Pcs Int) )
             Int)
(declare-fun set@@sl$Pcs@@Int
             ( (set sl$Pcs)
               (Array sl$Pcs Int) )
             (set Int))
(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))
(define-fun all@@sl$Pcs
            ()
            (set sl$Pcs)
            ( (as const (set sl$Pcs))
              true ))
(define-fun compl@@Int
            ( (s1 (set Int)) )
            (set Int)
            ( (_ map not)
              s1 ))
(define-fun compl@@sl$Pcs
            ( (s1 (set sl$Pcs)) )
            (set sl$Pcs)
            ( (_ map not)
              s1 ))
(define-fun elem@@Int
            ( (x Int)
              (s1 (set Int)) )
            Bool
            (select s1 x))
(define-fun elem@@sl$Pcs
            ( (x sl$Pcs)
              (s1 (set sl$Pcs)) )
            Bool
            (select s1 x))
(define-fun empty-set@@Int
            ()
            (set Int)
            ( (as const (set Int))
              false ))
(define-fun empty-set@@sl$Pcs
            ()
            (set sl$Pcs)
            ( (as const (set sl$Pcs))
              false ))
(define-fun set-diff@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            (set Int)
            (intersect s1 ( (_ map not) s2 )))
(define-fun set-diff@@sl$Pcs
            ( (s1 (set sl$Pcs))
              (s2 (set sl$Pcs)) )
            (set sl$Pcs)
            (intersect s1 ( (_ map not) s2 )))
(define-fun st-subset@@Int
            ( (s1 (set Int))
              (s2 (set Int)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun st-subset@@sl$Pcs
            ( (s1 (set sl$Pcs))
              (s2 (set sl$Pcs)) )
            Bool
            (and (subset s1 s2) (not (= s1 s2))))
(define-fun sl$Pcs
            ()
            (set sl$Pcs)
            ( (as const (set sl$Pcs))
              true ))
(assert (forall ( (term (Array sl$Pcs Int)) )
                (! (= (qsum@@sl$Pcs empty-set@@sl$Pcs term) 0)
                   :pattern
                   ( (qsum@@sl$Pcs empty-set@@sl$Pcs term) ))))
(assert (forall ( (r (set sl$Pcs))
                  (term (Array sl$Pcs Int))
                  (x sl$Pcs) )
                (! (=> (not (elem@@sl$Pcs x r))
                       (= (qsum@@sl$Pcs (union r (mk-set@@sl$Pcs x)) term)
                          (+ (qsum@@sl$Pcs r term) (select term x))))
                   :pattern
                   ( (qsum@@sl$Pcs (union r (mk-set@@sl$Pcs x)) term) ))))
(assert (forall ( (r (set sl$Pcs))
                  (r0 (set sl$Pcs))
                  (term (Array sl$Pcs Int)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)
                       (= (qsum@@sl$Pcs (union r r0) term)
                          (+ (qsum@@sl$Pcs r term) (qsum@@sl$Pcs r0 term))))
                   :pattern
                   ( (qsum@@sl$Pcs (union r r0) term) ))))
(assert (forall ( (r (set Int)) )
                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))
                   :pattern
                   ( (<= 0 (card@@Int r)) ))))
(assert (forall ( (r (set sl$Pcs)) )
                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))
                   :pattern
                   ( (<= 0 (card@@sl$Pcs r)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set sl$Pcs)) )
                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))
                   :pattern
                   ( (card@@sl$Pcs r) ))))
(assert (forall ( (x Int) )
                (! (= (card@@Int (mk-set@@Int x)) 1)
                   :pattern
                   ( (card@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x sl$Pcs) )
                (! (= (card@@sl$Pcs (mk-set@@sl$Pcs x)) 1)
                   :pattern
                   ( (card@@sl$Pcs (mk-set@@sl$Pcs x)) ))))
(assert (forall ( (r (set Int)) )
                (! (= (= (card@@Int r) 1)
                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))
                   :pattern
                   ( (card@@Int r) ))))
(assert (forall ( (r (set sl$Pcs)) )
                (! (= (= (card@@sl$Pcs r) 1)
                      (exists ( (x sl$Pcs) ) (and true (= r (mk-set@@sl$Pcs x)))))
                   :pattern
                   ( (card@@sl$Pcs r) ))))
(assert (forall ( (r (set Int))
                  (r0 (set Int)) )
                (! (=> (= (intersect r r0) empty-set@@Int)
                       (= (card@@Int (union r r0))
                          (+ (card@@Int r) (card@@Int r0))))
                   :pattern
                   ( (card@@Int (union r r0)) ))))
(assert (forall ( (r (set sl$Pcs))
                  (r0 (set sl$Pcs)) )
                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)
                       (= (card@@sl$Pcs (union r r0))
                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))
                   :pattern
                   ( (card@@sl$Pcs (union r r0)) ))))
(assert (forall ( (r (set sl$Pcs)) )
                (! (= (card@@sl$Pcs r)
                      (qsum@@sl$Pcs r (const@@sl$Pcs@@Int 1)))
                   :pattern
                   ( (card@@sl$Pcs r) ))))
(assert (forall ( (x Int)
                  (y sl$Pcs) )
                (! (= (select (const@@sl$Pcs@@Int x) y) x)
                   :pattern
                   ( (select (const@@sl$Pcs@@Int x) y) ))))
(assert (forall ( (x Int)
                  (y Int) )
                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))
                   :pattern
                   ( (elem@@Int x (mk-set@@Int y)) ))))
(assert (forall ( (x sl$Pcs)
                  (y sl$Pcs) )
                (! (= (elem@@sl$Pcs x (mk-set@@sl$Pcs y)) (= x y))
                   :pattern
                   ( (elem@@sl$Pcs x (mk-set@@sl$Pcs y)) ))))
(assert (forall ( (r1 (set sl$Pcs))
                  (term (Array sl$Pcs Int))
                  (y Int) )
                (! (= (elem@@Int y (set@@sl$Pcs@@Int r1 term))
                      (exists ( (x sl$Pcs) )
                              (and (elem@@sl$Pcs x r1) (= (select term x) y))))
                   :pattern
                   ( (elem@@Int y (set@@sl$Pcs@@Int r1 term)) ))))
(assert (forall ( (r1 (set sl$Pcs))
                  (term (Array sl$Pcs Int))
                  (y Int) )
                (! (= (= (set@@sl$Pcs@@Int r1 term) (mk-set@@Int y))
                      (forall ( (x sl$Pcs) )
                              (=> (elem@@sl$Pcs x r1) (= (select term x) y))))
                   :pattern
                   ( (set@@sl$Pcs@@Int r1 term)
                     (mk-set@@Int y) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (finite@@Int s1)
                       (finite@@Int (set-diff@@Int s1 s2)))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set sl$Pcs))
                  (s2 (set sl$Pcs)) )
                (! (=> (finite@@sl$Pcs s1)
                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))
                   :pattern
                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s1) (finite@@Int s2))
                       (finite@@Int (union s1 s2)))
                   :pattern
                   ( (finite@@Int (union s1 s2)) ))))
(assert (forall ( (s1 (set sl$Pcs))
                  (s2 (set sl$Pcs)) )
                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))
                       (finite@@sl$Pcs (union s1 s2)))
                   :pattern
                   ( (finite@@sl$Pcs (union s1 s2)) ))))
(assert (forall ( (s1 (set Int))
                  (s2 (set Int)) )
                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))
                       (not (finite@@Int (set-diff@@Int s1 s2))))
                   :pattern
                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))
(assert (forall ( (s1 (set sl$Pcs))
                  (s2 (set sl$Pcs)) )
                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))
                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))
                   :pattern
                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))
(assert (forall ( (x Int) )
                (! (finite@@Int (mk-set@@Int x))
                   :pattern
                   ( (finite@@Int (mk-set@@Int x)) ))))
(assert (forall ( (x sl$Pcs) )
                (! (finite@@sl$Pcs (mk-set@@sl$Pcs x))
                   :pattern
                   ( (finite@@sl$Pcs (mk-set@@sl$Pcs x)) ))))
(assert (finite@@Int empty-set@@Int))
(assert (finite@@sl$Pcs empty-set@@sl$Pcs))
; SKIP:b
(assert (= b@prime b))
; SKIP:c
(assert (= c@prime c))
; SKIP:cs
(assert (= cs@prime cs))
; SKIP:fs
(assert (= fs@prime fs))
; SKIP:n
(assert (= n@prime n))
; SKIP:ts
(assert (= ts@prime ts))
; act1
(assert (= vs@prime (union vs (mk-set@@sl$Pcs p))))
; asm0
(assert (finite@@sl$Pcs sl$Pcs))
; inv0
(assert (=> b (= vs sl$Pcs)))
; inv1
(assert (subset ts vs))
; inv2
(assert (subset cs vs))
; m3:inv0
(assert (= c (card@@sl$Pcs cs)))
; m3:inv1
(assert (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1))))
; m3:inv2
(assert (finite@@sl$Pcs ts))
; m3:inv5
(assert (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1))))
; m3:inv6
(assert (= (intersect ts cs) empty-set@@sl$Pcs))
; m3:inv7
(assert (= fs (union ts cs)))
; thm0
(assert (= (= n (card@@sl$Pcs sl$Pcs)) (= ts sl$Pcs)))
(assert (not (= c@prime (card@@sl$Pcs cs@prime))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))
; m3/visit/INV/m3:inv0
