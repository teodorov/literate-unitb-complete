{-# LANGUAGE OverloadedStrings #-}
module Language.UnitB.Parser.Tests.Puzzle where

    -- Modules
import Language.UnitB.Parser.Tests.Suite

import Logic.Expr
import Logic.Proof

    -- Library
import Control.Lens
import Control.Precondition ((!))

import Data.List as L
import Data.Map hiding ((!))
import Data.Set  as S (Set,fromList)
import           Data.Text (Text)
import qualified Data.Text as T

import Test.UnitTest

test_case :: TestCase
test_case = test_cases 
        "The king and his advisors puzzle"
        [ poCase "puzzle, m0" case0 result0
        , poCase "puzzle, m1" case1 result1
        , textCase "puzzle, proof obligation" case2 result2
        , textCase "puzzle, visit enablement, PO" case4 result4
        , textCase "puzzle, visit negation, PO" case5 result5
        -- , aCase "puzzle, remove default with weakento" case6 result6
        , poCase "puzzle, m2" case7 result7
        -- , poCase "puzzle, m3" case8 result8
        , textCase "puzzle m3, wd of sums" case9 result9
        , textCase "puzzle m3, proofs with sums" case10 result10
        , poCase "puzzle, m4" case11 result11
        , aCase "puzzle, deleted variables, m3" case12 result12
        , aCase "puzzle, deleted variables, m4" case13 result13
        , textCase "puzzle, error: invariant referring to deleted variable" case14 result14
        , textCase "puzzle, error: assignment to deleted variable" case15 result15
        , aCase "test 16, puzzle, removing actions, m3" case16 result16
        , aCase "test 17, puzzle, removed actions, m4" case17 result17
        , textCase "test 18, simulation proof obligation" case18 result18
        , textCase "test 19, simulation proof obligation (init)" case19 result19
        , textCase "test 20, crashing proof obligation of invariant with witness" case20 result20
        , textCase "test 21, deleting non-existant action" case21 result21
        , textCase "test 30, duplicate declarations" case30 result30
        , textCase "test 22, error providing a witness for non-deleted variable" case22 result22
        , textCase "test 23, error deleting non-existant variable" case23 result23
        , aCase "test 24, inherited vs local invariants" case24 result24
        , textCase "test 25, error: schedules and guards refer to deleted variables" case25 result25
        , aCase "test 27, old guards / new guards" case27 result27
        , textCase "test 28, illegal type application" case28 result28
        , textCase "test 29, theorem well-definedness" case29 result29
        ]

path0 :: FilePath
path0 = [path|Tests/puzzle/puzzle.tex|]

case0 :: IO (Text, Map Label Sequent)
case0 = verify path0 0

result0 :: Output
result0 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result0.txt"
    T.unlines
    [ "  o  m0/LIVE/prog0/ensure/TR/term/NEG"
    , "passed 1 / 1"
    ]

case1 :: IO (Text, Map Label Sequent)
case1 = verify path0 1

result1 :: Output
result1 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result1.txt"
    T.unlines
    [ "  o  m1/INIT/INV/inv0"
    , "  o  m1/LIVE/prog3/ensure/TR/WFIS/p/p@prime"
    , "  o  m1/LIVE/prog3/ensure/TR/visit/NEG"
    , "  o  m1/prog1/LIVE/induction/lhs"
    , "  o  m1/prog1/LIVE/induction/rhs"
    , "  o  m1/prog2/LIVE/PSP/lhs"
    , "  o  m1/prog2/LIVE/PSP/rhs"
    , "  o  m1/term/C_SCH/delay/0/prog/prog1/rhs/sch1"
    , "  o  m1/term/C_SCH/delay/0/saf/visit/SAF/term"
    , "  o  m1/term/INV/inv0"
    , "  o  m1/term/SAF/LIVE/prog3/ensure"
    , "  o  m1/term/SAF/saf1"
    , "  o  m1/term/SAF/saf2"
    , "  o  m1/term/SCH/grd0"
    , "  o  m1/visit/INV/inv0"
    , "  o  m1/visit/SAF/LIVE/prog3/ensure"
    , "  o  m1/visit/SAF/saf1"
    , "  o  m1/visit/SAF/saf2"
    , "passed 18 / 18"
    ]

case2 :: IO Text
case2 = proof_obligation path0 "m1/prog1/LIVE/induction/rhs" 1

result2 :: Output
result2 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result2.txt"
    T.unlines
    [ "; m1/prog1/LIVE/induction/rhs"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl$Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-const vs@prime (set sl$Pcs))"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "(assert (not (forall ( (V (set sl$Pcs)) )"
    , "                     (=> true"
    , "                         (=> (or (st-subset@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                                 (= vs sl$Pcs))"
    , "                             (or (and (subset (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                                      (subset empty-set@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs))"
    , "                                      (finite@@sl$Pcs (set-diff@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs) empty-set@@sl$Pcs)))"
    , "                                 (= vs sl$Pcs)))))))"
    , "(assert (not (=> (or (st-subset@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                     (= vs sl$Pcs))"
    , "                 (or (and (subset (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                          (subset empty-set@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs))"
    , "                          (finite@@sl$Pcs (set-diff@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs) empty-set@@sl$Pcs)))"
    , "                     (= vs sl$Pcs)))))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl$Pcs)))"
    , "(assert (not (=> (st-subset@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                 (and (subset (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                      (subset empty-set@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs))"
    , "                      (finite@@sl$Pcs (set-diff@@sl$Pcs (set-diff@@sl$Pcs sl$Pcs vs) empty-set@@sl$Pcs))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/prog1/LIVE/induction/rhs"
    ]

case4 :: IO Text
case4 = proof_obligation path0 "m1/LIVE/prog3/ensure/TR/visit/EN" 1

result4 :: Output
result4 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result4.txt"
    T.unlines
    [ "invalid label: m1/LIVE/prog3/ensure/TR/visit/EN"
    , "m1/INIT/INV/inv0"
    , "m1/LIVE/prog3/ensure/TR/WFIS/p/p@prime"
    , "m1/LIVE/prog3/ensure/TR/visit/NEG"
    , "m1/prog1/LIVE/induction/lhs"
    , "m1/prog1/LIVE/induction/rhs"
    , "m1/prog2/LIVE/PSP/lhs"
    , "m1/prog2/LIVE/PSP/rhs"
    , "m1/term/C_SCH/delay/0/prog/prog1/rhs/sch1"
    , "m1/term/C_SCH/delay/0/saf/visit/SAF/term"
    , "m1/term/INV/inv0"
    , "m1/term/SAF/LIVE/prog3/ensure"
    , "m1/term/SAF/saf1"
    , "m1/term/SAF/saf2"
    , "m1/term/SCH/grd0"
    , "m1/visit/INV/inv0"
    , "m1/visit/SAF/LIVE/prog3/ensure"
    , "m1/visit/SAF/saf1"
    , "m1/visit/SAF/saf2"
    ]

case5 :: IO Text
case5 = proof_obligation path0 "m1/LIVE/prog3/ensure/TR/visit/NEG" 1

result5 :: Output
result5 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result5.txt"
    T.unlines
    [ "; m1/LIVE/prog3/ensure/TR/visit/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl$Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-const vs@prime (set sl$Pcs))"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl$Pcs (sl$Pcs) (set sl$Pcs))"
    , "(declare-fun p@param () sl$Pcs)"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl$Pcs"
    , "            ( (x sl$Pcs)"
    , "              (s1 (set sl$Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x sl$Pcs) )"
    , "                (! (= (card@@sl$Pcs (mk-set@@sl$Pcs x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (mk-set@@sl$Pcs x)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 1)"
    , "                      (exists ( (x sl$Pcs) ) (and true (= r (mk-set@@sl$Pcs x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (x sl$Pcs)"
    , "                  (y sl$Pcs) )"
    , "                (! (= (elem@@sl$Pcs x (mk-set@@sl$Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Pcs x (mk-set@@sl$Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (x sl$Pcs) )"
    , "                (! (finite@@sl$Pcs (mk-set@@sl$Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (mk-set@@sl$Pcs x)) ))))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "(assert (not (elem@@sl$Pcs p@param vs)))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; act1"
    , "(assert (= vs@prime (union vs (mk-set@@sl$Pcs p@param))))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl$Pcs)))"
    , "(assert (not (=> (and (= (set-diff@@sl$Pcs sl$Pcs vs) V)"
    , "                      (not (= vs sl$Pcs))"
    , "                      (= (set-diff@@sl$Pcs sl$Pcs vs) V))"
    , "                 (not (and (= (set-diff@@sl$Pcs sl$Pcs vs@prime) V)"
    , "                           (not (= vs@prime sl$Pcs))"
    , "                           (= (set-diff@@sl$Pcs sl$Pcs vs@prime) V))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/prog3/ensure/TR/visit/NEG"
    ]

-- case6 :: IO Text
-- case6 = proof_obligation path0 "m1/visit/SCH/0/REF/weaken" 1

-- result6 :: Text
-- result6 = T.unlines
    -- [ "; m1/visit/SCH/0/REF/weaken"
    -- , "(set-option :auto-config false)"
    -- , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    -- , "(declare-datatypes () ( (Null null) ))"
    -- , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    -- , "; comment: we don't need to declare the sort Bool"
    -- , "; comment: we don't need to declare the sort Int"
    -- , "(declare-sort sl$Pcs 0)"
    -- , "; comment: we don't need to declare the sort Real"
    -- , "(define-sort set (a) (Array a Bool))"
    -- , "(declare-const b Bool)"
    -- , "(declare-const b@prime Bool)"
    -- , "(declare-const vs (set sl$Pcs))"
    -- , "(declare-const vs@prime (set sl$Pcs))"
    -- , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    -- , "(define-fun sl$Pcs"
    -- , "            ()"
    -- , "            (set sl$Pcs)"
    -- , "            ( (as const (set sl$Pcs))"
    -- , "              true ))"
    -- , "(define-fun compl@@sl$Pcs"
    -- , "            ( (s1 (set sl$Pcs)) )"
    -- , "            (set sl$Pcs)"
    -- , "            ( (_ map not)"
    -- , "              s1 ))"
    -- , "(define-fun empty-set@@sl$Pcs"
    -- , "            ()"
    -- , "            (set sl$Pcs)"
    -- , "            ( (as const (set sl$Pcs))"
    -- , "              false ))"
    -- , "(define-fun set-diff@@sl$Pcs"
    -- , "            ( (s1 (set sl$Pcs))"
    -- , "              (s2 (set sl$Pcs)) )"
    -- , "            (set sl$Pcs)"
    -- , "            (intersect s1 ( (_ map not) s2 )))"
    -- , "(define-fun st-subset@@sl$Pcs"
    -- , "            ( (s1 (set sl$Pcs))"
    -- , "              (s2 (set sl$Pcs)) )"
    -- , "            Bool"
    -- , "            (and (subset s1 s2) (not (= s1 s2))))"
    -- , "(assert (forall ( (s1 (set sl$Pcs))"
    -- , "                  (s2 (set sl$Pcs)) )"
    -- , "                (! (=> (finite@@sl$Pcs s1)"
    -- , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    -- , "                   :pattern"
    -- , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    -- , "(assert (forall ( (s1 (set sl$Pcs))"
    -- , "                  (s2 (set sl$Pcs)) )"
    -- , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    -- , "                       (finite@@sl$Pcs (union s1 s2)))"
    -- , "                   :pattern"
    -- , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    -- , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    -- , "; asm0"
    -- , "(assert (finite@@sl$Pcs sl$Pcs))"
    -- , "; inv0"
    -- , "(assert (=> b (= vs sl$Pcs)))"
    -- , "(assert (not true))"
    -- , "(check-sat-using (or-else (then qe smt)"
    -- , "                          (then simplify smt)"
    -- , "                          (then skip smt)"
    -- , "                          (then (using-params simplify :expand-power true) smt)))"
    -- , "; m1/visit/SCH/0/REF/weaken"
    -- ]

case7 :: IO (Text, Map Label Sequent)
case7 = verify path0 2

result7 :: Output
result7 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result7.txt"
    T.unlines
    [ "  o  m2/INIT/INV/inv1"
    , "  o  m2/INIT/INV/inv2"
    , "  o  m2/LIVE/prog10/ensure/TR/count/EN"
    , "  o  m2/LIVE/prog10/ensure/TR/count/NEG"
    , "  o  m2/LIVE/prog11/ensure/TR/WFIS/p/p@prime"
    , "  o  m2/LIVE/prog11/ensure/TR/visit/NEG"
    , "  o  m2/LIVE/prog6/ensure/TR/WFIS/p/p@prime"
    , "  o  m2/LIVE/prog6/ensure/TR/flick/EN"
    , "  o  m2/LIVE/prog6/ensure/TR/flick/NEG"
    , "  o  m2/LIVE/prog7/ensure/TR/count/EN"
    , "  o  m2/LIVE/prog7/ensure/TR/count/NEG"
    , "  o  m2/count/INV/inv1"
    , "  o  m2/count/INV/inv2"
    , "  o  m2/count/SAF/LIVE/prog11/ensure"
    , "  o  m2/count/SAF/LIVE/prog6/ensure"
    , "  o  m2/count/SAF/LIVE/prog7/ensure"
    , "  o  m2/count/SAF/saf3"
    , "  o  m2/count/SAF/saf8"
    , "  o  m2/flick/INV/inv1"
    , "  o  m2/flick/INV/inv2"
    , "  o  m2/flick/SAF/LIVE/prog11/ensure"
    , "  o  m2/flick/SAF/LIVE/prog6/ensure"
    , "  o  m2/flick/SAF/LIVE/prog7/ensure"
    , "  o  m2/flick/SAF/saf3"
    , "  o  m2/flick/SAF/saf8"
    , "  o  m2/flick/SCH/grd0"
    , "  o  m2/flick/SCH/grd1"
    , "  o  m2/prog4/LIVE/transitivity/mhs/0/1"
    , "  o  m2/prog4/LIVE/transitivity/rhs"
    , "  o  m2/prog5/LIVE/PSP/lhs"
    , "  o  m2/prog5/LIVE/PSP/rhs"
    , "  o  m2/prog8/LIVE/transitivity/lhs"
    , "  o  m2/prog8/LIVE/transitivity/mhs/0/1"
    , "  o  m2/prog8/LIVE/transitivity/mhs/1/2"
    , "  o  m2/prog8/LIVE/transitivity/rhs"
    , "  o  m2/prog9/LIVE/induction/lhs"
    , "  o  m2/prog9/LIVE/induction/rhs"
    , "  o  m2/term/C_SCH/delay/0/prog/prog4/rhs/sch2"
    , "  o  m2/term/C_SCH/delay/0/saf/count/SAF/term"
    , "  o  m2/term/C_SCH/delay/0/saf/flick/SAF/term"
    , "  o  m2/term/C_SCH/delay/0/saf/visit/SAF/term"
    , "  o  m2/term/GRD/str/sch1"
    , "  o  m2/term/INV/inv1"
    , "  o  m2/term/INV/inv2"
    , "  o  m2/term/SAF/LIVE/prog11/ensure"
    , "  o  m2/term/SAF/LIVE/prog6/ensure"
    , "  o  m2/term/SAF/LIVE/prog7/ensure"
    , "  o  m2/term/SAF/saf3"
    , "  o  m2/term/SAF/saf8"
    , "  o  m2/term/SCH/grd0"
    , "  o  m2/visit/INV/inv1"
    , "  o  m2/visit/INV/inv2"
    , "  o  m2/visit/SAF/LIVE/prog11/ensure"
    , "  o  m2/visit/SAF/LIVE/prog6/ensure"
    , "  o  m2/visit/SAF/LIVE/prog7/ensure"
    , "  o  m2/visit/SAF/saf3"
    , "  o  m2/visit/SAF/saf8"
    , "passed 57 / 57"
    ]

case8 :: IO (Text, Map Label Sequent)
case8 = verify path0 3

result8 :: Output
result8 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result8.txt"
    T.unlines 
    [ "  o  m3/INIT/INV/m3:inv0"
    , "  o  m3/INIT/INV/m3:inv1"
    , "  o  m3/INIT/INV/m3:inv2"
    , "  o  m3/INIT/INV/m3:inv5"
    , "  o  m3/INIT/INV/m3:inv6"
    , "  o  m3/INIT/INV/m3:inv7"
    , "  o  m3/INIT/SIM/in1"
    , "  o  m3/INIT/SIM/in2"
    , "  o  m3/INIT/WFIS/cs"
    , "  o  m3/INIT/WFIS/ts"
    , "  o  m3/INV/WD"
    , "  o  m3/THM/WD"
    , "  o  m3/THM/thm0/goal"
    , "  o  m3/THM/thm0/hypotheses"
    , "  o  m3/THM/thm0/relation"
    , "  o  m3/THM/thm0/step 1"
    , "  o  m3/THM/thm0/step 2"
    , "  o  m3/THM/thm0/step 3"
    , "  o  m3/THM/thm0/step 4"
    , "  o  m3/THM/thm0/step 5"
    , "  o  m3/THM/thm0/step 6"
    , "  o  m3/count/C_SCH/weaken/sch1"
    , "  o  m3/count/GRD/str/sch0"
    , "  o  m3/count/INV/m3:inv0"
    , "  o  m3/count/INV/m3:inv1"
    , "  o  m3/count/INV/m3:inv2"
    , "  o  m3/count/INV/m3:inv5"
    , "  o  m3/count/INV/m3:inv6"
    , "  o  m3/count/INV/m3:inv7"
    , "  o  m3/count/SCH/m3:grd0"
    , "  o  m3/count/SIM/act0"
    , "  o  m3/count/SIM/act1"
    , "  o  m3/count/WFIS/cs@prime"
    , "  o  m3/count/WFIS/ts@prime"
    , "  o  m3/flick/C_SCH/weaken/m3:csch1"
    , "  o  m3/flick/C_SCH/weaken/m3:csch2"
    , "  o  m3/flick/GRD/str/grd0"
    , "  o  m3/flick/GRD/str/sch0"
    , "  o  m3/flick/GRD/str/sch1"
    , "  o  m3/flick/INV/m3:inv0"
    , "  o  m3/flick/INV/m3:inv1"
    , "  o  m3/flick/INV/m3:inv2"
    , "  o  m3/flick/INV/m3:inv5"
    , "  o  m3/flick/INV/m3:inv6"
    , "  o  m3/flick/INV/m3:inv7"
    , "  o  m3/flick/SCH/grd1"
    , "  o  m3/flick/SCH/m3:grd1"
    , "  o  m3/flick/SCH/m3:grd2"
    , "  o  m3/flick/SIM/act0"
    , "  o  m3/flick/WFIS/cs@prime"
    , "  o  m3/term/C_SCH/weaken/sch3"
    , "  o  m3/term/GRD/str/sch2"
    , "  o  m3/term/INV/m3:inv0"
    , "  o  m3/term/INV/m3:inv1"
    , "  o  m3/term/INV/m3:inv2"
    , "  o  m3/term/INV/m3:inv5"
    , "  o  m3/term/INV/m3:inv6"
    , "  o  m3/term/INV/m3:inv7"
    , "  o  m3/term/SCH/grd0"
    , "  o  m3/term/WD/C_SCH"
    , "  o  m3/visit/INV/m3:inv0"
    , "  o  m3/visit/INV/m3:inv1"
    , "  o  m3/visit/INV/m3:inv2"
    , "  o  m3/visit/INV/m3:inv5"
    , "  o  m3/visit/INV/m3:inv6"
    , "  o  m3/visit/INV/m3:inv7"
    , "passed 66 / 66"
    ]

case9 :: IO Text
case9 = proof_obligation path0 "m3/INV/WD" 3

result9 :: Output
result9 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result9.txt"
    T.unlines
    [ "; m3/INV/WD"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl$Pcs))"
    , "(declare-const fs (set sl$Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl$Pcs))"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun const@@sl$Pcs@@Int (Int) (Array sl$Pcs Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(declare-fun ident@@sl$Pcs () (Array sl$Pcs sl$Pcs))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun qsum@@sl$Pcs"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl$Pcs@@Int"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             (set Int))"
    , "(declare-fun set@@sl$Pcs@@sl$Pcs"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs sl$Pcs) )"
    , "             (set sl$Pcs))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl$Pcs Int)) )"
    , "                (! (= (qsum@@sl$Pcs empty-set@@sl$Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs empty-set@@sl$Pcs term) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (qsum@@sl$Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl$Pcs r term) (qsum@@sl$Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (card@@sl$Pcs r)"
    , "                      (qsum@@sl$Pcs r (const@@sl$Pcs@@Int 1)))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "(assert (forall ( (r1 (set sl$Pcs)) )"
    , "                (! (= (set@@sl$Pcs@@sl$Pcs r1 ident@@sl$Pcs) r1)"
    , "                   :pattern"
    , "                   ( (set@@sl$Pcs@@sl$Pcs r1 ident@@sl$Pcs) ))))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl$Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "(assert (not (=> (and (finite@@sl$Pcs ts)"
    , "                      (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1)))"
    , "                      (= (intersect ts cs) empty-set@@sl$Pcs)"
    , "                      (= fs (union ts cs)))"
    , "                 (or (and (= c (card@@sl$Pcs cs))"
    , "                          (finite@@sl$Pcs cs)"
    , "                          (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1)))"
    , "                          (finite@@sl$Pcs (set@@sl$Pcs@@sl$Pcs ts ident@@sl$Pcs)))"
    , "                     (and (not (= c (card@@sl$Pcs cs))) (finite@@sl$Pcs cs))"
    , "                     (and (not (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1))))"
    , "                          (finite@@sl$Pcs (set@@sl$Pcs@@sl$Pcs ts ident@@sl$Pcs)))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INV/WD"
    ]

case10 :: IO Text
case10 = proof_obligation path0 "m3/INIT/INV/m3:inv1" 3

result10 :: Output
result10 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result10.txt"
    T.unlines
    [ "; m3/INIT/INV/m3:inv1"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl$Pcs))"
    , "(declare-const fs (set sl$Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl$Pcs))"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun const@@sl$Pcs@@Int (Int) (Array sl$Pcs Int))"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(declare-fun qsum@@sl$Pcs"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             Int)"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl$Pcs Int)) )"
    , "                (! (= (qsum@@sl$Pcs empty-set@@sl$Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs empty-set@@sl$Pcs term) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (qsum@@sl$Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl$Pcs r term) (qsum@@sl$Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (card@@sl$Pcs r)"
    , "                      (qsum@@sl$Pcs r (const@@sl$Pcs@@Int 1)))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; cs"
    , "(assert (= cs empty-set@@sl$Pcs))"
    , "; in0"
    , "(assert (= b false))"
    , "; m3:in0"
    , "(assert (= c 0))"
    , "; m3:in1"
    , "(assert (= n 0))"
    , "; m3:in2"
    , "(assert (= fs empty-set@@sl$Pcs))"
    , "; ts"
    , "(assert (= ts empty-set@@sl$Pcs))"
    , "(assert (not (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INIT/INV/m3:inv1"
    ]

case11 :: IO (Text, Map Label Sequent)
case11 = verify path0 4

result11 :: Output
result11 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result11.txt"
    T.unlines
    [ "passed 0 / 0"
    ]

case12 :: IO (Either [Error] (Set Name,Set Name,Set Name))
case12 = runEitherT $ do
    m <- EitherT $ parse_machine path0 3
    return ( keysSet $ m!.abs_vars
           , keysSet $ m!.del_vars
           , keysSet $ m!.variables)

result12 :: Either [Error] (Set Name,Set Name,Set Name)
result12 = Right $ ( ["b","cs","ts","vs"]
                   , ["cs","ts"]
                   , ["b","vs","n","c","fs"])
                 & each %~ (S.fromList . L.map fromString'')

case13 :: IO (Either [Error] (Set Name,Set Name,Set Name))
case13 = runEitherT $ do
    m <- EitherT $ parse_machine path0 4
    return ( keysSet $ m!.abs_vars
           , keysSet $ m!.del_vars
           , keysSet $ m!.variables)

result13 :: Either [Error] (Set Name,Set Name,Set Name)
result13 = Right $ ( ["b","vs","n","c","fs"]
                   , ["cs","ts"]
                   , ["b","vs","n","c","fs"])
                 & each %~ (S.fromList . L.map fromString'')

path14 :: FilePath
path14 = [path|Tests/puzzle/puzzle-err0.tex|]

case14 :: IO Text
case14 = find_errors path14

result14 :: Output
result14 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result14.txt"
    T.unlines
        [ "error 225:24:"
        , "    unrecognized term: cs"
        , "Perhaps you meant:"
        , "c (variable)"
        , "ts (variable)"
        , "vs (variable)"
        , "\\Pcs (variable)"
        ]

path15 :: FilePath
path15 = [path|Tests/puzzle/puzzle-err1.tex|]

case15 :: IO Text
case15 = find_errors path15

result15 :: Output
result15 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result15.txt"
    T.unlines
    [ "In 'm3', event 'count', action 'act0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 179:2:"
    , "\taction 'act0'"
    , ""
    , ""
    , "In 'm3', event 'count', action 'act1' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 180:2:"
    , "\taction 'act1'"
    , ""
    , ""
    , "In 'm3', event 'count', coarse schedule 'sch0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 176:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "In 'm3', event 'flick', action 'act0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 163:2:"
    , "\taction 'act0'"
    , ""
    , ""
    , "In 'm3', event 'flick', coarse schedule 'sch0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 160:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "In 'm3', initialization predicate 'in2' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable cs"
    , ""
    , "error 175:2:"
    , "\tpredicate in2"
    , ""
    ]

case16 :: IO (Either [Error] (Set Label,Set Label,Set Label))
case16 = runEitherT $ do
    m <- EitherT $ parse_machine path0 3
    let evt = all_upwards m ! "count"
    return ( keysSet $ evt^.evt_pairs.traverse.old.actions
           , keysSet $ evt^.evt_pairs.traverse.deleted.actions
           , keysSet $ evt^.new.actions)

result16 :: Either [Error] (Set Label,Set Label,Set Label)
result16 = Right ( S.fromList ["act0","act1"]
                 , S.fromList ["act0","act1"]
                 , S.fromList ["m3:act0","m3:act1"])

case17 :: IO (Either [Error] (Set Label,Set Label,Set Label))
case17 = runEitherT $ do
    m <- EitherT $ parse_machine path0 4
    let evt = all_upwards m ! "count"
    return ( keysSet $ evt^.evt_pairs.traverse.old.actions
           , keysSet $ evt^.evt_pairs.traverse.deleted.actions
           , keysSet $ evt^.new.actions)

result17 :: Either [Error] (Set Label,Set Label,Set Label)
result17 = Right ( S.fromList ["m3:act0","m3:act1"]
                 , S.fromList []
                 , S.fromList ["m3:act0","m3:act1"])

case18 :: IO Text
case18 = proof_obligation path0 "m3/count/SIM/act0" 3

result18 :: Output
result18 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result18.txt"
    T.unlines
    [ "; m3/count/SIM/act0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const cs (set sl$Pcs))"
    , "(declare-const cs@prime (set sl$Pcs))"
    , "(declare-const fs (set sl$Pcs))"
    , "(declare-const fs@prime (set sl$Pcs))"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-const ts (set sl$Pcs))"
    , "(declare-const ts@prime (set sl$Pcs))"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-const vs@prime (set sl$Pcs))"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun const@@sl$Pcs@@Int (Int) (Array sl$Pcs Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun qsum@@sl$Pcs"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl$Pcs@@Int"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             (set Int))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl$Pcs Int)) )"
    , "                (! (= (qsum@@sl$Pcs empty-set@@sl$Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs empty-set@@sl$Pcs term) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (qsum@@sl$Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl$Pcs r term) (qsum@@sl$Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (card@@sl$Pcs r)"
    , "                      (qsum@@sl$Pcs r (const@@sl$Pcs@@Int 1)))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; SKIP:fs"
    , "(assert (= fs@prime fs))"
    , "; SKIP:vs"
    , "(assert (= vs@prime vs))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; cs"
    , "(assert (= cs@prime empty-set@@sl$Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl$Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "; m3:act0"
    , "(assert (= c@prime 0))"
    , "; m3:act1"
    , "(assert (= n@prime (+ n 1)))"
    , "; m3:grd0"
    , "(assert (= c 1))"
    , "; m3:inv0"
    , "(assert (= c (card@@sl$Pcs cs)))"
    , "; m3:inv1"
    , "(assert (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1))))"
    , "; m3:inv2"
    , "(assert (finite@@sl$Pcs ts))"
    , "; m3:inv5"
    , "(assert (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1))))"
    , "; m3:inv6"
    , "(assert (= (intersect ts cs) empty-set@@sl$Pcs))"
    , "; m3:inv7"
    , "(assert (= fs (union ts cs)))"
    , "; sch1"
    , "(assert (= c 1))"
    , "; thm0"
    , "(assert (= (= n (card@@sl$Pcs sl$Pcs)) (= ts sl$Pcs)))"
    , "; ts"
    , "(assert (= ts@prime (union ts cs)))"
    , "(assert (not (= cs@prime empty-set@@sl$Pcs)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/count/SIM/act0"
    ]

case20 :: IO Text
case20 = proof_obligation path0 "m3/visit/INV/m3:inv0" 3

result20 :: Output
result20 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result20.txt"
    T.unlines
    [ "; m3/visit/INV/m3:inv0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const cs (set sl$Pcs))"
    , "(declare-const cs@prime (set sl$Pcs))"
    , "(declare-const fs (set sl$Pcs))"
    , "(declare-const fs@prime (set sl$Pcs))"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-const p sl$Pcs)"
    , "(declare-const ts (set sl$Pcs))"
    , "(declare-const ts@prime (set sl$Pcs))"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-const vs@prime (set sl$Pcs))"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun const@@sl$Pcs@@Int (Int) (Array sl$Pcs Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Pcs (sl$Pcs) (set sl$Pcs))"
    , "(declare-fun qsum@@sl$Pcs"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl$Pcs@@Int"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             (set Int))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Pcs"
    , "            ( (x sl$Pcs)"
    , "              (s1 (set sl$Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl$Pcs Int)) )"
    , "                (! (= (qsum@@sl$Pcs empty-set@@sl$Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs empty-set@@sl$Pcs term) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int))"
    , "                  (x sl$Pcs) )"
    , "                (! (=> (not (elem@@sl$Pcs x r))"
    , "                       (= (qsum@@sl$Pcs (union r (mk-set@@sl$Pcs x)) term)"
    , "                          (+ (qsum@@sl$Pcs r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs (union r (mk-set@@sl$Pcs x)) term) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (qsum@@sl$Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl$Pcs r term) (qsum@@sl$Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl$Pcs) )"
    , "                (! (= (card@@sl$Pcs (mk-set@@sl$Pcs x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (mk-set@@sl$Pcs x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 1)"
    , "                      (exists ( (x sl$Pcs) ) (and true (= r (mk-set@@sl$Pcs x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (card@@sl$Pcs r)"
    , "                      (qsum@@sl$Pcs r (const@@sl$Pcs@@Int 1)))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Pcs) )"
    , "                (! (= (select (const@@sl$Pcs@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl$Pcs@@Int x) y) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x sl$Pcs)"
    , "                  (y sl$Pcs) )"
    , "                (! (= (elem@@sl$Pcs x (mk-set@@sl$Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Pcs x (mk-set@@sl$Pcs y)) ))))"
    , "(assert (forall ( (r1 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (set@@sl$Pcs@@Int r1 term))"
    , "                      (exists ( (x sl$Pcs) )"
    , "                              (and (elem@@sl$Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (set@@sl$Pcs@@Int r1 term)) ))))"
    , "(assert (forall ( (r1 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (= (set@@sl$Pcs@@Int r1 term) (mk-set@@Int y))"
    , "                      (forall ( (x sl$Pcs) )"
    , "                              (=> (elem@@sl$Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@sl$Pcs@@Int r1 term)"
    , "                     (mk-set@@Int y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl$Pcs) )"
    , "                (! (finite@@sl$Pcs (mk-set@@sl$Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (mk-set@@sl$Pcs x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; SKIP:c"
    , "(assert (= c@prime c))"
    , "; SKIP:cs"
    , "(assert (= cs@prime cs))"
    , "; SKIP:fs"
    , "(assert (= fs@prime fs))"
    , "; SKIP:n"
    , "(assert (= n@prime n))"
    , "; SKIP:ts"
    , "(assert (= ts@prime ts))"
    , "; act1"
    , "(assert (= vs@prime (union vs (mk-set@@sl$Pcs p))))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl$Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "; m3:inv0"
    , "(assert (= c (card@@sl$Pcs cs)))"
    , "; m3:inv1"
    , "(assert (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1))))"
    , "; m3:inv2"
    , "(assert (finite@@sl$Pcs ts))"
    , "; m3:inv5"
    , "(assert (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1))))"
    , "; m3:inv6"
    , "(assert (= (intersect ts cs) empty-set@@sl$Pcs))"
    , "; m3:inv7"
    , "(assert (= fs (union ts cs)))"
    , "; thm0"
    , "(assert (= (= n (card@@sl$Pcs sl$Pcs)) (= ts sl$Pcs)))"
    , "(assert (not (= c@prime (card@@sl$Pcs cs@prime))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/visit/INV/m3:inv0"
    ]

case19 :: IO Text
case19 = proof_obligation path0 "m3/INIT/SIM/in2" 3

result19 :: Output
result19 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result19.txt"
    T.unlines
    [ "; m3/INIT/SIM/in2"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl$Pcs))"
    , "(declare-const fs (set sl$Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl$Pcs))"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; cs"
    , "(assert (= cs empty-set@@sl$Pcs))"
    , "; in0"
    , "(assert (= b false))"
    , "; m3:in0"
    , "(assert (= c 0))"
    , "; m3:in1"
    , "(assert (= n 0))"
    , "; m3:in2"
    , "(assert (= fs empty-set@@sl$Pcs))"
    , "; ts"
    , "(assert (= ts empty-set@@sl$Pcs))"
    , "(assert (not (= cs empty-set@@sl$Pcs)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INIT/SIM/in2"
    ]

path21 :: FilePath
path21 = [path|Tests/puzzle/puzzle-err2.tex|]

case21 :: IO Text
case21 = find_errors path21

result21 :: Output
result21 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result21.txt"
    T.unlines
    [ "In 'm3', event 'flick', coarse schedule 'sch1' refers to deleted symbols"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 161:2:"
    , "\tcoarse schedule 'sch1'"
    , ""
    , ""
    , "In 'm3', event 'flick', guard 'grd0' refers to deleted symbols"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 162:2:"
    , "\tguard 'grd0'"
    , ""
    , ""
    , "In 'm3', event 'term', coarse schedule 'sch2' refers to deleted symbols"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 104:2:"
    , "\tcoarse schedule 'sch2'"
    , ""
    , ""
    , "In 'm3', event 'count', coarse schedule 'sch0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 176:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "In 'm3', event 'flick', action 'act0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 163:2:"
    , "\taction 'act0'"
    , ""
    , ""
    , "In 'm3', event 'flick', coarse schedule 'sch0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 160:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "In 'm3', initialization predicate 'in2' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable cs"
    , ""
    , "error 175:2:"
    , "\tpredicate in2"
    , ""
    , ""
    , "error 204:2:"
    , "    event 'flick', action 'act' was deleted but does not exist"
    , ""
    , "error 205:2:"
    , "    initialization predicate 'in' was deleted but does not exist"
    ]

path22 :: FilePath
path22 = [path|Tests/puzzle/puzzle-err3.tex|]

case22 :: IO Text
case22 = find_errors path22

result22 :: Output
result22 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result22.txt"
    T.unlines
    [ "error 227:2:\n    'c' is not a disappearing variable or a new index"
    ]

path23 :: FilePath
path23 = [path|Tests/puzzle/puzzle-err4.tex|]

case23 :: IO Text
case23 = find_errors path23

result23 :: Output
result23 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result23.txt"
    T.unlines
    [ "error 227:2:\n    deleted variable \'xyz\' does not exist"
    ]

case24 :: IO (Either [Error] (Set Label,Set Label))
case24 = runEitherT $ do
    m <- EitherT $ parse_machine path0 4
    return ( keysSet $ m!.inh_props.inv
           , keysSet $ m!.props.inv)

result24 :: Either [Error] (Set Label,Set Label)
result24 = Right ( S.fromList ["inv0","inv1","inv2","m3:inv0","m3:inv1"
                              ,"m3:inv2","m3:inv5","m3:inv6"
                              ,"m3:inv7"]
                 , S.fromList [])

path25 :: FilePath
path25 = [path|Tests/puzzle/puzzle-err5.tex|]

case25 :: IO Text
case25 = find_errors path25

result25 :: Output
result25 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result25.txt"
    T.unlines
    [ "In 'm3', event 'flick', coarse schedule 'sch1' refers to deleted symbols"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 161:2:"
    , "\tcoarse schedule 'sch1'"
    , ""
    , ""
    , "In 'm3', event 'flick', guard 'grd0' refers to deleted symbols"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 162:2:"
    , "\tguard 'grd0'"
    , ""
    , ""
    , "In 'm3', event 'term', coarse schedule 'sch2' refers to deleted symbols"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 104:2:"
    , "\tcoarse schedule 'sch2'"
    , ""
    , ""
    , "In 'm3', event 'count', coarse schedule 'sch0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 176:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "In 'm3', event 'flick', coarse schedule 'sch0' refers to deleted symbols"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 160:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    ]

case27 :: IO (Either [Error] (Set Label,Set Label))
case27 = runEitherT $ do
    m <- EitherT $ parse_machine path0 3
    let evt = nonSkipUpwards m ! "flick"
    return ( keysSet $ evt^.evt_pairs.traverse.old.guards
           , keysSet $ evt^.new.guards)

result27 :: Either [Error] (Set Label,Set Label)
result27 = Right ( S.fromList ["grd0","grd1","sch0","sch1","sch2"]
                 , S.fromList ["grd1","m3:grd1","m3:grd2","m3:csch1","m3:csch2","sch2"])

case28 :: IO Text
case28 = find_errors "Tests/puzzle/puzzle-err7.tex"

result28 :: Output
result28 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result28.txt"
    T.unlines
    [ "error 238:24:"
    , "    Parameter mismatch. Expecting 1 type parameters, received 0."
    ]

case29 :: IO Text
case29 = proof_obligation path0 "m3/THM/WD" 3

result29 :: Output
result29 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result29.txt"
    T.unlines
    [ "; m3/THM/WD"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl$Pcs))"
    , "(declare-const fs (set sl$Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl$Pcs))"
    , "(declare-const vs (set sl$Pcs))"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Pcs ( (set sl$Pcs) ) Int)"
    , "(declare-fun const@@sl$Pcs@@Int (Int) (Array sl$Pcs Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Pcs ( (set sl$Pcs) ) Bool)"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun qsum@@sl$Pcs"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl$Pcs@@Int"
    , "             ( (set sl$Pcs)"
    , "               (Array sl$Pcs Int) )"
    , "             (set Int))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            (set sl$Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Pcs"
    , "            ( (s1 (set sl$Pcs))"
    , "              (s2 (set sl$Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Pcs"
    , "            ()"
    , "            (set sl$Pcs)"
    , "            ( (as const (set sl$Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl$Pcs Int)) )"
    , "                (! (= (qsum@@sl$Pcs empty-set@@sl$Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs empty-set@@sl$Pcs term) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs))"
    , "                  (term (Array sl$Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (qsum@@sl$Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl$Pcs r term) (qsum@@sl$Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl$Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs r) (<= 0 (card@@sl$Pcs r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Pcs r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (= (card@@sl$Pcs r) 0) (= r empty-set@@sl$Pcs))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs))"
    , "                  (r0 (set sl$Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Pcs)"
    , "                       (= (card@@sl$Pcs (union r r0))"
    , "                          (+ (card@@sl$Pcs r) (card@@sl$Pcs r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Pcs)) )"
    , "                (! (= (card@@sl$Pcs r)"
    , "                      (qsum@@sl$Pcs r (const@@sl$Pcs@@Int 1)))"
    , "                   :pattern"
    , "                   ( (card@@sl$Pcs r) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (finite@@sl$Pcs s1)"
    , "                       (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s1) (finite@@sl$Pcs s2))"
    , "                       (finite@@sl$Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Pcs))"
    , "                  (s2 (set sl$Pcs)) )"
    , "                (! (=> (and (finite@@sl$Pcs s2) (not (finite@@sl$Pcs s1)))"
    , "                       (not (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Pcs (set-diff@@sl$Pcs s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl$Pcs empty-set@@sl$Pcs))"
    , "; asm0"
    , "(assert (finite@@sl$Pcs sl$Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl$Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "; m3:inv0"
    , "(assert (= c (card@@sl$Pcs cs)))"
    , "; m3:inv1"
    , "(assert (= n (qsum@@sl$Pcs ts (const@@sl$Pcs@@Int 1))))"
    , "; m3:inv2"
    , "(assert (finite@@sl$Pcs ts))"
    , "; m3:inv5"
    , "(assert (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1))))"
    , "; m3:inv6"
    , "(assert (= (intersect ts cs) empty-set@@sl$Pcs))"
    , "; m3:inv7"
    , "(assert (= fs (union ts cs)))"
    , "(assert (not (finite@@sl$Pcs sl$Pcs)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/THM/WD"
    ]

path30 :: FilePath
path30 = [path|Tests/puzzle/puzzle-err8.tex|]

case30 :: IO Text
case30 = find_errors path30

result30 :: Output
result30 = readFileLn' "expected/Language/UnitB/Parser/Puzzle/result30.txt"
    T.unlines
    [ "Multiple expressions with the label grd0"
    , "error 53:2:"
    , "\tguard (event 'term')"
    , ""
    , "error 253:2:"
    , "\tguard (event 'term')"
    , ""
    , ""
    , "Multiple expressions with the label sch1"
    , "error 54:2:"
    , "\tcoarse schedule (event 'term')"
    , ""
    , "error 254:2:"
    , "\tcoarse schedule (event 'term')"
    , ""
    , ""
    , "Multiple expressions with the label act1"
    , "error 88:2:"
    , "\taction (event 'visit')"
    , ""
    , "error 288:2:"
    , "\taction (event 'visit')"
    , ""
    , ""
    , "Multiple expressions with the label sch0"
    , "error 160:2:"
    , "\tcoarse schedule (event 'flick')"
    , ""
    , "error 360:2:"
    , "\tcoarse schedule (event 'flick')"
    , ""
    , ""
    , "Multiple expressions with the label sch1"
    , "error 161:2:"
    , "\tcoarse schedule (event 'flick')"
    , ""
    , "error 361:2:"
    , "\tcoarse schedule (event 'flick')"
    , ""
    , ""
    , "Multiple expressions with the label grd0"
    , "error 162:2:"
    , "\tguard (event 'flick')"
    , ""
    , "error 362:2:"
    , "\tguard (event 'flick')"
    , ""
    , ""
    , "Multiple expressions with the label act0"
    , "error 163:2:"
    , "\taction (event 'flick')"
    , ""
    , "error 363:2:"
    , "\taction (event 'flick')"
    , ""
    , ""
    , "Multiple expressions with the label sch0"
    , "error 176:2:"
    , "\tcoarse schedule (event 'count')"
    , ""
    , "error 376:2:"
    , "\tcoarse schedule (event 'count')"
    , ""
    , ""
    , "Multiple expressions with the label act0"
    , "error 179:2:"
    , "\taction (event 'count')"
    , ""
    , "error 379:2:"
    , "\taction (event 'count')"
    , ""
    , ""
    , "Multiple expressions with the label act1"
    , "error 180:2:"
    , "\taction (event 'count')"
    , ""
    , "error 380:2:"
    , "\taction (event 'count')"
    , ""
    , ""
    , "Multiple expressions with the label grd1"
    , "error 188:2:"
    , "\tguard (event 'flick')"
    , ""
    , "error 388:2:"
    , "\tguard (event 'flick')"
    , ""
    , ""
    , "Multiple expressions with the label sch2"
    , "error 189:2:"
    , "\tcoarse schedule (event 'flick')"
    , ""
    , "error 389:2:"
    , "\tcoarse schedule (event 'flick')"
    , ""
    , ""
    , "Multiple expressions with the label m3:act1"
    , "error 223:3:"
    , "\taction (event 'count')"
    , ""
    , "error 423:3:"
    , "\taction (event 'count')"
    , ""
    , ""
    , "Multiple expressions with the label m3:grd0"
    , "error 224:3:"
    , "\tguard (event 'count')"
    , ""
    , "error 424:3:"
    , "\tguard (event 'count')"
    , ""
    ]
