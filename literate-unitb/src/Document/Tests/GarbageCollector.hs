module Document.Tests.GarbageCollector where

import Document.Tests.Suite

import Logic.Names
import Logic.Proof
import Logic.Theories.RelationTheory

import Control.Arrow
import Control.Lens

import Data.List as L
import Data.Map  as M

import Test.UnitTest

test_case :: TestCase
test_case = test_cases 
    "Garbage collector" 
    [ poCase "test0: verify m0" case0 result0 
    , poCase "test1: verify m1" case1 result1 
    , poCase "test2: verify m2" case2 result2 
    , stringCase "test3: monotonic simplification" case3 result3
    , stringCase "test4: monotonicity of POs" case4 result4 
    , stringCase "test5: monotonicity in relation theory" case5 result5 
    , stringCase "test6: monotonicity of POs" case6 result6
    , stringCase "test7: POs, step 3 (monotonicity, associativity)" case7 result7
    , stringCase "test8: POs, step 4 (monotonicity, associativity)" case8 result8 
    ]

path0 :: FilePath
path0 = [path|Tests/garbage collector/main.tex|]

case0 :: IO POResult
case0 = verify path0 0

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/INV/m0:inv2"
    , "  o  m0/alloc/INV/m0:inv0"
    , "  o  m0/alloc/INV/m0:inv1"
    , "  o  m0/alloc/INV/m0:inv2"
    , "  o  m0/free/INV/m0:inv0"
    , "  o  m0/free/INV/m0:inv1"
    , "  o  m0/free/INV/m0:inv2"
    , "  o  m0/free/SCH/m0:grd0"
    , "passed 10 / 10"
    ]

case1 :: IO POResult
case1 = verify path0 1

result1 :: String
result1 = unlines
    [ "  o  m1/LIVE/m1:prog0/ensure/TR/WFIS/p/p@prime"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/free/EN"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/free/NEG"
    , "  o  m1/THM/thm0/assertion/WD/E/easy"
    , "  o  m1/THM/thm0/assertion/WD/rr/easy"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/goal"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/hypotheses"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/relation"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 1"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 2"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 3"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 4"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 5"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 6"
    , "  o  m1/THM/thm0/main goal/assertion/lmm0/step 7"
    , " xxx m1/THM/thm0/main goal/main goal/goal"
    , "  o  m1/THM/thm0/main goal/main goal/hypotheses"
    , "  o  m1/THM/thm0/main goal/main goal/relation"
    , "  o  m1/THM/thm0/main goal/main goal/step 1"
    , "  o  m1/THM/thm0/main goal/main goal/step 2"
    , "  o  m1/THM/thm0/main goal/main goal/step 3"
    , "  o  m1/THM/thm0/main goal/new assumption"
    , "  o  m1/add/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/add/SCH/p"
    , "  o  m1/add/SCH/q"
    , "  o  m1/alloc/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/delete/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/delete/SCH/p"
    , "  o  m1/free/C_SCH/weaken/m1:sch0"
    , "  o  m1/free/C_SCH/weaken/m1:sch1"
    , "  o  m1/free/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/free/SCH/m0:grd0"
    , "passed 31 / 32"
    ]

case2 :: IO POResult
case2 = verify path0 2

result2 :: String
result2 = unlines
    [ "  o  m2/INIT/INV/m2:inv0"
    , "  o  m2/add/INV/m2:inv0"
    , "  o  m2/add/SAF/m2:saf0"
    , "  o  m2/alloc/INV/m2:inv0"
    , "  o  m2/alloc/SAF/m2:saf0"
    , "  o  m2/delete/INV/m2:inv0"
    , "  o  m2/delete/SAF/m2:saf0"
    , " xxx m2/free/C_SCH/weaken/m2:sch0"
    , " xxx m2/free/C_SCH/weaken/m2:sch1"
    , "  o  m2/free/GRD/str/m1:sch1"
    , "  o  m2/free/INV/m2:inv0"
    , "  o  m2/free/SAF/m2:saf0"
    , "  o  m2/free/SCH/m0:grd0"
    , " xxx m2/m2:prog0/LIVE/add"
    , " xxx m2/m2:prog1/LIVE/add"
    , " xxx m2/m2:prog2/LIVE/add"
    , "passed 11 / 16"
    ]

case3 :: IO String
case3 = proof_obligation_stripped path0 "m1/THM/thm0/main goal/assertion/lmm0/step 5" 1

result3 :: String
result3 = unlines
    [ "; m1/THM/thm0/main goal/assertion/lmm0/step 5"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-sort Node 0)"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const E (set (Pair Node Node)))"
    , "(declare-const free (set Node))"
    , "(declare-const live (set Node))"
    , "(declare-const p Node)"
    , "(declare-const ptr (set (Pair Node Node)))"
    , "(declare-const q Node)"
    , "(declare-const r Node)"
    , "(declare-const ref Node)"
    , "(declare-const rr (set (Pair Node Node)))"
    , "(declare-fun asrel@@Node ( (set Node) ) (set (Pair Node Node)))"
    , "(declare-fun card@@Node ( (set Node) ) Int)"
    , "(declare-fun card@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Int)"
    , "(declare-fun finite@@Node ( (set Node) ) Bool)"
    , "(declare-fun finite@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Bool)"
    , "(declare-fun id@@Node () (set (Pair Node Node)))"
    , "(declare-fun lookup@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set Node) )"
    , "             (set Node))"
    , "(declare-fun mk-set@@Node (Node) (set Node))"
    , "(declare-fun mk-set@Open@@Pair@@Node@@Node@Close"
    , "             ( (Pair Node Node) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun plus@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun reldom@@Node@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set Node))"
    , "(declare-fun seq@@Node@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun star@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(define-fun Node () (set Node) ( (as const (set Node)) true ))"
    , "(define-fun all@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              true ))"
    , "(define-fun all@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              true ))"
    , "(define-fun compl@@Node"
    , "            ( (s1 (set Node)) )"
    , "            (set Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Node"
    , "            ( (x Node)"
    , "              (s1 (set Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Pair@@Node@@Node@Close"
    , "            ( (x (Pair Node Node))"
    , "              (s1 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              false ))"
    , "(define-fun set-diff@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            (set Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= E (mk-set (pair p q))))"
    , "(assert (= rr (asrel (mk-set r))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x Node) ) (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x (Pair Node Node)) )"
    , "                              (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set Node))"
    , "                  (r0 (set Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node)))"
    , "                  (r0 (set (Pair Node Node))) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (x Node)"
    , "                  (y Node) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (x (Pair Node Node))"
    , "                  (y (Pair Node Node)) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (finite empty-set))"
    , "(assert (finite empty-set))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem (pair x1 x2) r1) (elem x1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x1 (reldom r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node)) )"
    , "                (! (= (reldom (seq (asrel s1) r1))"
    , "                      (intersect s1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (reldom (seq (asrel s1) r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1))"
    , "                      (elem (pair x1 x2) r1))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1)) ))))"
    , "(assert (forall ( (x1 Node) )"
    , "                (! (= (asrel (mk-set x1)) (mk-set (pair x1 x1)))"
    , "                   :pattern"
    , "                   ( (asrel (mk-set x1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node)))"
    , "                  (r5 (set (Pair Node Node))) )"
    , "                (! (= (seq (seq r1 r3) r5) (seq r1 (seq r3 r5)))"
    , "                   :pattern"
    , "                   ( (seq (seq r1 r3) r5) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star (seq (star rr) rr2)) (star rr)))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star rr2) (star (seq rr (star rr2)))))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq (star rr) rr) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq (star rr) rr) id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq rr (star rr)) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq rr (star rr)) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (= (seq (union r1 r2) r3)"
    , "                      (union (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (seq (union r1 r2) r3) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (= (seq r4 (union r1 r2))"
    , "                      (union (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (seq r4 (union r1 r2)) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (seq (mk-set (pair x1 x3)) all)"
    , "                      (seq (asrel (mk-set x1)) all))"
    , "                   :pattern"
    , "                   ( (seq (mk-set (pair x1 x3)) all) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node)"
    , "                  (x4 Node)"
    , "                  (x5 Node) )"
    , "                (! (= (seq (seq (mk-set (pair x1 x2)) all)"
    , "                           (mk-set (pair x4 x5)))"
    , "                      (mk-set (pair x1 x5)))"
    , "                   :pattern"
    , "                   ( (seq (seq (mk-set (pair x1 x2)) all)"
    , "                          (mk-set (pair x4 x5))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2)))"
    , "                      (mk-set (pair x1 x2)))"
    , "                   :pattern"
    , "                   ( (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (elem (pair x1 x3) id) (= x1 x3))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq id r1) r1) :pattern ( (seq id r1) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq r1 id) r1) :pattern ( (seq r1 id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (subset rr (star rr))"
    , "                   :pattern"
    , "                   ( (subset rr (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (=> (subset rr rr2) (subset (star rr) (star rr2)))"
    , "                   :pattern"
    , "                   ( (subset (star rr) (star rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                       (elem (pair x1 x3) (star rr)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                     (elem (pair x1 x3) (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star rr))"
    , "                       (elem (pair x1 x3) (star (union rr rr2))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (union rr rr2))) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (seq (star rr) (star rr)) (star rr))"
    , "                   :pattern"
    , "                   ( (seq (star rr) (star rr)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq (star rr) rr))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq rr (star rr)))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x2 Node) )"
    , "                (! (= (elem x2 (lookup r1 s1))"
    , "                      (exists ( (x1 Node) )"
    , "                              (and (elem x1 s1) (elem (pair x1 x2) r1))))"
    , "                   :pattern"
    , "                   ( (elem x2 (lookup r1 s1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem x1 s1)"
    , "                       (=> (elem (pair x1 x2) r1) (elem x2 (lookup r1 s1))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x2 (lookup r1 s1)) ))))"
    , "(assert true)"
    , "(assert true)"
    , "(assert (not (subset (union (seq (seq (seq rr all) (asrel (mk-set q))) (star ptr))"
    , "                            (seq rr (star ptr)))"
    , "                     (union (seq (mk-set (pair r q)) (star ptr))"
    , "                            (seq rr (star ptr))))))"
    , "(assert (not (subset (seq (seq (seq rr all) (asrel (mk-set q))) (star ptr))"
    , "                     (seq (mk-set (pair r q)) (star ptr)))))"
    , "(assert (not (subset (seq (seq rr all) (asrel (mk-set q)))"
    , "                     (mk-set (pair r q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/THM/thm0/main goal/assertion/lmm0/step 5"
    ]

case4 :: IO String
case4 = do
    either id (unlines . L.map (show . (each %~ render)) . keys . (^.syntacticThm.monotonicity)) 
        <$> sequent path0 "m1/THM/thm0/main goal/assertion/lmm0/step 5" 1

result4 :: String
result4 = unlines
    [ "(\"<=\",\"+\")"
    , "(\"<=\",\"-\")"
    , "(\"=>\",\"<=\")"
    , "(\"=>\",\"=>\")"
    , "(\"=>\",\"and\")"
    , "(\"=>\",\"not\")"
    , "(\"=>\",\"or\")"
    , "(\"=>\",\"st-subset\")"
    , "(\"=>\",\"subset\")"
    , "(\"st-subset\",\"compl\")"
    , "(\"subset\",\"compl\")"
    , "(\"subset\",\"intersect\")"
    , "(\"subset\",\"seq\")"
    , "(\"subset\",\"set-diff\")"
    , "(\"subset\",\"star\")"
    , "(\"subset\",\"union\")"
    ]

case5 :: IO String
case5 = do
    return $ unlines $ L.map (show . (render *** render)) $ keys 
        $ relation_theory^.syntacticThm.monotonicity

result5 :: String
result5 = unlines
    [ "(\"subset\",\"seq\")"
    , "(\"subset\",\"star\")"
    ]

case6 :: IO String
case6 = do
    proof_obligation_stripped path0 
        "m1/THM/thm0/main goal/assertion/lmm0/step 6" 1

result6 :: String
result6 = unlines
    [ "; m1/THM/thm0/main goal/assertion/lmm0/step 6"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-sort Node 0)"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const E (set (Pair Node Node)))"
    , "(declare-const free (set Node))"
    , "(declare-const live (set Node))"
    , "(declare-const p Node)"
    , "(declare-const ptr (set (Pair Node Node)))"
    , "(declare-const q Node)"
    , "(declare-const r Node)"
    , "(declare-const ref Node)"
    , "(declare-const rr (set (Pair Node Node)))"
    , "(declare-fun asrel@@Node ( (set Node) ) (set (Pair Node Node)))"
    , "(declare-fun card@@Node ( (set Node) ) Int)"
    , "(declare-fun card@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Int)"
    , "(declare-fun finite@@Node ( (set Node) ) Bool)"
    , "(declare-fun finite@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Bool)"
    , "(declare-fun id@@Node () (set (Pair Node Node)))"
    , "(declare-fun lookup@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set Node) )"
    , "             (set Node))"
    , "(declare-fun mk-set@@Node (Node) (set Node))"
    , "(declare-fun mk-set@Open@@Pair@@Node@@Node@Close"
    , "             ( (Pair Node Node) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun plus@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun reldom@@Node@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set Node))"
    , "(declare-fun seq@@Node@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun star@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(define-fun Node () (set Node) ( (as const (set Node)) true ))"
    , "(define-fun all@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              true ))"
    , "(define-fun all@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              true ))"
    , "(define-fun compl@@Node"
    , "            ( (s1 (set Node)) )"
    , "            (set Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Node"
    , "            ( (x Node)"
    , "              (s1 (set Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Pair@@Node@@Node@Close"
    , "            ( (x (Pair Node Node))"
    , "              (s1 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              false ))"
    , "(define-fun set-diff@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            (set Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (elem (pair r q) (star ptr)))"
    , "(assert (= E (mk-set (pair p q))))"
    , "(assert (= rr (asrel (mk-set r))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x Node) ) (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x (Pair Node Node)) )"
    , "                              (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set Node))"
    , "                  (r0 (set Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node)))"
    , "                  (r0 (set (Pair Node Node))) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (x Node)"
    , "                  (y Node) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (x (Pair Node Node))"
    , "                  (y (Pair Node Node)) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (finite empty-set))"
    , "(assert (finite empty-set))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem (pair x1 x2) r1) (elem x1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x1 (reldom r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node)) )"
    , "                (! (= (reldom (seq (asrel s1) r1))"
    , "                      (intersect s1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (reldom (seq (asrel s1) r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1))"
    , "                      (elem (pair x1 x2) r1))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1)) ))))"
    , "(assert (forall ( (x1 Node) )"
    , "                (! (= (asrel (mk-set x1)) (mk-set (pair x1 x1)))"
    , "                   :pattern"
    , "                   ( (asrel (mk-set x1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node)))"
    , "                  (r5 (set (Pair Node Node))) )"
    , "                (! (= (seq (seq r1 r3) r5) (seq r1 (seq r3 r5)))"
    , "                   :pattern"
    , "                   ( (seq (seq r1 r3) r5) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star (seq (star rr) rr2)) (star rr)))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star rr2) (star (seq rr (star rr2)))))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq (star rr) rr) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq (star rr) rr) id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq rr (star rr)) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq rr (star rr)) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (= (seq (union r1 r2) r3)"
    , "                      (union (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (seq (union r1 r2) r3) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (= (seq r4 (union r1 r2))"
    , "                      (union (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (seq r4 (union r1 r2)) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (seq (mk-set (pair x1 x3)) all)"
    , "                      (seq (asrel (mk-set x1)) all))"
    , "                   :pattern"
    , "                   ( (seq (mk-set (pair x1 x3)) all) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node)"
    , "                  (x4 Node)"
    , "                  (x5 Node) )"
    , "                (! (= (seq (seq (mk-set (pair x1 x2)) all)"
    , "                           (mk-set (pair x4 x5)))"
    , "                      (mk-set (pair x1 x5)))"
    , "                   :pattern"
    , "                   ( (seq (seq (mk-set (pair x1 x2)) all)"
    , "                          (mk-set (pair x4 x5))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2)))"
    , "                      (mk-set (pair x1 x2)))"
    , "                   :pattern"
    , "                   ( (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (elem (pair x1 x3) id) (= x1 x3))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq id r1) r1) :pattern ( (seq id r1) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq r1 id) r1) :pattern ( (seq r1 id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (subset rr (star rr))"
    , "                   :pattern"
    , "                   ( (subset rr (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (=> (subset rr rr2) (subset (star rr) (star rr2)))"
    , "                   :pattern"
    , "                   ( (subset (star rr) (star rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                       (elem (pair x1 x3) (star rr)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                     (elem (pair x1 x3) (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star rr))"
    , "                       (elem (pair x1 x3) (star (union rr rr2))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (union rr rr2))) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (seq (star rr) (star rr)) (star rr))"
    , "                   :pattern"
    , "                   ( (seq (star rr) (star rr)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq (star rr) rr))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq rr (star rr)))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x2 Node) )"
    , "                (! (= (elem x2 (lookup r1 s1))"
    , "                      (exists ( (x1 Node) )"
    , "                              (and (elem x1 s1) (elem (pair x1 x2) r1))))"
    , "                   :pattern"
    , "                   ( (elem x2 (lookup r1 s1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem x1 s1)"
    , "                       (=> (elem (pair x1 x2) r1) (elem x2 (lookup r1 s1))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x2 (lookup r1 s1)) ))))"
    , "(assert true)"
    , "(assert true)"
    , "(assert (not (subset (union (seq (mk-set (pair r q)) (star ptr))"
    , "                            (seq rr (star ptr)))"
    , "                     (union (seq (seq rr (star ptr)) (star ptr))"
    , "                            (seq rr (star ptr))))))"
    , "(assert (not (subset (seq (mk-set (pair r q)) (star ptr))"
    , "                     (seq (seq rr (star ptr)) (star ptr)))))"
    , "(assert (not (subset (mk-set (pair r q)) (seq rr (star ptr)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/THM/thm0/main goal/assertion/lmm0/step 6"
    ]

case7 :: IO String
case7 = proof_obligation_stripped path0 "m1/THM/thm0/main goal/assertion/lmm0/step 3" 1

result7 :: String
result7 = unlines
    [ "; m1/THM/thm0/main goal/assertion/lmm0/step 3"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-sort Node 0)"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const E (set (Pair Node Node)))"
    , "(declare-const free (set Node))"
    , "(declare-const live (set Node))"
    , "(declare-const p Node)"
    , "(declare-const ptr (set (Pair Node Node)))"
    , "(declare-const q Node)"
    , "(declare-const r Node)"
    , "(declare-const ref Node)"
    , "(declare-const rr (set (Pair Node Node)))"
    , "(declare-fun asrel@@Node ( (set Node) ) (set (Pair Node Node)))"
    , "(declare-fun card@@Node ( (set Node) ) Int)"
    , "(declare-fun card@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Int)"
    , "(declare-fun finite@@Node ( (set Node) ) Bool)"
    , "(declare-fun finite@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Bool)"
    , "(declare-fun id@@Node () (set (Pair Node Node)))"
    , "(declare-fun lookup@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set Node) )"
    , "             (set Node))"
    , "(declare-fun mk-set@@Node (Node) (set Node))"
    , "(declare-fun mk-set@Open@@Pair@@Node@@Node@Close"
    , "             ( (Pair Node Node) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun plus@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun reldom@@Node@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set Node))"
    , "(declare-fun seq@@Node@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun star@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(define-fun Node () (set Node) ( (as const (set Node)) true ))"
    , "(define-fun all@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              true ))"
    , "(define-fun all@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              true ))"
    , "(define-fun compl@@Node"
    , "            ( (s1 (set Node)) )"
    , "            (set Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Node"
    , "            ( (x Node)"
    , "              (s1 (set Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Pair@@Node@@Node@Close"
    , "            ( (x (Pair Node Node))"
    , "              (s1 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              false ))"
    , "(define-fun set-diff@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            (set Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= E (mk-set (pair p q))))"
    , "(assert (= rr (asrel (mk-set r))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x Node) ) (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x (Pair Node Node)) )"
    , "                              (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set Node))"
    , "                  (r0 (set Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node)))"
    , "                  (r0 (set (Pair Node Node))) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (x Node)"
    , "                  (y Node) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (x (Pair Node Node))"
    , "                  (y (Pair Node Node)) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (finite empty-set))"
    , "(assert (finite empty-set))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem (pair x1 x2) r1) (elem x1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x1 (reldom r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node)) )"
    , "                (! (= (reldom (seq (asrel s1) r1))"
    , "                      (intersect s1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (reldom (seq (asrel s1) r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1))"
    , "                      (elem (pair x1 x2) r1))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1)) ))))"
    , "(assert (forall ( (x1 Node) )"
    , "                (! (= (asrel (mk-set x1)) (mk-set (pair x1 x1)))"
    , "                   :pattern"
    , "                   ( (asrel (mk-set x1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node)))"
    , "                  (r5 (set (Pair Node Node))) )"
    , "                (! (= (seq (seq r1 r3) r5) (seq r1 (seq r3 r5)))"
    , "                   :pattern"
    , "                   ( (seq (seq r1 r3) r5) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star (seq (star rr) rr2)) (star rr)))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star rr2) (star (seq rr (star rr2)))))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq (star rr) rr) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq (star rr) rr) id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq rr (star rr)) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq rr (star rr)) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (= (seq (union r1 r2) r3)"
    , "                      (union (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (seq (union r1 r2) r3) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (= (seq r4 (union r1 r2))"
    , "                      (union (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (seq r4 (union r1 r2)) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (seq (mk-set (pair x1 x3)) all)"
    , "                      (seq (asrel (mk-set x1)) all))"
    , "                   :pattern"
    , "                   ( (seq (mk-set (pair x1 x3)) all) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node)"
    , "                  (x4 Node)"
    , "                  (x5 Node) )"
    , "                (! (= (seq (seq (mk-set (pair x1 x2)) all)"
    , "                           (mk-set (pair x4 x5)))"
    , "                      (mk-set (pair x1 x5)))"
    , "                   :pattern"
    , "                   ( (seq (seq (mk-set (pair x1 x2)) all)"
    , "                          (mk-set (pair x4 x5))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2)))"
    , "                      (mk-set (pair x1 x2)))"
    , "                   :pattern"
    , "                   ( (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (elem (pair x1 x3) id) (= x1 x3))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq id r1) r1) :pattern ( (seq id r1) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq r1 id) r1) :pattern ( (seq r1 id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (subset rr (star rr))"
    , "                   :pattern"
    , "                   ( (subset rr (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (=> (subset rr rr2) (subset (star rr) (star rr2)))"
    , "                   :pattern"
    , "                   ( (subset (star rr) (star rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                       (elem (pair x1 x3) (star rr)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                     (elem (pair x1 x3) (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star rr))"
    , "                       (elem (pair x1 x3) (star (union rr rr2))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (union rr rr2))) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (seq (star rr) (star rr)) (star rr))"
    , "                   :pattern"
    , "                   ( (seq (star rr) (star rr)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq (star rr) rr))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq rr (star rr)))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x2 Node) )"
    , "                (! (= (elem x2 (lookup r1 s1))"
    , "                      (exists ( (x1 Node) )"
    , "                              (and (elem x1 s1) (elem (pair x1 x2) r1))))"
    , "                   :pattern"
    , "                   ( (elem x2 (lookup r1 s1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem x1 s1)"
    , "                       (=> (elem (pair x1 x2) r1) (elem x2 (lookup r1 s1))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x2 (lookup r1 s1)) ))))"
    , "(assert true)"
    , "(assert true)"
    , "(assert (not (subset (union (seq (seq (seq rr (seq (star (seq (star ptr) E)) (star ptr)))"
    , "                                      E)"
    , "                                 (star ptr))"
    , "                            (seq rr (star ptr)))"
    , "                     (union (seq (seq rr (seq all E)) (star ptr))"
    , "                            (seq rr (star ptr))))))"
    , "(assert (not (subset (seq (seq (seq rr (seq (star (seq (star ptr) E)) (star ptr)))"
    , "                               E)"
    , "                          (star ptr))"
    , "                     (seq (seq rr (seq all E)) (star ptr)))))"
    , "(assert (not (subset (seq (seq rr (seq (star (seq (star ptr) E)) (star ptr)))"
    , "                          E)"
    , "                     (seq rr (seq all E)))))"
    , "(assert (not (subset (seq (star (seq (star ptr) E)) (star ptr)) all)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/THM/thm0/main goal/assertion/lmm0/step 3"
    ]

case8 :: IO String
case8 = proof_obligation_stripped path0 "m1/THM/thm0/main goal/assertion/lmm0/step 4" 1

result8 :: String
result8 = unlines
    [ "; m1/THM/thm0/main goal/assertion/lmm0/step 4"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-sort Node 0)"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const E (set (Pair Node Node)))"
    , "(declare-const free (set Node))"
    , "(declare-const live (set Node))"
    , "(declare-const p Node)"
    , "(declare-const ptr (set (Pair Node Node)))"
    , "(declare-const q Node)"
    , "(declare-const r Node)"
    , "(declare-const ref Node)"
    , "(declare-const rr (set (Pair Node Node)))"
    , "(declare-fun asrel@@Node ( (set Node) ) (set (Pair Node Node)))"
    , "(declare-fun card@@Node ( (set Node) ) Int)"
    , "(declare-fun card@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Int)"
    , "(declare-fun finite@@Node ( (set Node) ) Bool)"
    , "(declare-fun finite@Open@@Pair@@Node@@Node@Close"
    , "             ( (set (Pair Node Node)) )"
    , "             Bool)"
    , "(declare-fun id@@Node () (set (Pair Node Node)))"
    , "(declare-fun lookup@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set Node) )"
    , "             (set Node))"
    , "(declare-fun mk-set@@Node (Node) (set Node))"
    , "(declare-fun mk-set@Open@@Pair@@Node@@Node@Close"
    , "             ( (Pair Node Node) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun plus@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun reldom@@Node@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set Node))"
    , "(declare-fun seq@@Node@@Node@@Node"
    , "             ( (set (Pair Node Node))"
    , "               (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(declare-fun star@@Node"
    , "             ( (set (Pair Node Node)) )"
    , "             (set (Pair Node Node)))"
    , "(define-fun Node () (set Node) ( (as const (set Node)) true ))"
    , "(define-fun all@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              true ))"
    , "(define-fun all@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              true ))"
    , "(define-fun compl@@Node"
    , "            ( (s1 (set Node)) )"
    , "            (set Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Node"
    , "            ( (x Node)"
    , "              (s1 (set Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@Pair@@Node@@Node@Close"
    , "            ( (x (Pair Node Node))"
    , "              (s1 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Node"
    , "            ()"
    , "            (set Node)"
    , "            ( (as const (set Node))"
    , "              false ))"
    , "(define-fun empty-set@Open@@Pair@@Node@@Node@Close"
    , "            ()"
    , "            (set (Pair Node Node))"
    , "            ( (as const (set (Pair Node Node)))"
    , "              false ))"
    , "(define-fun set-diff@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            (set Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            (set (Pair Node Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Node"
    , "            ( (s1 (set Node))"
    , "              (s2 (set Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@Pair@@Node@@Node@Close"
    , "            ( (s1 (set (Pair Node Node)))"
    , "              (s2 (set (Pair Node Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= E (mk-set (pair p q))))"
    , "(assert (= rr (asrel (mk-set r))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (=> (finite r) (<= 0 (card r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card r)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 0) (= r empty-set))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (= (card (mk-set x)) 1)"
    , "                   :pattern"
    , "                   ( (card (mk-set x)) ))))"
    , "(assert (forall ( (r (set Node)) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x Node) ) (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set (Pair Node Node))) )"
    , "                (! (= (= (card r) 1)"
    , "                      (exists ( (x (Pair Node Node)) )"
    , "                              (and true (= r (mk-set x)))))"
    , "                   :pattern"
    , "                   ( (card r) ))))"
    , "(assert (forall ( (r (set Node))"
    , "                  (r0 (set Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (r (set (Pair Node Node)))"
    , "                  (r0 (set (Pair Node Node))) )"
    , "                (! (=> (= (intersect r r0) empty-set)"
    , "                       (= (card (union r r0)) (+ (card r) (card r0))))"
    , "                   :pattern"
    , "                   ( (card (union r r0)) ))))"
    , "(assert (forall ( (x Node)"
    , "                  (y Node) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (x (Pair Node Node))"
    , "                  (y (Pair Node Node)) )"
    , "                (! (= (elem x (mk-set y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem x (mk-set y)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (finite s1) (finite (set-diff s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s1) (finite s2))"
    , "                       (finite (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Node))"
    , "                  (s2 (set Node)) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (Pair Node Node)))"
    , "                  (s2 (set (Pair Node Node))) )"
    , "                (! (=> (and (finite s2) (not (finite s1)))"
    , "                       (not (finite (set-diff s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite (set-diff s1 s2)) ))))"
    , "(assert (forall ( (x Node) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (forall ( (x (Pair Node Node)) )"
    , "                (! (finite (mk-set x))"
    , "                   :pattern"
    , "                   ( (finite (mk-set x)) ))))"
    , "(assert (finite empty-set))"
    , "(assert (finite empty-set))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem (pair x1 x2) r1) (elem x1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x1 (reldom r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node)) )"
    , "                (! (= (reldom (seq (asrel s1) r1))"
    , "                      (intersect s1 (reldom r1)))"
    , "                   :pattern"
    , "                   ( (reldom (seq (asrel s1) r1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1))"
    , "                      (elem (pair x1 x2) r1))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) (seq (asrel (mk-set x1)) r1)) ))))"
    , "(assert (forall ( (x1 Node) )"
    , "                (! (= (asrel (mk-set x1)) (mk-set (pair x1 x1)))"
    , "                   :pattern"
    , "                   ( (asrel (mk-set x1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node)))"
    , "                  (r5 (set (Pair Node Node))) )"
    , "                (! (= (seq (seq r1 r3) r5) (seq r1 (seq r3 r5)))"
    , "                   :pattern"
    , "                   ( (seq (seq r1 r3) r5) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star (seq (star rr) rr2)) (star rr)))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (= (star (union rr rr2))"
    , "                      (seq (star rr2) (star (seq rr (star rr2)))))"
    , "                   :pattern"
    , "                   ( (star (union rr rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq (star rr) rr) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq (star rr) rr) id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (union (seq rr (star rr)) id) (star rr))"
    , "                   :pattern"
    , "                   ( (union (seq rr (star rr)) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (= (seq (union r1 r2) r3)"
    , "                      (union (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (seq (union r1 r2) r3) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (= (seq r4 (union r1 r2))"
    , "                      (union (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (seq r4 (union r1 r2)) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (seq (mk-set (pair x1 x3)) all)"
    , "                      (seq (asrel (mk-set x1)) all))"
    , "                   :pattern"
    , "                   ( (seq (mk-set (pair x1 x3)) all) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node)"
    , "                  (x4 Node)"
    , "                  (x5 Node) )"
    , "                (! (= (seq (seq (mk-set (pair x1 x2)) all)"
    , "                           (mk-set (pair x4 x5)))"
    , "                      (mk-set (pair x1 x5)))"
    , "                   :pattern"
    , "                   ( (seq (seq (mk-set (pair x1 x2)) all)"
    , "                          (mk-set (pair x4 x5))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (= (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2)))"
    , "                      (mk-set (pair x1 x2)))"
    , "                   :pattern"
    , "                   ( (seq (seq (asrel (mk-set x1)) all) (asrel (mk-set x2))) ))))"
    , "(assert (forall ( (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (= (elem (pair x1 x3) id) (= x1 x3))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) id) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq id r1) r1) :pattern ( (seq id r1) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node))) )"
    , "                (! (= (seq r1 id) r1) :pattern ( (seq r1 id) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (subset rr (star rr))"
    , "                   :pattern"
    , "                   ( (subset rr (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node))) )"
    , "                (! (=> (subset rr rr2) (subset (star rr) (star rr2)))"
    , "                   :pattern"
    , "                   ( (subset (star rr) (star rr2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                       (elem (pair x1 x3) (star rr)))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (intersect rr rr2)))"
    , "                     (elem (pair x1 x3) (star rr)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node)))"
    , "                  (rr2 (set (Pair Node Node)))"
    , "                  (x1 Node)"
    , "                  (x3 Node) )"
    , "                (! (=> (elem (pair x1 x3) (star rr))"
    , "                       (elem (pair x1 x3) (star (union rr rr2))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x3) (star (union rr rr2))) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (seq (star rr) (star rr)) (star rr))"
    , "                   :pattern"
    , "                   ( (seq (star rr) (star rr)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r3 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r1 r3) (seq r2 r3)))"
    , "                   :pattern"
    , "                   ( (subset (seq r1 r3) (seq r2 r3)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (r2 (set (Pair Node Node)))"
    , "                  (r4 (set (Pair Node Node))) )"
    , "                (! (=> (subset r1 r2) (subset (seq r4 r1) (seq r4 r2)))"
    , "                   :pattern"
    , "                   ( (subset (seq r4 r1) (seq r4 r2)) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq (star rr) rr))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (rr (set (Pair Node Node))) )"
    , "                (! (= (plus rr) (seq rr (star rr)))"
    , "                   :pattern"
    , "                   ( (plus rr) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x2 Node) )"
    , "                (! (= (elem x2 (lookup r1 s1))"
    , "                      (exists ( (x1 Node) )"
    , "                              (and (elem x1 s1) (elem (pair x1 x2) r1))))"
    , "                   :pattern"
    , "                   ( (elem x2 (lookup r1 s1)) ))))"
    , "(assert (forall ( (r1 (set (Pair Node Node)))"
    , "                  (s1 (set Node))"
    , "                  (x1 Node)"
    , "                  (x2 Node) )"
    , "                (! (=> (elem x1 s1)"
    , "                       (=> (elem (pair x1 x2) r1) (elem x2 (lookup r1 s1))))"
    , "                   :pattern"
    , "                   ( (elem (pair x1 x2) r1)"
    , "                     (elem x2 (lookup r1 s1)) ))))"
    , "(assert true)"
    , "(assert true)"
    , "(assert (not (= (union (seq (seq rr (seq all E)) (star ptr))"
    , "                       (seq rr (star ptr)))"
    , "                (union (seq (seq (seq rr all) (asrel (mk-set q))) (star ptr))"
    , "                       (seq rr (star ptr))))))"
    , "(assert (not (= (seq (seq rr (seq all E)) (star ptr))"
    , "                (seq (seq (seq rr all) (asrel (mk-set q))) (star ptr)))))"
    , "(assert (not (= (seq rr (seq all E))"
    , "                (seq (seq rr all) (asrel (mk-set q))))))"
    , "(assert (not (= E (asrel (mk-set q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/THM/thm0/main goal/assertion/lmm0/step 4"
    ]
