{-# LANGUAGE OverloadedStrings #-}
module Language.UnitB.Parser.Tests.Lambdas where

    -- Modules
import Language.UnitB.Parser.Tests.Suite

import Logic.Expr.Const
import Logic.Proof

import Logic.Theories.FunctionTheory

import Language.UnitB.Expr

    -- Libraries
import           Data.Map hiding ( map )
import qualified Data.Map as M
import           Data.Text (Text)
import qualified Data.Text as T

import Test.UnitTest

import Utilities.Syntactic

test_case :: TestCase
test_case = test

test :: TestCase
test = test_cases
            "lambda expressions in the cube example"
            [ part0
            , part1
            , part2
            , part3
            ]            
part0 :: TestCase
part0 = test_cases
            "part 0"
            [ (poCase "test 0, verification, lambda vs empty-fun" 
                (verify path0 0) result0)
            , (poCase "test 1, verification, lambda vs ovl, mk-fun" 
                (verify path1 0) result1)
            , (poCase "test 2, verification, lambda vs apply" 
                (verify path2 0) result2)
            ]            
part1 :: TestCase
part1 = test_cases
            "part 1"
            [ (poCase "test 3, verification, set comprehension, failed proof" 
                (verify path3 0) result3)
            , (aCase "test 4, adding a progress property" case4 result4)
            , (aCase "test 5, unless properties" case5 result5)
            ]            
part2 :: TestCase
part2 = test_cases
            "part 2"
            [ (poCase "test 6, verify progress refinement" case6 result6)
            , (poCase "test 7, verify refinement rules" case7 result7)
            , (poCase "test 8, verify refinement rules" case8 result8)
            ]            
part3 :: TestCase
part3 = test_cases
            "part 3"
            [ (poCase "test 9, verify disjunction rule" (verify path9 0) result9)
            , (textCase "test 10, error: cyclic proof" (find_errors path10) result10)
            , (textCase   "test 11, intermediate goals of monotonic \
                              \simplification" case11 result11)
            , (aCase "test 12, bound variable with ambiguous type"
                case12 result12)
            , textCase "test 13, inv6, PO" case13 result13
            ]

result0 :: Text
result0 = T.unlines 
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , " xxx m0/evt/INV/inv3"
    , "passed 32 / 33"
    ]

path0 :: FilePath
path0 = [path|Tests/cubes-t0.tex|]

result1 :: Text
result1 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv3/step 6"
    , "  o  m0/evt/INV/inv4"
    , "passed 44 / 44"
    ]

path1 :: FilePath
path1 = [path|Tests/cubes-t1.tex|]

result2 :: Text
result2 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy"
    , "  o  m0/evt/INV/inv5/main goal/goal"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses"
    , "  o  m0/evt/INV/inv5/main goal/relation"
    , "  o  m0/evt/INV/inv5/main goal/step 1"
    , "  o  m0/evt/INV/inv5/main goal/step 2"
    , "  o  m0/evt/INV/inv5/main goal/step 3"
    , "  o  m0/evt/INV/inv5/main goal/step 4"
    , "  o  m0/evt/INV/inv5/main goal/step 5"
    , "passed 54 / 54"
    ]

path2 :: FilePath
path2 = [path|Tests/cubes-t2.tex|]

result3 :: Text
result3 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy"
    , "  o  m0/evt/INV/inv5/main goal/goal"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses"
    , "  o  m0/evt/INV/inv5/main goal/relation"
    , "  o  m0/evt/INV/inv5/main goal/step 1"
    , "  o  m0/evt/INV/inv5/main goal/step 2"
    , "  o  m0/evt/INV/inv5/main goal/step 3"
    , "  o  m0/evt/INV/inv5/main goal/step 4"
    , "  o  m0/evt/INV/inv5/main goal/step 5"
    , "  o  m0/evt/INV/inv6"
    , "passed 56 / 56"
    ]

path3 :: FilePath
path3 = [path|Tests/cubes-t3.tex|]

result4 :: Either [Error] (Map ProgId ProgressProp)
result4 = M.map (fmap (DispExpr "")) <$> either g Right (do
        q0 <- f `mzeq` zlambda [i_decl] 
            (mzle (mzint (0 :: Int)) i `mzand` mzless i bigN) 
            (mzpow i $ mzint (3 :: Int))
        q1 <- bigN `mzeq` n
        q2 <- (k `mzless` n) `mzor` (n `mzeq` bigN)
        p1  <- (n `mzeq` k)
        p2  <- mzall [k `mzle` n, n `mzeq` k, mznot (n `mzeq` bigN)]
        p3 <-  mzall [n `mzeq` k, mznot (n `mzeq` bigN)]
        q3 <- mzor 
                (mzle k n `mzand` mznot (k `mzeq` n)) 
                (n `mzeq` bigN)
        q4 <- mznot (n `mzeq` k)
        return $ fromList 
            [   ("prog0", LeadsTo [] ztrue q0)
            ,   ("prog1", LeadsTo [] ztrue q1)
            ,   ("prog2", LeadsTo [kdec] p1 q2)
            ,   ("prog3", LeadsTo [kdec] p2 q3)
            ,   ("prog4", LeadsTo [kdec] p3 q4)
            ])
    where
        (k,kdec)   = var "k" int
        (i,i_decl) = var "i" int
        (f,_)      = var "f" (fun_type int int)
        (n,_)      = var "n" int
        (bigN,_)   = var "N" int
        li         = LI path4 0 0
        g xs = Left $ map (`Error` li) xs

path4 :: FilePath
path4 = [path|Tests/cubes-t6.tex|]

case4 :: IO (Either [Error] (Map ProgId ProgressProp))
case4 = runEitherT (do
    ms <- EitherT $ parse path4 :: EitherT [Error] IO [Machine]
    case ms of
        [m] -> right $ m!.props.progress
        _   -> left [Error "a single machine is expected" (LI "" 0 0)])

result5 :: Either [Error] (Map Label SafetyProp)
result5 = M.map (fmap $ DispExpr "") <$> either g Right (do
        q0  <- bigN `mzeq` n
        p0  <- (k `mzle` n)
        q1  <- mznot (n `mzeq` k)
        p1  <- mzall
                [ n `mzeq` k
                , mznot (n `mzeq` bigN)
                ]
        return $ fromList 
            [   (label "saf0", Unless [k_decl] p0 q0)
            ,   (label "saf1", Unless [k_decl] p1 q1)
            ])
    where
        (k,k_decl) = var "k" int
        (n,_)      = var "n" int
        (bigN,_)   = var "N" int
        li         = LI path4 0 0
        g xs = Left $ map (`Error` li) xs

case5 :: IO (Either [Error] (Map Label SafetyProp))
case5 = runEitherT (do
    ms <- EitherT $ parse path4 :: EitherT [Error] IO [Machine]
    case ms of
        [m] -> right $ m!.props.safety
        _   -> left [Error "a single machine is expected" (LI "" 0 0)])

case6 :: IO (Text, Map Label Sequent)
case6 = verify path6 0

result6 :: Text
result6 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , " xxx m0/INIT/INV/inv8"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy"
    , "  o  m0/evt/INV/inv5/main goal/goal"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses"
    , "  o  m0/evt/INV/inv5/main goal/relation"
    , "  o  m0/evt/INV/inv5/main goal/step 1"
    , "  o  m0/evt/INV/inv5/main goal/step 2"
    , "  o  m0/evt/INV/inv5/main goal/step 3"
    , "  o  m0/evt/INV/inv5/main goal/step 4"
    , "  o  m0/evt/INV/inv5/main goal/step 5"
    , "  o  m0/evt/INV/inv6/goal"
    , "  o  m0/evt/INV/inv6/hypotheses"
    , "  o  m0/evt/INV/inv6/relation"
    , "  o  m0/evt/INV/inv6/step 1"
    , "  o  m0/evt/INV/inv6/step 2"
    , "  o  m0/evt/INV/inv6/step 3"
    , "  o  m0/evt/INV/inv6/step 4"
    , " xxx m0/evt/INV/inv6/step 5"
    , "  o  m0/evt/INV/inv8"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SCH/grd0"
    , "  o  m0/prog0/LIVE/monotonicity/rhs"
    , " xxx m0/prog1/LIVE/add"
    , "  o  m0/prog2/LIVE/trading/lhs"
    , "  o  m0/prog2/LIVE/trading/rhs"
    , "  o  m0/prog3/LIVE/PSP/lhs"
    , "  o  m0/prog3/LIVE/PSP/rhs"
    , "  o  m0/prog4/LIVE/discharge/tr/lhs"
    , " xxx m0/prog4/LIVE/discharge/tr/rhs"
    , "  o  m0/tr0/TR/evt/EN"
    , "  o  m0/tr0/TR/evt/NEG"
    , "passed 73 / 77"
    ]

path6 :: FilePath
path6 = [path|Tests/cubes-t5.tex|]

case7 :: IO (Text, Map Label Sequent)
case7 = verify path7 0

result7 :: Text
result7 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy"
    , "  o  m0/evt/INV/inv5/main goal/goal"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses"
    , "  o  m0/evt/INV/inv5/main goal/relation"
    , "  o  m0/evt/INV/inv5/main goal/step 1"
    , "  o  m0/evt/INV/inv5/main goal/step 2"
    , "  o  m0/evt/INV/inv5/main goal/step 3"
    , "  o  m0/evt/INV/inv5/main goal/step 4"
    , "  o  m0/evt/INV/inv5/main goal/step 5"
    , "  o  m0/evt/INV/inv6/goal"
    , "  o  m0/evt/INV/inv6/hypotheses"
    , "  o  m0/evt/INV/inv6/relation"
    , "  o  m0/evt/INV/inv6/step 1"
    , "  o  m0/evt/INV/inv6/step 2"
    , "  o  m0/evt/INV/inv6/step 3"
    , "  o  m0/evt/INV/inv6/step 4"
    , " xxx m0/evt/INV/inv6/step 5"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/prog0/LIVE/monotonicity/rhs"
    , " xxx m0/prog1/LIVE/add"
    , " xxx m0/prog10/LIVE/add"
    , " xxx m0/prog2/LIVE/trading/lhs"
    , "  o  m0/prog2/LIVE/trading/rhs"
    , " xxx m0/prog3/LIVE/PSP/lhs"
    , " xxx m0/prog3/LIVE/PSP/rhs"
    , " xxx m0/prog4/LIVE/add"
    , " xxx m0/prog5/LIVE/transitivity/lhs"
    , "  o  m0/prog5/LIVE/transitivity/mhs/0/1"
    , "  o  m0/prog5/LIVE/transitivity/rhs"
    , " xxx m0/prog6/LIVE/add"
    , " xxx m0/prog7/LIVE/add"
    , "  o  m0/prog8/LIVE/transitivity/mhs/0/1"
    , "  o  m0/prog8/LIVE/transitivity/rhs"
    , " xxx m0/prog9/LIVE/add"
    , "passed 69 / 80"
    ]

path7 :: FilePath
path7 = [path|Tests/cubes-t4.tex|]

case8 :: IO (Text, Map Label Sequent)
case8 = verify path8 0

result8 :: Text
result8 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INIT/INV/inv7"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/goal"
    , "  o  m0/evt/INV/inv5/hypotheses"
    , "  o  m0/evt/INV/inv5/relation"
    , "  o  m0/evt/INV/inv5/step 1"
    , "  o  m0/evt/INV/inv5/step 2"
    , "  o  m0/evt/INV/inv5/step 3"
    , "  o  m0/evt/INV/inv5/step 4"
    , "  o  m0/evt/INV/inv5/step 5"
    , "  o  m0/evt/INV/inv6/goal"
    , "  o  m0/evt/INV/inv6/hypotheses"
    , "  o  m0/evt/INV/inv6/relation"
    , "  o  m0/evt/INV/inv6/step 1"
    , "  o  m0/evt/INV/inv6/step 2"
    , "  o  m0/evt/INV/inv6/step 3"
    , "  o  m0/evt/INV/inv6/step 4"
    , " xxx m0/evt/INV/inv6/step 5"
    , "  o  m0/evt/INV/inv7"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SAF/saf1"
    , "  o  m0/evt/SCH/grd0"
    , "  o  m0/prog0/LIVE/monotonicity/rhs"
    , "  o  m0/prog1/LIVE/induction/lhs"
    , "  o  m0/prog1/LIVE/induction/rhs"
    , "  o  m0/prog2/LIVE/trading/lhs"
    , "  o  m0/prog2/LIVE/trading/rhs"
    , "  o  m0/prog3/LIVE/PSP/lhs"
    , "  o  m0/prog3/LIVE/PSP/rhs"
    , "  o  m0/prog4/LIVE/discharge/saf/lhs"
    , "  o  m0/prog4/LIVE/discharge/saf/rhs"
    , "  o  m0/prog4/LIVE/discharge/tr"
    , "  o  m0/tr0/TR/evt/EN"
    , "  o  m0/tr0/TR/evt/NEG"
    , "passed 78 / 79"
    ]
  
path8 :: FilePath
path8 = [path|Tests/cubes-t7.tex|]

result9 :: Text
result9 = T.unlines
    [ "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal"
    , "  o  m0/INIT/INV/inv3/hypotheses"
    , "  o  m0/INIT/INV/inv3/relation"
    , "  o  m0/INIT/INV/inv3/step 1"
    , "  o  m0/INIT/INV/inv3/step 2"
    , "  o  m0/INIT/INV/inv3/step 3"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INIT/INV/inv7"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/INV/inv0/goal"
    , "  o  m0/evt/INV/inv0/hypotheses"
    , "  o  m0/evt/INV/inv0/relation"
    , "  o  m0/evt/INV/inv0/step 1"
    , "  o  m0/evt/INV/inv0/step 2"
    , "  o  m0/evt/INV/inv0/step 3"
    , "  o  m0/evt/INV/inv0/step 4"
    , "  o  m0/evt/INV/inv0/step 5"
    , "  o  m0/evt/INV/inv1/goal"
    , "  o  m0/evt/INV/inv1/hypotheses"
    , "  o  m0/evt/INV/inv1/relation"
    , "  o  m0/evt/INV/inv1/step 1"
    , "  o  m0/evt/INV/inv1/step 2"
    , "  o  m0/evt/INV/inv1/step 3"
    , "  o  m0/evt/INV/inv1/step 4"
    , "  o  m0/evt/INV/inv1/step 5"
    , "  o  m0/evt/INV/inv1/step 6"
    , "  o  m0/evt/INV/inv1/step 7"
    , "  o  m0/evt/INV/inv2/easy"
    , "  o  m0/evt/INV/inv3/goal"
    , "  o  m0/evt/INV/inv3/hypotheses"
    , "  o  m0/evt/INV/inv3/relation"
    , "  o  m0/evt/INV/inv3/step 1"
    , "  o  m0/evt/INV/inv3/step 2"
    , "  o  m0/evt/INV/inv3/step 3"
    , "  o  m0/evt/INV/inv3/step 4"
    , "  o  m0/evt/INV/inv3/step 5"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/goal"
    , "  o  m0/evt/INV/inv5/hypotheses"
    , "  o  m0/evt/INV/inv5/relation"
    , "  o  m0/evt/INV/inv5/step 1"
    , "  o  m0/evt/INV/inv5/step 2"
    , "  o  m0/evt/INV/inv5/step 3"
    , "  o  m0/evt/INV/inv5/step 4"
    , "  o  m0/evt/INV/inv5/step 5"
    , "  o  m0/evt/INV/inv6/goal"
    , "  o  m0/evt/INV/inv6/hypotheses"
    , "  o  m0/evt/INV/inv6/relation"
    , "  o  m0/evt/INV/inv6/step 1"
    , "  o  m0/evt/INV/inv6/step 2"
    , "  o  m0/evt/INV/inv6/step 3"
    , "  o  m0/evt/INV/inv6/step 4"
    , " xxx m0/evt/INV/inv6/step 5"
    , "  o  m0/evt/INV/inv7"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SAF/saf1"
    , "  o  m0/evt/SCH/grd0"
    , "  o  m0/prog0/LIVE/monotonicity/rhs"
    , "  o  m0/prog1/LIVE/induction/lhs"
    , "  o  m0/prog1/LIVE/induction/rhs"
    , "  o  m0/prog2/LIVE/trading/lhs"
    , "  o  m0/prog2/LIVE/trading/rhs"
    , "  o  m0/prog3/LIVE/PSP/lhs"
    , "  o  m0/prog3/LIVE/PSP/rhs"
    , "  o  m0/prog4/LIVE/discharge/saf/lhs"
    , "  o  m0/prog4/LIVE/discharge/saf/rhs"
    , "  o  m0/prog4/LIVE/discharge/tr"
    , "  o  m0/prog5/LIVE/disjunction/lhs"
    , "  o  m0/prog5/LIVE/disjunction/rhs"
    , " xxx m0/prog6/LIVE/add"
    , " xxx m0/prog7/LIVE/add"
    , " xxx m0/prog8/LIVE/add"
    , "  o  m0/tr0/TR/evt/EN"
    , "  o  m0/tr0/TR/evt/NEG"
    , "passed 75 / 79"
    ]

path9 :: FilePath
path9 = [path|Tests/cubes-t8.tex|]
     
path10 :: FilePath
path10 = [path|Tests/cubes-t9.tex|]

result10 :: Text
result10 = T.unlines
    [ "A cycle exists in the liveness proof"
    , "error 339:1:"
    , "\tProgress property prog0 (refined in m0)"
    , ""
    , "error 341:1:"
    , "\tProgress property prog1 (refined in m0)"
    , ""
    , "error 343:1:"
    , "\tProgress property prog2 (refined in m0)"
    , ""
    , "error 347:1:"
    , "\tProgress property prog3 (refined in m0)"
    , ""
    ]

case11 :: IO Text
case11 = do
        proof_obligation path2 "m0/evt/INV/inv5/main goal/step 4" 0
        -- pos <- list_file_obligations path2
        -- case pos of
        --     Right [(_,pos)] -> do
        --         let po = pos ! label "m0/evt/INV/inv5/main goal/step (287,1)"
        --             cmd = T.unlines $ map pretty_print' $ z3_code po
        --         return cmd
        --     x -> return $ show x

result11 :: Text
result11 = T.unlines 
    [ "; m0/evt/INV/inv5/main goal/step 4"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const a Int)"
    , "(declare-const a@prime Int)"
    , "(declare-const b Int)"
    , "(declare-const b@prime Int)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const f (pfun Int Int))"
    , "(declare-const f@prime (pfun Int Int))"
    , "(declare-const i Int)"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-fun apply@@Int@@Int ( (pfun Int Int) Int ) Int)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun dom@@Int@@Int ( (pfun Int Int) ) (set Int))"
    , "(declare-fun dom-rest@@Int@@Int"
    , "             ( (set Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun dom-subt@@Int@@Int"
    , "             ( (set Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun empty-fun@@Int@@Int () (pfun Int Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun injective@@Int@@Int ( (pfun Int Int) ) Bool)"
    , "(declare-fun mk-fun@@Int@@Int (Int Int) (pfun Int Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun ovl@@Int@@Int"
    , "             ( (pfun Int Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun ran@@Int@@Int ( (pfun Int Int) ) (set Int))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (i Int) )"
    , "                (! (= (elem@@Int i (dom@@Int@@Int f))"
    , "                      (and (<= 0 i) (< i n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int i (dom@@Int@@Int f)) ))))"
    , "(assert (= f@prime (ovl@@Int@@Int f (mk-fun@@Int@@Int n a))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (= (dom@@Int@@Int empty-fun@@Int@@Int)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (ovl@@Int@@Int f1 empty-fun@@Int@@Int) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int f1 empty-fun@@Int@@Int) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (ovl@@Int@@Int empty-fun@@Int@@Int f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int empty-fun@@Int@@Int f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (dom@@Int@@Int (mk-fun@@Int@@Int x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (mk-fun@@Int@@Int x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Int f2))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)"
    , "                          (apply@@Int@@Int f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Int f2))))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Int f1)))"
    , "                       (= (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                       (= (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int)) )"
    , "                (! (= (dom@@Int@@Int (ovl@@Int@@Int f1 f2))"
    , "                      (union (dom@@Int@@Int f1) (dom@@Int@@Int f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (ovl@@Int@@Int f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1))"
    , "                      (intersect s1 (dom@@Int@@Int f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                           (= (apply@@Int@@Int f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@Int f1))"
    , "                     (apply@@Int@@Int f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y Int) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2)"
    , "                          (apply@@Int@@Int f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x) ))))"
    , "(assert (= (ran@@Int@@Int empty-fun@@Int@@Int)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (ran@@Int@@Int f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                                        (= (apply@@Int@@Int f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (ran@@Int@@Int f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (ran@@Int@@Int (mk-fun@@Int@@Int x y))"
    , "                      (mk-set@@Int y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (mk-fun@@Int@@Int x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (injective@@Int@@Int f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Int f1)))"
    , "                                  (=> (= (apply@@Int@@Int f1 x) (apply@@Int@@Int f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Int f1) ))))"
    , "(assert (injective@@Int@@Int empty-fun@@Int@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Int f1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                  (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Int f1) s1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                  (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                            (injective@@Int@@Int f1))"
    , "                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))"
    , "                          (union (set-diff@@Int (ran@@Int@@Int f1)"
    , "                                                (mk-set@@Int (apply@@Int@@Int f1 x)))"
    , "                                 (mk-set@@Int y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Int f1)))"
    , "                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))"
    , "                          (union (ran@@Int@@Int f1) (mk-set@@Int y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (forall ( (i Int) )"
    , "                (! (= (elem@@Int i (dom@@Int@@Int f))"
    , "                      (and (<= 0 i) (< i n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int i (dom@@Int@@Int f)) ))))"
    , "(assert (not (= (forall ( (i Int) )"
    , "                        (=> (and (<= 0 i) (< i n))"
    , "                            (= (apply@@Int@@Int f@prime i) (^ i 3))))"
    , "                (forall ( (i Int) )"
    , "                        (=> (and (<= 0 i) (< i n))"
    , "                            (= (apply@@Int@@Int f i) (^ i 3)))))))"
    , "(assert (not (forall ( (i Int) )"
    , "                     (=> true"
    , "                         (= (=> (and (<= 0 i) (< i n))"
    , "                                (= (apply@@Int@@Int f@prime i) (^ i 3)))"
    , "                            (=> (and (<= 0 i) (< i n))"
    , "                                (= (apply@@Int@@Int f i) (^ i 3))))))))"
    , "(assert (not (= (=> (and (<= 0 i) (< i n))"
    , "                    (= (apply@@Int@@Int f@prime i) (^ i 3)))"
    , "                (=> (and (<= 0 i) (< i n))"
    , "                    (= (apply@@Int@@Int f i) (^ i 3))))))"
    , "(assert (not (= (= (apply@@Int@@Int f@prime i) (^ i 3))"
    , "                (= (apply@@Int@@Int f i) (^ i 3)))))"
    , "(assert (not (= (apply@@Int@@Int f@prime i) (apply@@Int@@Int f i))))"
    , "(assert (not (= f@prime f)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m0/evt/INV/inv5/main goal/step 4"
    ]

path12 :: FilePath
path12 = [path|Tests/cubes-t10.tex|]

result12 :: Text
result12 = T.unlines 
        [  "error 274:3:\n    type of j is ill-defined: _a"
        ]

case12 :: IO Text
case12 = find_errors path12

case13 :: IO Text
case13 = proof_obligation path3 "m0/evt/INV/inv6" 0

result13 :: Text
result13 = T.unlines
    [ "; m0/evt/INV/inv6"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const a Int)"
    , "(declare-const a@prime Int)"
    , "(declare-const b Int)"
    , "(declare-const b@prime Int)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const f (pfun Int Int))"
    , "(declare-const f@prime (pfun Int Int))"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-fun apply@@Int@@Int ( (pfun Int Int) Int ) Int)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun const@@Int@@Int (Int) (Array Int Int))"
    , "(declare-fun dom@@Int@@Int ( (pfun Int Int) ) (set Int))"
    , "(declare-fun dom-rest@@Int@@Int"
    , "             ( (set Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun dom-subt@@Int@@Int"
    , "             ( (set Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun empty-fun@@Int@@Int () (pfun Int Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun ident@@Int () (Array Int Int))"
    , "(declare-fun injective@@Int@@Int ( (pfun Int Int) ) Bool)"
    , "(declare-fun lambda@@Int@@Int"
    , "             ( (set Int)"
    , "               (Array Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun mk-fun@@Int@@Int (Int Int) (pfun Int Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun ovl@@Int@@Int"
    , "             ( (pfun Int Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun qsum@@Int ( (set Int) (Array Int Int) ) Int)"
    , "(declare-fun ran@@Int@@Int ( (pfun Int Int) ) (set Int))"
    , "(declare-fun set@@Int@@Int"
    , "             ( (set Int)"
    , "               (Array Int Int) )"
    , "             (set Int))"
    , "(declare-fun @@lambda@@_0 (Int Int) (set Int))"
    , "(declare-fun @@lambda@@_1 (Int) (Array Int Int))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (term (Array Int Int)) )"
    , "                (! (= (qsum@@Int empty-set@@Int term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@Int empty-set@@Int term) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (term (Array Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (not (elem@@Int x r))"
    , "                       (= (qsum@@Int (union r (mk-set@@Int x)) term)"
    , "                          (+ (qsum@@Int r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@Int (union r (mk-set@@Int x)) term) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int))"
    , "                  (term (Array Int Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (qsum@@Int (union r r0) term)"
    , "                          (+ (qsum@@Int r term) (qsum@@Int r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@Int (union r r0) term) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (card@@Int r) (qsum@@Int r (const@@Int@@Int 1)))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (select (const@@Int@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@Int@@Int x) y) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select ident@@Int x) x)"
    , "                   :pattern"
    , "                   ( (select ident@@Int x) ))))"
    , "(assert (= (dom@@Int@@Int empty-fun@@Int@@Int)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (t (Array Int Int)) )"
    , "                (! (= (lambda@@Int@@Int empty-set@@Int t)"
    , "                      empty-fun@@Int@@Int)"
    , "                   :pattern"
    , "                   ( (lambda@@Int@@Int empty-set@@Int t) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (t (Array Int Int)) )"
    , "                (! (= (dom@@Int@@Int (lambda@@Int@@Int r t)) r)"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (lambda@@Int@@Int r t)) ))))"
    , "(assert (forall ( (t (Array Int Int))"
    , "                  (x Int) )"
    , "                (! (= (lambda@@Int@@Int (mk-set@@Int x) t)"
    , "                      (mk-fun@@Int@@Int x (select t x)))"
    , "                   :pattern"
    , "                   ( (lambda@@Int@@Int (mk-set@@Int x) t) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (t (Array Int Int))"
    , "                  (x Int) )"
    , "                (! (= (ovl@@Int@@Int (lambda@@Int@@Int r t)"
    , "                                     (mk-fun@@Int@@Int x (select t x)))"
    , "                      (lambda@@Int@@Int (union r (mk-set@@Int x)) t))"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int (lambda@@Int@@Int r t)"
    , "                                    (mk-fun@@Int@@Int x (select t x))) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int))"
    , "                  (t (Array Int Int)) )"
    , "                (! (= (ovl@@Int@@Int (lambda@@Int@@Int r t) (lambda@@Int@@Int r0 t))"
    , "                      (lambda@@Int@@Int (union r r0) t))"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int (lambda@@Int@@Int r t) (lambda@@Int@@Int r0 t)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (ovl@@Int@@Int f1 empty-fun@@Int@@Int) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int f1 empty-fun@@Int@@Int) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (ovl@@Int@@Int empty-fun@@Int@@Int f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int empty-fun@@Int@@Int f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (dom@@Int@@Int (mk-fun@@Int@@Int x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (mk-fun@@Int@@Int x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Int f2))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)"
    , "                          (apply@@Int@@Int f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Int f2))))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Int f1)))"
    , "                       (= (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                       (= (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int)) )"
    , "                (! (= (dom@@Int@@Int (ovl@@Int@@Int f1 f2))"
    , "                      (union (dom@@Int@@Int f1) (dom@@Int@@Int f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (ovl@@Int@@Int f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1))"
    , "                      (intersect s1 (dom@@Int@@Int f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1)) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (t (Array Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x r)"
    , "                       (= (apply@@Int@@Int (lambda@@Int@@Int r t) x)"
    , "                          (select t x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (lambda@@Int@@Int r t) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                           (= (apply@@Int@@Int f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@Int f1))"
    , "                     (apply@@Int@@Int f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y Int) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2)"
    , "                          (apply@@Int@@Int f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x) ))))"
    , "(assert (= (ran@@Int@@Int empty-fun@@Int@@Int)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (ran@@Int@@Int f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                                        (= (apply@@Int@@Int f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (ran@@Int@@Int f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (ran@@Int@@Int (mk-fun@@Int@@Int x y))"
    , "                      (mk-set@@Int y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (mk-fun@@Int@@Int x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (injective@@Int@@Int f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Int f1)))"
    , "                                  (=> (= (apply@@Int@@Int f1 x) (apply@@Int@@Int f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Int f1) ))))"
    , "(assert (injective@@Int@@Int empty-fun@@Int@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Int f1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                  (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Int f1) s1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                  (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                            (injective@@Int@@Int f1))"
    , "                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))"
    , "                          (union (set-diff@@Int (ran@@Int@@Int f1)"
    , "                                                (mk-set@@Int (apply@@Int@@Int f1 x)))"
    , "                                 (mk-set@@Int y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Int f1)))"
    , "                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))"
    , "                          (union (ran@@Int@@Int f1) (mk-set@@Int y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (r1 (set Int))"
    , "                  (term (Array Int Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (set@@Int@@Int r1 term))"
    , "                      (exists ( (x Int) )"
    , "                              (and (elem@@Int x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (set@@Int@@Int r1 term)) ))))"
    , "(assert (forall ( (r1 (set Int))"
    , "                  (term (Array Int Int))"
    , "                  (y Int) )"
    , "                (! (= (= (set@@Int@@Int r1 term) (mk-set@@Int y))"
    , "                      (forall ( (x Int) )"
    , "                              (=> (elem@@Int x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@Int@@Int r1 term)"
    , "                     (mk-set@@Int y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s2) (not (finite@@Int s1)))"
    , "                       (not (finite@@Int (set-diff@@Int s1 s2))))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (forall ( (r1 (set Int)) )"
    , "                (! (= (set@@Int@@Int r1 ident@@Int) r1)"
    , "                   :pattern"
    , "                   ( (set@@Int@@Int r1 ident@@Int) ))))"
    , "(assert (forall ( (@@fv@@_0 Int)"
    , "                  (@@bv@@_0 Int) )"
    , "                (! (= (select (@@lambda@@_1 @@fv@@_0) @@bv@@_0)"
    , "                      (^ @@bv@@_0 @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (select (@@lambda@@_1 @@fv@@_0) @@bv@@_0) ))))"
    , "(assert (forall ( (@@fv@@_0 Int)"
    , "                  (@@fv@@_1 Int)"
    , "                  (@@bv@@_0 Int) )"
    , "                (! (= (elem@@Int @@bv@@_0 (@@lambda@@_0 @@fv@@_0 @@fv@@_1))"
    , "                      (and (<= @@fv@@_0 @@bv@@_0) (< @@bv@@_0 @@fv@@_1)))"
    , "                   :pattern"
    , "                   ( (elem@@Int @@bv@@_0 (@@lambda@@_0 @@fv@@_0 @@fv@@_1)) ))))"
    , "; a0"
    , "(assert (= n@prime (+ n 1)))"
    , "; a1"
    , "(assert (= a@prime (+ a b)))"
    , "; a2"
    , "(assert (= b@prime (+ b c)))"
    , "; a3"
    , "(assert (= c@prime (+ c 6)))"
    , "; a4"
    , "(assert (= f@prime (ovl@@Int@@Int f (mk-fun@@Int@@Int n a))))"
    , "; inv0"
    , "(assert (= a (^ n 3)))"
    , "; inv1"
    , "(assert (= b (+ (+ (* 3 (^ n 2)) (* 3 n)) 1)))"
    , "; inv2"
    , "(assert (= c (+ (* 6 n) 6)))"
    , "; inv3"
    , "(assert (= f"
    , "           (lambda@@Int@@Int (@@lambda@@_0 0 n) (@@lambda@@_1 3))))"
    , "; inv4"
    , "(assert (<= 0 n))"
    , "; inv5"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (and (<= 0 i) (< i n))"
    , "                       (= (apply@@Int@@Int f i) (^ i 3)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int f i) ))))"
    , "; inv6"
    , "(assert (= (dom@@Int@@Int f)"
    , "           (set@@Int@@Int (@@lambda@@_0 0 n) ident@@Int)))"
    , "(assert (not (= (dom@@Int@@Int f@prime)"
    , "                (set@@Int@@Int (@@lambda@@_0 0 n@prime) ident@@Int))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m0/evt/INV/inv6"
    ]
