module Language.UnitB.Parser.Tests.IndirectEq where

import Language.UnitB.Parser
import Language.UnitB.Parser.Tests.Suite

import Language.UnitB.PO
import Language.UnitB.Syntax

import Logic.Expr
import Logic.Proof

import Z3.Z3 ( z3_code )

    -- Libraries
import Data.HashMap.Lazy as M hiding (split, map)

import Control.Monad.Trans.Either

import Test.UnitTest

import Text.Printf.TH

import Utilities.Syntactic

test_case :: TestCase
test_case = test

test :: TestCase
test = test_cases
            "theories and proofs"
            [ POCase "verify proof with galois connections" case0 result0
            , POCase "verify theory 1: indirect (in)equality" case1 result1
            , POCase "verify theory 2: lattices" case2 result2
            , POCase "proofs by symmetry: PO" case3 result3
            , aCase "proofs by symmetry: hypotheses labels" case4 result4
            , aCase "cyclic references between proofs" case5 result5
            , POCase "referring to theorems in automatic proofs (failure)" case6 result6
            , aCase "partial instantiation of theorems in calc. hints" case7 result7
            ]

path0 :: FilePath
path0 = [path|Tests/indirect-equality.tex|]

path1 :: FilePath
path1 = [path|Tests/indirect-equality-t1.tex|]

path2 :: FilePath
path2 = [path|Tests/indirect-equality-t2.tex|]

path3 :: FilePath
path3 = [path|Tests/indirect-equality-t3.tex|]

case0 :: IO (String, HashMap Label Sequent)
case0 = verify path0 0

result0 :: String
result0 = unlines 
    [ " xxx m0/INIT/INV/inv0/assertion/indirect:eq/easy (53,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/goal (55,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/hypotheses (55,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/relation (55,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/step (57,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/step (59,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/step (61,1)"
    , "  o  m0/INIT/INV/inv0/assertion/new:goal/step (63,1)"
    , "  o  m0/INIT/INV/inv0/main goal/easy (53,1)"
    , "  o  m0/INIT/INV/inv1/completeness (78,1)"
    , "  o  m0/INIT/INV/inv1/part 1/easy (80,2)"
    , "  o  m0/INIT/INV/inv1/part 2/goal (89,2)"
    , "  o  m0/INIT/INV/inv1/part 2/hypotheses (89,2)"
    , "  o  m0/INIT/INV/inv1/part 2/new assumption (84,2)"
    , "  o  m0/INIT/INV/inv1/part 2/relation (89,2)"
    , "  o  m0/INIT/INV/inv1/part 2/step (91,2)"
    , "  o  m0/INIT/INV/inv1/part 2/step (93,2)"
    , "  o  m0/INIT/INV/inv1/part 2/step (96,2)"
    , "  o  m0/INIT/WD"
    , " xxx m0/INV/WD"
    , "passed 18 / 20"
    ]
    
case1 :: IO (String, HashMap Label Sequent)
case1 = verify_thy path0 "ctx0"

result1 :: String
result1 = unlines
    [ "  o  THM/thm0/completeness (131,1)"
    , "  o  THM/thm0/part 1/easy (133,2)"
    , "  o  THM/thm0/part 2/goal (143,2)"
    , "  o  THM/thm0/part 2/hypotheses (143,2)"
    , "  o  THM/thm0/part 2/new assumption (138,2)"
    , "  o  THM/thm0/part 2/relation (143,2)"
    , "  o  THM/thm0/part 2/step (145,2)"
    , "  o  THM/thm0/part 2/step (147,2)"
    , "  o  THM/thm0/part 2/step (150,2)"
    , "  o  THM/thm1/completeness (162,1)"
    , "  o  THM/thm1/part 1/goal (165,2)"
    , "  o  THM/thm1/part 1/hypotheses (165,2)"
    , "  o  THM/thm1/part 1/relation (165,2)"
    , "  o  THM/thm1/part 1/step (167,2)"
    , "  o  THM/thm1/part 2/goal (173,2)"
    , "  o  THM/thm1/part 2/hypotheses (173,2)"
    , "  o  THM/thm1/part 2/relation (173,2)"
    , "  o  THM/thm1/part 2/step (175,2)"
    , "  o  THM/thm1/part 2/step (177,2)"
    ]

case2 :: IO (String, HashMap Label Sequent)
case2 = verify_thy path0 "ctx1"

result2 :: String
result2 = unlines
    [ "  o  THM/ctx1:thm10/assertion/indirect:eq/easy (482,24)"
    , "  o  THM/ctx1:thm10/assertion/new:goal/goal (483,41)"
    , "  o  THM/ctx1:thm10/assertion/new:goal/hypotheses (483,41)"
    , "  o  THM/ctx1:thm10/assertion/new:goal/relation (483,41)"
    , "  o  THM/ctx1:thm10/assertion/new:goal/step (485,20)"
    , "  o  THM/ctx1:thm10/main goal/easy (482,24)"
    , "  o  THM/ctx1:thm11/completeness (506,24)"
    , "  o  THM/ctx1:thm11/new assumption (498,1)"
    , "  o  THM/ctx1:thm11/part 1/easy (516,1)"
    , "  o  THM/ctx1:thm11/part 2/goal (526,1)"
    , "  o  THM/ctx1:thm11/part 2/hypotheses (526,1)"
    , "  o  THM/ctx1:thm11/part 2/new assumption (518,13)"
    , "  o  THM/ctx1:thm11/part 2/relation (526,1)"
    , "  o  THM/ctx1:thm11/part 2/step (528,1)"
    , "  o  THM/ctx1:thm11/part 2/step (533,1)"
    , "  o  THM/ctx1:thm11/part 2/step (535,1)"
    , "  o  THM/ctx1:thm11/part 2/step (537,1)"
    , "  o  THM/ctx1:thm3/goal (213,1)"
    , "  o  THM/ctx1:thm3/hypotheses (213,1)"
    , "  o  THM/ctx1:thm3/relation (213,1)"
    , "  o  THM/ctx1:thm3/step (216,1)"
    , "  o  THM/ctx1:thm3/step (219,1)"
    , "  o  THM/ctx1:thm3/step (221,1)"
    , "  o  THM/ctx1:thm4/assertion/indirect:eq/easy (236,24)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/goal (237,41)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/hypotheses (237,41)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/relation (237,41)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/step (240,1)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/step (242,1)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/step (244,1)"
    , " xxx THM/ctx1:thm4/assertion/new:goal/step (246,1)"
    , "  o  THM/ctx1:thm4/main goal/easy (236,24)"
    , "  o  THM/ctx1:thm5/goal (263,1)"
    , "  o  THM/ctx1:thm5/hypotheses (263,1)"
    , "  o  THM/ctx1:thm5/relation (263,1)"
    , "  o  THM/ctx1:thm5/step (266,1)"
    , "  o  THM/ctx1:thm5/step (268,1)"
    , "  o  THM/ctx1:thm5/step (270,1)"
    , "  o  THM/ctx1:thm5/step (272,1)"
    , "  o  THM/ctx1:thm6/goal (288,1)"
    , "  o  THM/ctx1:thm6/hypotheses (288,1)"
    , "  o  THM/ctx1:thm6/relation (288,1)"
    , "  o  THM/ctx1:thm6/step (291,1)"
    , "  o  THM/ctx1:thm6/step (293,1)"
    , "  o  THM/ctx1:thm6/step (295,1)"
    , "  o  THM/ctx1:thm6/step (297,1)"
    , "  o  THM/ctx1:thm7/goal (324,1)"
    , "  o  THM/ctx1:thm7/hypotheses (324,1)"
    , "  o  THM/ctx1:thm7/new assumption (313,1)"
    , "  o  THM/ctx1:thm7/relation (324,1)"
    , "  o  THM/ctx1:thm7/step (327,1)"
    , "  o  THM/ctx1:thm7/step (329,1)"
    , "  o  THM/ctx1:thm7/step (331,1)"
    , "  o  THM/ctx1:thm7/step (333,1)"
    , "  o  THM/ctx1:thm8/completeness (349,27)"
    , "  o  THM/ctx1:thm8/part 1/goal (357,1)"
    , "  o  THM/ctx1:thm8/part 1/hypotheses (357,1)"
    , "  o  THM/ctx1:thm8/part 1/relation (357,1)"
    , "  o  THM/ctx1:thm8/part 1/step (360,1)"
    , "  o  THM/ctx1:thm8/part 2/goal (372,27)"
    , "  o  THM/ctx1:thm8/part 2/hypotheses (372,27)"
    , "  o  THM/ctx1:thm8/part 2/new assumption (366,13)"
    , "  o  THM/ctx1:thm8/part 2/relation (372,27)"
    , "  o  THM/ctx1:thm8/part 2/step (375,1)"
    , "  o  THM/ctx1:thm8/part 2/step (377,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/indirect:ineq/easy (400,41)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/goal (401,43)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/hypotheses (401,43)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/relation (401,43)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/step (404,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/step (406,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/step (408,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/main goal/easy (400,41)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/new assumption (399,33)"
    , "  o  THM/ctx1:thm9/main goal/case 1/easy (399,33)"
    , "  o  THM/ctx1:thm9/main goal/case 2/easy (399,33)"
    , "  o  THM/ctx1:thm9/main goal/completeness (399,33)"
    , "  o  THM/ctx1:thm9/new assumption (393,1)"
    ]

case3 :: IO (String, HashMap Label Sequent)
case3 = verify_thy path1 "ctx2"

result3 :: String
result3 = unlines
    [ "  o  THM/thm4/case 1/easy (310,2)"
    , "  o  THM/thm4/case 2/assertion/symmetry/goal (315,2)"
    , "  o  THM/thm4/case 2/assertion/symmetry/hypotheses (315,2)"
    , "  o  THM/thm4/case 2/assertion/symmetry/new assumption (314,2)"
    , "  o  THM/thm4/case 2/assertion/symmetry/relation (315,2)"
    , "  o  THM/thm4/case 2/assertion/symmetry/step (317,2)"
    , "  o  THM/thm4/case 2/assertion/symmetry/step (319,2)"
    , " xxx THM/thm4/case 2/assertion/symmetry/step (321,2)"
    , "  o  THM/thm4/case 2/main goal/case 1/easy (314,2)"
    , "  o  THM/thm4/case 2/main goal/case 2/easy (314,2)"
    , "  o  THM/thm4/case 2/main goal/completeness (314,2)"
    , "  o  THM/thm4/completeness (308,1)"
    , "  o  THM/thm4/new assumption (300,23)"
    ]

case4 :: IO String
case4 = get_po "ctx2" $ label "THM/thm4/case 2/assertion/symmetry/easy (458,2)"

result4 :: String
result4 = unlines
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const i Int)"
    , "(declare-const j Int)"
    , "(declare-const k Int)"
    , "(declare-const swap (pfun (Pair (Pair Int Int) Int) Int))"
    , "(declare-fun apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "             ( (pfun (Pair (Pair Int Int) Int) Int)"
    , "               (Pair (Pair Int Int) Int) )"
    , "             Int)"
--    , "(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))"
--    , "(declare-fun bunion@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (set (Pair (Pair Int Int) Int)) )"
--    , "             (set (Pair (Pair Int Int) Int)))"
--    , "(declare-fun dom-rest@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (pfun (Pair (Pair Int Int) Int) Int) )"
--    , "             (pfun (Pair (Pair Int Int) Int) Int))"
--    , "(declare-fun dom-subt@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (pfun (Pair (Pair Int Int) Int) Int) )"
--    , "             (pfun (Pair (Pair Int Int) Int) Int))"
--    , "(declare-fun dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
--    , "             ( (pfun (Pair (Pair Int Int) Int) Int) )"
--    , "             (set (Pair (Pair Int Int) Int)))"
--    , "(declare-fun elem@@Int (Int (set Int)) Bool)"
--    , "(declare-fun elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ( (Pair (Pair Int Int) Int)"
--    , "               (set (Pair (Pair Int Int) Int)) )"
--    , "             Bool)"
    , "(declare-fun empty-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "             ()"
    , "             (pfun (Pair (Pair Int Int) Int) Int))"
--    , "(declare-fun empty-set@@Int () (set Int))"
--    , "(declare-fun empty-set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ()"
--    , "             (set (Pair (Pair Int Int) Int)))"
--    , "(declare-fun intersect@@Int"
--    , "             ( (set Int)"
--    , "               (set Int) )"
--    , "             (set Int))"
--    , "(declare-fun intersect@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (set (Pair (Pair Int Int) Int)) )"
--    , "             (set (Pair (Pair Int Int) Int)))"
    , "(declare-fun injective@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "             ( (pfun (Pair (Pair Int Int) Int) Int) )"
    , "             Bool)"
    , "(declare-fun mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "             ( (Pair (Pair Int Int) Int)"
    , "               Int )"
    , "             (pfun (Pair (Pair Int Int) Int) Int))"
--    , "(declare-fun mk-set@@Int (Int) (set Int))"
--    , "(declare-fun mk-set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ( (Pair (Pair Int Int) Int) )"
--    , "             (set (Pair (Pair Int Int) Int)))"
    , "(declare-fun ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "             ( (pfun (Pair (Pair Int Int) Int) Int)"
    , "               (pfun (Pair (Pair Int Int) Int) Int) )"
    , "             (pfun (Pair (Pair Int Int) Int) Int))"
--    , "(declare-fun ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
--    , "             ( (pfun (Pair (Pair Int Int) Int) Int) )"
--    , "             (set Int))"
--    , "(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))"
--    , "(declare-fun set-diff@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (set (Pair (Pair Int Int) Int)) )"
--    , "             (set (Pair (Pair Int Int) Int)))"
--    , "(declare-fun set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
--    , "             ( (pfun (Pair (Pair Int Int) Int) Int) )"
--    , "             (set Int))"
--    , "(declare-fun subset@@Int ( (set Int)   (set Int) ) Bool)"
--    , "(declare-fun subset@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (set (Pair (Pair Int Int) Int)) )"
--    , "             Bool)"
--    , "(declare-fun tfun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
--    , "             ( (set (Pair (Pair Int Int) Int))"
--    , "               (set Int) )"
--    , "             (set (pfun (Pair (Pair Int Int) Int) Int)))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (f2 (pfun (Pair (Pair Int Int) Int) Int)) )"
--    , "                (=> true"
--    , "                    (= (bunion@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)"
--    , "                                                                                (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f2))"
--    , "                       (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 f2))))))"
--    , "(assert (= (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int empty-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int)"
--    , "           empty-set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (y Int) )"
--    , "                (=> true"
--    , "                    (= (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y))"
--    , "                       (mk-set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x)))))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (f2 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (x (Pair (Pair Int Int) Int)) )"
--    , "                (=> true"
--    , "                    (=> (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                               (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f2))"
--    , "                        (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 f2)"
--    , "                                                                                        x)"
--    , "                           (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f2 x))))))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (f2 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (x (Pair (Pair Int Int) Int)) )"
--    , "                (=> true"
--    , "                    (=> (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                               (set-diff@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)"
--    , "                                                                                                                                          (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f2)))"
--    , "                        (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 f2)"
--    , "                                                                                        x)"
--    , "                           (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x))))))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int))) )"
--    , "                (=> true"
--    , "                    (= (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (dom-subt@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int s1 f1))"
--    , "                       (set-diff@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)"
--    , "                                                                                  s1)))))"
    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
    , "                  (y Int) )"
    , "                (! (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y)"
    , "                                                                                   x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y)"
    , "                                                                                  x) ))))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int)))"
--    , "                  (x (Pair (Pair Int Int) Int)) )"
--    , "                (=> true"
--    , "                    (=> (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                               (intersect@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close s1"
--    , "                                                                                                                                           (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)))"
--    , "                        (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (dom-rest@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int s1 f1)"
--    , "                                                                                        x)"
--    , "                           (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x))))))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int)))"
--    , "                  (x (Pair (Pair Int Int) Int)) )"
--    , "                (=> true"
--    , "                    (=> (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                               (set-diff@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)"
--    , "                                                                                                                                          s1))"
--    , "                        (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (dom-subt@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int s1 f1)"
--    , "                                                                                        x)"
--    , "                           (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x))))))"
    , "(assert (forall ( (x (Pair (Pair Int Int) Int)) )"
    , "                (! (= (select empty-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "                              x)"
    , "                      (as Nothing (Maybe Int)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int"
    , "                             x) ))))"
    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
    , "                  (x2 (Pair (Pair Int Int) Int))"
    , "                  (y Int) )"
    , "                (! (= (select (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y)"
    , "                              x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Int))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y)"
    , "                             x2) ))))"
    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
    , "                  (f1 (pfun (Pair (Pair Int Int) Int) Int))"
    , "                  (f2 (pfun (Pair (Pair Int Int) Int) Int)) )"
    , "                (! (= (select (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 f2)"
    , "                              x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Int)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 f2)"
    , "                             x) ))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (f1 (pfun (Pair (Pair Int Int) Int) Int)) )"
--    , "                (=> true"
--    , "                    (= (select (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)"
--    , "                               x)"
--    , "                       (not (= (select f1 x) (as Nothing (Maybe Int))))))))"
--    , "(assert (forall ( (y Int)"
--    , "                  (f1 (pfun (Pair (Pair Int Int) Int) Int)) )"
--    , "                (=> true"
--    , "                    (= (elem@@Int y"
--    , "                                  (set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1))"
--    , "                       (exists ( (x (Pair (Pair Int Int) Int)) )"
--    , "                               (and (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                                           (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1))"
--    , "                                    (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x)"
--    , "                                       y)))))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (y Int)"
--    , "                  (f1 (pfun (Pair (Pair Int Int) Int) Int)) )"
--    , "                (=> true"
--    , "                    (= (and (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                                   (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1))"
--    , "                            (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x)"
--    , "                               y))"
--    , "                       (= (select f1 x) (Just y))))))"
    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
    , "                  (x2 (Pair (Pair Int Int) Int))"
    , "                  (x (Pair (Pair Int Int) Int))"
    , "                  (y Int) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1"
    , "                                                                                                                                                  (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y))"
    , "                                                                                       x2)"
    , "                          (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1"
    , "                                                                                                                                             (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y))"
    , "                                                                                  x2) ))))"
    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
    , "                  (x (Pair (Pair Int Int) Int))"
    , "                  (y Int) )"
    , "                (! (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1"
    , "                                                                                                                                              (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y))"
    , "                                                                                   x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1"
    , "                                                                                                                                             (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y))"
    , "                                                                                  x) ))))"
--    , "(assert (= (ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int empty-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int)"
--    , "           empty-set@@Int))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (y Int) )"
--    , "                (=> true"
--    , "                    (= (elem@@Int y"
--    , "                                  (ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1))"
--    , "                       (exists ( (x (Pair (Pair Int Int) Int)) )"
--    , "                               (and true"
--    , "                                    (and (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                                                (dom@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1))"
--    , "                                         (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 x)"
--    , "                                            y))))))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (y Int) )"
--    , "                (=> true"
--    , "                    (= (ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (mk-fun@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int x y))"
--    , "                       (mk-set@@Int y)))))"
--    , "(assert (forall ( (f1 (pfun (Pair (Pair Int Int) Int) Int))"
--    , "                  (f2 (pfun (Pair (Pair Int Int) Int) Int)) )"
--    , "                (=> true"
--    , "                    (subset@@Int (ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int (ovl@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1 f2))"
--    , "                                 (bunion@@Int (ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f1)"
--    , "                                              (ran@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int f2))))))"
--    , "(assert (forall ( (x Int)"
--    , "                  (y Int) )"
--    , "                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))"
--    , "(assert (forall ( (x Int)"
--    , "                  (s1 (set Int))"
--    , "                  (s2 (set Int)) )"
--    , "                (=> true"
--    , "                    (= (elem@@Int x (set-diff@@Int s1 s2))"
--    , "                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))"
--    , "(assert (forall ( (x Int)"
--    , "                  (s1 (set Int))"
--    , "                  (s2 (set Int)) )"
--    , "                (=> true"
--    , "                    (= (elem@@Int x (intersect@@Int s1 s2))"
--    , "                       (and (elem@@Int x s1) (elem@@Int x s2))))))"
--    , "(assert (forall ( (x Int)"
--    , "                  (s1 (set Int))"
--    , "                  (s2 (set Int)) )"
--    , "                (=> true"
--    , "                    (= (elem@@Int x (bunion@@Int s1 s2))"
--    , "                       (or (elem@@Int x s1) (elem@@Int x s2))))))"
--    , "(assert (forall ( (x Int) )"
--    , "                (=> true (not (elem@@Int x empty-set@@Int)))))"
--    , "(assert (forall ( (x Int)"
--    , "                  (s1 (set Int)) )"
--    , "                (=> true (= (elem@@Int x s1) (select s1 x)))))"
--    , "(assert (forall ( (s1 (set Int))"
--    , "                  (s2 (set Int)) )"
--    , "                (=> true"
--    , "                    (= (subset@@Int s1 s2)"
--    , "                       (forall ( (x Int) )"
--    , "                               (=> true (=> (elem@@Int x s1) (elem@@Int x s2))))))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (y (Pair (Pair Int Int) Int)) )"
--    , "                (=> true"
--    , "                    (= (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                              (mk-set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close y))"
--    , "                       (= x y)))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int)))"
--    , "                  (s2 (set (Pair (Pair Int Int) Int))) )"
--    , "                (=> true"
--    , "                    (= (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                              (set-diff@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close s1 s2))"
--    , "                       (and (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s1)"
--    , "                            (not (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s2)))))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int)))"
--    , "                  (s2 (set (Pair (Pair Int Int) Int))) )"
--    , "                (=> true"
--    , "                    (= (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                              (intersect@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close s1 s2))"
--    , "                       (and (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s1)"
--    , "                            (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s2))))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int)))"
--    , "                  (s2 (set (Pair (Pair Int Int) Int))) )"
--    , "                (=> true"
--    , "                    (= (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                              (bunion@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close s1 s2))"
--    , "                       (or (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s1)"
--    , "                           (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s2))))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int)) )"
--    , "                (=> true"
--    , "                    (not (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x"
--    , "                                                                                empty-set@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close)))))"
--    , "(assert (forall ( (x (Pair (Pair Int Int) Int))"
--    , "                  (s1 (set (Pair (Pair Int Int) Int))) )"
--    , "                (=> true"
--    , "                    (= (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s1)"
--    , "                       (select s1 x)))))"
--    , "(assert (forall ( (s1 (set (Pair (Pair Int Int) Int)))"
--    , "                  (s2 (set (Pair (Pair Int Int) Int))) )"
--    , "                (=> true"
--    , "                    (= (subset@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close s1 s2)"
--    , "                       (forall ( (x (Pair (Pair Int Int) Int)) )"
--    , "                               (=> true"
--    , "                                   (=> (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s1)"
--    , "                                       (elem@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close x s2))))))))"
    , "; axm0"
    , "(assert (forall ( (i Int)"
    , "                  (j Int)"
    , "                  (k Int) )"
    , "                (! (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) k))"
    , "                      (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair j i) k)))"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) k)) ))))"
    , "; axm1"
    , "(assert (forall ( (i Int)"
    , "                  (j Int) )"
    , "                (! (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) i))"
    , "                      j)"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) i)) ))))"
    , "; axm2"
    , "(assert (forall ( (i Int)"
    , "                  (j Int) )"
    , "                (! (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) j))"
    , "                      i)"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) j)) ))))"
    , "; axm3"
    , "(assert (forall ( (i Int)"
    , "                  (j Int)"
    , "                  (k Int) )"
    , "                (! (=> (and (not (= k i)) (not (= k j)))"
    , "                       (= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) k))"
    , "                          k))"
    , "                   :pattern"
    , "                   ( (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) k)) ))))"
    , "; ctx2:thm4:hyp0"
    , "(assert (<= i k))"
    , "; ctx2:thm4:hyp1"
    , "(assert (<= j k))"
    , "; ctx2:thm4:hyp3"
    , "(assert (= i k))"
    , "(assert (not (<= (apply@Open@@Pair@Open@@Pair@@Int@@Int@Close@@Int@Close@@Int swap (pair (pair i j) k))"
    , "                 k)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

case5 :: IO String
case5 = find_errors path2

result5 :: String
result5 = "Error \"A cycle exists in the proofs of ctx1: thm3, thm5\" (1,1)\n"

case6 :: IO (String, HashMap Label Sequent)
case6 = verify_thy path3 "ctx1"

result6 :: String
result6 = unlines
    [ " xxx THM/ctx1:thm10"
    , "  o  THM/ctx1:thm3/goal (213,1)"
    , "  o  THM/ctx1:thm3/hypotheses (213,1)"
    , "  o  THM/ctx1:thm3/relation (213,1)"
    , "  o  THM/ctx1:thm3/step (216,1)"
    , "  o  THM/ctx1:thm3/step (219,1)"
    , "  o  THM/ctx1:thm3/step (221,1)"
    , "  o  THM/ctx1:thm4/assertion/indirect:eq/easy (236,24)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/goal (237,41)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/hypotheses (237,41)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/relation (237,41)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/step (240,1)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/step (242,1)"
    , "  o  THM/ctx1:thm4/assertion/new:goal/step (244,1)"
    , " xxx THM/ctx1:thm4/assertion/new:goal/step (246,1)"
    , "  o  THM/ctx1:thm4/main goal/easy (236,24)"
    , "  o  THM/ctx1:thm5/goal (263,1)"
    , "  o  THM/ctx1:thm5/hypotheses (263,1)"
    , "  o  THM/ctx1:thm5/relation (263,1)"
    , "  o  THM/ctx1:thm5/step (266,1)"
    , "  o  THM/ctx1:thm5/step (268,1)"
    , "  o  THM/ctx1:thm5/step (270,1)"
    , "  o  THM/ctx1:thm5/step (272,1)"
    , "  o  THM/ctx1:thm6/goal (288,1)"
    , "  o  THM/ctx1:thm6/hypotheses (288,1)"
    , "  o  THM/ctx1:thm6/relation (288,1)"
    , "  o  THM/ctx1:thm6/step (291,1)"
    , "  o  THM/ctx1:thm6/step (293,1)"
    , "  o  THM/ctx1:thm6/step (295,1)"
    , "  o  THM/ctx1:thm6/step (297,1)"
    , "  o  THM/ctx1:thm7/goal (324,1)"
    , "  o  THM/ctx1:thm7/hypotheses (324,1)"
    , "  o  THM/ctx1:thm7/new assumption (313,1)"
    , "  o  THM/ctx1:thm7/relation (324,1)"
    , "  o  THM/ctx1:thm7/step (327,1)"
    , "  o  THM/ctx1:thm7/step (329,1)"
    , "  o  THM/ctx1:thm7/step (331,1)"
    , "  o  THM/ctx1:thm7/step (333,1)"
    , "  o  THM/ctx1:thm8/completeness (349,27)"
    , "  o  THM/ctx1:thm8/part 1/goal (357,1)"
    , "  o  THM/ctx1:thm8/part 1/hypotheses (357,1)"
    , "  o  THM/ctx1:thm8/part 1/relation (357,1)"
    , "  o  THM/ctx1:thm8/part 1/step (360,1)"
    , "  o  THM/ctx1:thm8/part 2/goal (372,27)"
    , "  o  THM/ctx1:thm8/part 2/hypotheses (372,27)"
    , "  o  THM/ctx1:thm8/part 2/new assumption (366,13)"
    , "  o  THM/ctx1:thm8/part 2/relation (372,27)"
    , "  o  THM/ctx1:thm8/part 2/step (375,1)"
    , "  o  THM/ctx1:thm8/part 2/step (377,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/indirect:ineq/easy (400,31)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/goal (401,43)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/hypotheses (401,43)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/relation (401,43)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/step (404,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/step (406,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/assertion/new:goal/step (408,1)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/main goal/easy (400,31)"
    , "  o  THM/ctx1:thm9/assertion/symmetry/new assumption (399,1)"
    , "  o  THM/ctx1:thm9/main goal/case 1/easy (399,1)"
    , " xxx THM/ctx1:thm9/main goal/case 2/easy (399,1)"
    , "  o  THM/ctx1:thm9/main goal/completeness (399,1)"
    , "  o  THM/ctx1:thm9/new assumption (393,1)"
    ]

case7 :: IO String
case7 = get_po "ctx1" (label "THM/ctx1:thm11/part 2/step (528,1)")

result7 :: String
result7 = unlines
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "(define-sort guarded (a) (Maybe a))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort G 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const G (set G))"
    , "(declare-const x G)"
    , "(declare-const y G)"
    , "(declare-const z G)"
--    , "(declare-fun apply@@G@@G ( (pfun G G)   G ) G)"
--    , "(declare-fun bunion@@G ( (set G)   (set G) ) (set G))"
--    , "(declare-fun dom-rest@@G@@G"
--    , "             ( (set G)"
--    , "               (pfun G G) )"
--    , "             (pfun G G))"
--    , "(declare-fun dom-subt@@G@@G"
--    , "             ( (set G)"
--    , "               (pfun G G) )"
--    , "             (pfun G G))"
--    , "(declare-fun dom@@G@@G ( (pfun G G) ) (set G))"
--    , "(declare-fun elem@@G (G (set G)) Bool)"
--    , "(declare-fun empty-fun@@G@@G () (pfun G G))"
--    , "(declare-fun empty-set@@G () (set G))"
--    , "(declare-fun intersect@@G ( (set G)   (set G) ) (set G))"
    , "(declare-fun le (G G) Bool)"
--    , "(declare-fun mk-fun@@G@@G (G G) (pfun G G))"
--    , "(declare-fun mk-set@@G (G) (set G))"
--    , "(declare-fun ovl@@G@@G ( (pfun G G)   (pfun G G) ) (pfun G G))"
--    , "(declare-fun ran@@G@@G ( (pfun G G) ) (set G))"
--    , "(declare-fun set-diff@@G ( (set G)   (set G) ) (set G))"
--    , "(declare-fun set@@G@@G ( (pfun G G) ) (set G))"
--    , "(declare-fun subset@@G ( (set G)   (set G) ) Bool)"
--    , "(declare-fun tfun@@G@@G ( (set G)   (set G) ) (set (pfun G G)))"
    , "(declare-fun up (G G) G)"
        -- This is the line of importance. It is the partially
        -- instantiated property of linearity
    , "(assert (forall ( (p G) )"
    , "                (! (or (le p x) (le x p))"
    , "                   :pattern"
    , "                   ( (le p x)"
    , "                     (le x p) ))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (f2 (pfun G G)) )"
--    , "                (=> true"
--    , "                    (= (bunion@@G (dom@@G@@G f1) (dom@@G@@G f2))"
--    , "                       (dom@@G@@G (ovl@@G@@G f1 f2))))))"
--    , "(assert (= (dom@@G@@G empty-fun@@G@@G) empty-set@@G))"
--    , "(assert (forall ( (x G)"
--    , "                  (y G) )"
--    , "                (=> true"
--    , "                    (= (dom@@G@@G (mk-fun@@G@@G x y)) (mk-set@@G x)))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (f2 (pfun G G))"
--    , "                  (x G) )"
--    , "                (=> true"
--    , "                    (=> (elem@@G x (dom@@G@@G f2))"
--    , "                        (= (apply@@G@@G (ovl@@G@@G f1 f2) x)"
--    , "                           (apply@@G@@G f2 x))))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (f2 (pfun G G))"
--    , "                  (x G) )"
--    , "                (=> true"
--    , "                    (=> (elem@@G x (set-diff@@G (dom@@G@@G f1) (dom@@G@@G f2)))"
--    , "                        (= (apply@@G@@G (ovl@@G@@G f1 f2) x)"
--    , "                           (apply@@G@@G f1 x))))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (s1 (set G)) )"
--    , "                (=> true"
--    , "                    (= (dom@@G@@G (dom-subt@@G@@G s1 f1))"
--    , "                       (set-diff@@G (dom@@G@@G f1) s1)))))"
--    , "(assert (forall ( (x G)"
--    , "                  (y G) )"
--    , "                (=> true (= (apply@@G@@G (mk-fun@@G@@G x y) x) y))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (s1 (set G))"
--    , "                  (x G) )"
--    , "                (=> true"
--    , "                    (=> (elem@@G x (intersect@@G s1 (dom@@G@@G f1)))"
--    , "                        (= (apply@@G@@G (dom-rest@@G@@G s1 f1) x)"
--    , "                           (apply@@G@@G f1 x))))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (s1 (set G))"
--    , "                  (x G) )"
--    , "                (=> true"
--    , "                    (=> (elem@@G x (set-diff@@G (dom@@G@@G f1) s1))"
--    , "                        (= (apply@@G@@G (dom-subt@@G@@G s1 f1) x)"
--    , "                           (apply@@G@@G f1 x))))))"
--    , "(assert (forall ( (x G) )"
--    , "                (=> true"
--    , "                    (= (select empty-fun@@G@@G x) (as Nothing (Maybe G))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (x2 G)"
--    , "                  (y G) )"
--    , "                (=> true"
--    , "                    (= (select (mk-fun@@G@@G x y) x2)"
--    , "                       (ite (= x x2) (Just y) (as Nothing (Maybe G)))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (f1 (pfun G G))"
--    , "                  (f2 (pfun G G)) )"
--    , "                (=> true"
--    , "                    (= (select (ovl@@G@@G f1 f2) x)"
--    , "                       (ite (= (select f2 x) (as Nothing (Maybe G)))"
--    , "                            (select f1 x)"
--    , "                            (select f2 x))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (f1 (pfun G G)) )"
--    , "                (=> true"
--    , "                    (= (select (dom@@G@@G f1) x)"
--    , "                       (not (= (select f1 x) (as Nothing (Maybe G))))))))"
--    , "(assert (forall ( (y G)"
--    , "                  (f1 (pfun G G)) )"
--    , "                (=> true"
--    , "                    (= (elem@@G y (set@@G@@G f1))"
--    , "                       (exists ( (x G) )"
--    , "                               (and (elem@@G x (dom@@G@@G f1))"
--    , "                                    (= (apply@@G@@G f1 x) y)))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (y G)"
--    , "                  (f1 (pfun G G)) )"
--    , "                (=> true"
--    , "                    (= (and (elem@@G x (dom@@G@@G f1))"
--    , "                            (= (apply@@G@@G f1 x) y))"
--    , "                       (= (select f1 x) (Just y))))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (x2 G)"
--    , "                  (x G)"
--    , "                  (y G) )"
--    , "                (=> true"
--    , "                    (=> (not (= x x2))"
--    , "                        (= (apply@@G@@G (ovl@@G@@G f1 (mk-fun@@G@@G x y)) x2)"
--    , "                           (apply@@G@@G f1 x2))))))"
--    , "(assert (= (ran@@G@@G empty-fun@@G@@G) empty-set@@G))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (y G) )"
--    , "                (=> true"
--    , "                    (= (elem@@G y (ran@@G@@G f1))"
--    , "                       (exists ( (x G) )"
--    , "                               (and true"
--    , "                                    (and (elem@@G x (dom@@G@@G f1))"
--    , "                                         (= (apply@@G@@G f1 x) y))))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (y G) )"
--    , "                (=> true"
--    , "                    (= (ran@@G@@G (mk-fun@@G@@G x y)) (mk-set@@G y)))))"
--    , "(assert (forall ( (f1 (pfun G G))"
--    , "                  (f2 (pfun G G)) )"
--    , "                (=> true"
--    , "                    (subset@@G (ran@@G@@G (ovl@@G@@G f1 f2))"
--    , "                               (bunion@@G (ran@@G@@G f1) (ran@@G@@G f2))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (y G) )"
--    , "                (=> true (= (elem@@G x (mk-set@@G y)) (= x y)))))"
--    , "(assert (forall ( (x G)"
--    , "                  (s1 (set G))"
--    , "                  (s2 (set G)) )"
--    , "                (=> true"
--    , "                    (= (elem@@G x (set-diff@@G s1 s2))"
--    , "                       (and (elem@@G x s1) (not (elem@@G x s2)))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (s1 (set G))"
--    , "                  (s2 (set G)) )"
--    , "                (=> true"
--    , "                    (= (elem@@G x (intersect@@G s1 s2))"
--    , "                       (and (elem@@G x s1) (elem@@G x s2))))))"
--    , "(assert (forall ( (x G)"
--    , "                  (s1 (set G))"
--    , "                  (s2 (set G)) )"
--    , "                (=> true"
--    , "                    (= (elem@@G x (bunion@@G s1 s2))"
--    , "                       (or (elem@@G x s1) (elem@@G x s2))))))"
--    , "(assert (forall ( (x G) )"
--    , "                (=> true (not (elem@@G x empty-set@@G)))))"
--    , "(assert (forall ( (x G)"
--    , "                  (s1 (set G)) )"
--    , "                (=> true (= (elem@@G x s1) (select s1 x)))))"
--    , "(assert (forall ( (s1 (set G))"
--    , "                  (s2 (set G)) )"
--    , "                (=> true"
--    , "                    (= (subset@@G s1 s2)"
--    , "                       (forall ( (x G) )"
--    , "                               (=> true (=> (elem@@G x s1) (elem@@G x s2))))))))"
    , "(assert (not (= true (or (le x y) (le y x)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

get_po :: FilePath -> Label -> IO String
get_po name lbl = do
        r <- runEitherT $ do
            s   <- EitherT $ parse_system path0
            th  <- maybe 
                    (left [Error (format "unknown theory: {0} {1}" name $ keys $ theories s) li])
                    return
                    $ name `M.lookup` theories s
            pos <- hoistEither $ theory_po th
            p   <- maybe 
                    (left $ [Error (format "unknown proof obligation: {0} {1}" lbl $ keys pos) 
                          $ li]) 
                    right 
                    (M.lookup lbl pos)
            return $ unlines $ map pretty_print' $ z3_code p
        return $ either (const "error") id r
    where
        li = LI path0 0 0

parse :: FilePath -> IO String
parse path = do
        makeReport $ do
            EitherT $ parse_system path
            return "ok"

